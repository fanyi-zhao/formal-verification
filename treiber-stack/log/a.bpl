                                                                                                    
 /*                                                                                                 
                                                                                                    
 treiber-stack-linked-list.anchor:                                                                  
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid) || isRead ? B : E                                                
                                                                                                    
       Node next isLocal(this, tid) || isRead ? B : E                                               
                                                                                                    
                                                                                                    
      requires this.next == Node.null;                                                              
                                                                                                    
      public void init(int item) {                                                                  
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class TreiberStack {                                                                            
      volatile Node head N                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head != Node.null;                                                             
        ensures this.head.next == old(this.head);                                                   
        ensures this.head.item == item;                                                             
      }                                                                                             
      public void push(int item) {                                                                  
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node newHead;                                                                           
            newHead = new Node();                                                                   
            newHead.init(item)                                                                      
            Node oldHead;                                                                           
            oldHead := this.head;                                                                   
            yield;                                                                                  
            newHead.next := oldHead;                                                                
            boolean tmp2;                                                                           
            tmp2 = this.head@oldHead :~ newHead;                                                    
            if (tmp2) {                                                                             
               return;                                                                              
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head.next) == this.head;                                                   
        ensures $result == old(this.head.item);                                                     
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp3;                                                                             
          tmp3 = true;                                                                              
          if (!tmp3) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node oldHead;                                                                           
            oldHead := this.head;                                                                   
            yield;                                                                                  
            Node newHead;                                                                           
            newHead := oldHead.next;                                                                
            boolean tmp4;                                                                           
            tmp4 = this.head@oldHead :~ newHead;                                                    
            if (tmp4) {                                                                             
              int tmp5;                                                                             
              tmp5 := oldHead.item;                                                                 
               return tmp5;                                                                         
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid) || isRead ? B : E                                                
                                                                                                    
       Node next isLocal(this, tid) || isRead ? B : E                                               
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
      requires this.next == Node.null;                                                              
                                                                                                    
      public void init(int item) {                                                                  
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class TreiberStack {                                                                            
      hasCASOperation volatile Node head N                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head != Node.null;                                                             
        ensures this.head.next == old(this.head);                                                   
        ensures this.head.item == item;                                                             
      }                                                                                             
      public void push(int item) {                                                                  
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node newHead;                                                                           
            newHead = new Node();                                                                   
            newHead.init(item)                                                                      
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            newHead.next := oldHead;                                                                
            boolean tmp2;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3582;                                                                     
              ctmp3582 = *;                                                                         
              if (ctmp3582) {                                                                       
                noop(TraceOn);                                                                      
                tmp2 = false;                                                                       
              } else {                                                                              
                ctmp3582 = *;                                                                       
                if (ctmp3582) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp2) {                                                                             
              {                                                                                     
                 return;                                                                            
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head.next) == this.head;                                                   
        ensures $result == old(this.head.item);                                                     
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp3;                                                                             
          tmp3 = true;                                                                              
          if (!tmp3) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node newHead;                                                                           
            newHead := oldHead.next;                                                                
            boolean tmp4;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3649;                                                                     
              ctmp3649 = *;                                                                         
              if (ctmp3649) {                                                                       
                noop(TraceOn);                                                                      
                tmp4 = false;                                                                       
              } else {                                                                              
                ctmp3649 = *;                                                                       
                if (ctmp3649) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp4) {                                                                             
              int tmp5;                                                                             
              tmp5 := oldHead.item;                                                                 
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid) || isRead ? B : E                                                
                                                                                                    
       Node next isLocal(this, tid) || isRead ? B : E                                               
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
      requires this.next == Node.null;                                                              
                                                                                                    
      public void init(int item) {                                                                  
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class TreiberStack {                                                                            
      hasCASOperation volatile Node head N                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head != Node.null;                                                             
        ensures this.head.next == old(this.head);                                                   
        ensures this.head.item == item;                                                             
      }                                                                                             
      public void push(int item) {                                                                  
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node newHead;                                                                           
            newHead = new Node();                                                                   
            {                                                                                       
              inlined newHead.init(item);                                                           
              exit$1: {                                                                             
                int item$1;                                                                         
                Node this$1;                                                                        
                item$1 = item;                                                                      
                this$1 = newHead;                                                                   
                {                                                                                   
                  assume this$1.item == 0;                                                          
                  assume this$1.next == Node.null;                                                  
                  {                                                                                 
                    this$1.item := item$1;                                                          
                    {                                                                               
                      break exit$1;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            newHead.next := oldHead;                                                                
            boolean tmp2;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3582;                                                                     
              ctmp3582 = *;                                                                         
              if (ctmp3582) {                                                                       
                noop(TraceOn);                                                                      
                tmp2 = false;                                                                       
              } else {                                                                              
                ctmp3582 = *;                                                                       
                if (ctmp3582) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp2) {                                                                             
              {                                                                                     
                 return;                                                                            
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head.next) == this.head;                                                   
        ensures $result == old(this.head.item);                                                     
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp3;                                                                             
          tmp3 = true;                                                                              
          if (!tmp3) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node newHead;                                                                           
            newHead := oldHead.next;                                                                
            boolean tmp4;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3649;                                                                     
              ctmp3649 = *;                                                                         
              if (ctmp3649) {                                                                       
                noop(TraceOn);                                                                      
                tmp4 = false;                                                                       
              } else {                                                                              
                ctmp3649 = *;                                                                       
                if (ctmp3649) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp4) {                                                                             
              int tmp5;                                                                             
              tmp5 := oldHead.item;                                                                 
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid) || isRead ? B : E                                                
                                                                                                    
       Node next isLocal(this, tid) || isRead ? B : E                                               
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
      requires this.next == Node.null;                                                              
                                                                                                    
      public void init(int item) {                                                                  
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.item := item;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class TreiberStack {                                                                            
      hasCASOperation volatile Node head N                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures this.head != Node.null;                                                             
        ensures this.head.next == old(this.head);                                                   
        ensures this.head.item == item;                                                             
      }                                                                                             
      public void push(int item) {                                                                  
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node newHead;                                                                           
            newHead = new Node();                                                                   
            {                                                                                       
              inlined newHead.init(item);                                                           
              exit$1: {                                                                             
                int item$1;                                                                         
                Node this$1;                                                                        
                item$1 = item;                                                                      
                this$1 = newHead;                                                                   
                {                                                                                   
                  assume this$1.item == 0;                                                          
                  assume this$1.next == Node.null;                                                  
                  {                                                                                 
                    this$1.item := item$1;                                                          
                    {                                                                               
                      break exit$1;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            newHead.next := oldHead;                                                                
            boolean tmp2;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3582;                                                                     
              ctmp3582 = *;                                                                         
              if (ctmp3582) {                                                                       
                noop(TraceOn);                                                                      
                tmp2 = false;                                                                       
              } else {                                                                              
                ctmp3582 = *;                                                                       
                if (ctmp3582) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp2 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp2) {                                                                             
              {                                                                                     
                 return;                                                                            
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        ensures old(this.head.next) == this.head;                                                   
        ensures $result == old(this.head.item);                                                     
      }                                                                                             
      public int pop() {                                                                            
        while (true)   {                                                                            
          boolean tmp3;                                                                             
          tmp3 = true;                                                                              
          if (!tmp3) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node oldHead;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                oldHead := this.head  as R;                                                         
              } else {                                                                              
                noop(TraceOn);                                                                      
                oldHead := this.head;                                                               
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node newHead;                                                                           
            newHead := oldHead.next;                                                                
            boolean tmp4;                                                                           
            {                                                                                       
              noop(TraceOff);                                                                       
              boolean ctmp3649;                                                                     
              ctmp3649 = *;                                                                         
              if (ctmp3649) {                                                                       
                noop(TraceOn);                                                                      
                tmp4 = false;                                                                       
              } else {                                                                              
                ctmp3649 = *;                                                                       
                if (ctmp3649) {                                                                     
                  Tid tmpTid;                                                                       
                  Node tmpValue;                                                                    
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  assume this.head == oldHead;                                                      
                  assume !goesWrong(_m);                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  this.head_nextThread := tmpTid as B;                                              
                  this.head_nextValue := tmpValue as B;                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = true;                                                                      
                } else {                                                                            
                  assume this.head_nextThread == tid;                                               
                  assume this.head_nextValue == oldHead;                                            
                  Node _currentValue;                                                               
                  _currentValue := this.head  as B;                                                 
                  this.head := oldHead as B;                                                        
                  Mover _m;                                                                         
                  _m = writePermission(this.head, newHead);                                         
                  this.head := _currentValue as B;                                                  
                  assume goesWrong(_m);                                                             
                  noop(TraceOn);                                                                    
                  this.head := newHead;                                                             
                  tmp4 = false;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
            if (tmp4) {                                                                             
              int tmp5;                                                                             
              tmp5 := oldHead.item;                                                                 
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if ((isLocal(Node._state[this], tid)||isRead)) then                                                
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((isLocal(Node._state[this], tid)||isRead)) then                                                
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if ((isLocal(Node._state[this], tid)||isRead)) then                                                
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((isLocal(Node._state[this], tid)||isRead)) then                                                
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Node.init(tid:Tid, this : Node, item : int)                                              
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies TreiberStack._state;                                                                       
modifies TreiberStack.head;                                                                         
modifies TreiberStack._lock;                                                                        
modifies TreiberStack.head_nextThread;                                                              
modifies TreiberStack.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (13.5): Bad tid
requires isLocal(Node._state[this], tid);                                                           
requires (forall _x : Node :: this != _x ==> !isLocal(Node._state[_x], tid));                       
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
requires (Node.next[this]==Node.null);                                                              
                                                                                                    
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
{                                                                                                   
 var Node._lock21875: [Node]Tid;                                                                    
 var this21876: Node;                                                                               
 var tid21875: Tid;                                                                                 
 var $recorded.state21876: int;                                                                     
 var TreiberStack.head21876: [TreiberStack]Node;                                                    
 var Node.next21875: [Node]Node;                                                                    
 var TreiberStack._state21875: [TreiberStack]State;                                                 
 var item21875: int;                                                                                
 var $pc21875: Phase;                                                                               
 var path21875: int;                                                                                
 var TreiberStack.head_nextValue21876: [TreiberStack]Node;                                          
 var TreiberStack._lock21876: [TreiberStack]Tid;                                                    
 var TreiberStack._lock21875: [TreiberStack]Tid;                                                    
 var tid21876: Tid;                                                                                 
 var TreiberStack._state21876: [TreiberStack]State;                                                 
 var Node.item21875: [Node]int;                                                                     
 var TreiberStack.head_nextThread21876: [TreiberStack]Tid;                                          
 var $pc21876: Phase;                                                                               
 var Node._lock21876: [Node]Tid;                                                                    
 var item21876: int;                                                                                
 var mover21875: Mover;                                                                             
 var TreiberStack.head21875: [TreiberStack]Node;                                                    
 var moverPath21875: MoverPath;                                                                     
 var TreiberStack.head_nextThread21875: [TreiberStack]Tid;                                          
 var this21875: Node;                                                                               
 var Node.item21876: [Node]int;                                                                     
 var Node._state21876: [Node]State;                                                                 
 var Node._state21875: [Node]State;                                                                 
 var $recorded.state21875: int;                                                                     
 var Node.next21876: [Node]Node;                                                                    
 var TreiberStack.head_nextValue21875: [TreiberStack]Node;                                          
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)),_R);       // (13.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 13.5: assume this.item == 0;                                                                    
                                                                                                    
 assume (Node.item[this]==0);                                                                       
                                                                                                    
 // 13.5: assume this.next == Node.null;                                                            
                                                                                                    
 assume (Node.next[this]==Node.null);                                                               
                                                                                                    
                                                                                                    
 // 14.9: this.item := item;                                                                        
                                                                                                    
                                                                                                    
 moverPath21875 := WriteEval.Node.item(tid: Tid,this: Node,item: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 mover21875 := m#moverPath(moverPath21875);                                                         
 path21875 := p#moverPath(moverPath21875);                                                          
 assume Node._state21875 == Node._state && Node.item21875 == Node.item && Node.next21875 == Node.next && Node._lock21875 == Node._lock && TreiberStack._state21875 == TreiberStack._state && TreiberStack.head21875 == TreiberStack.head && TreiberStack._lock21875 == TreiberStack._lock && TreiberStack.head_nextThread21875 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21875 == TreiberStack.head_nextValue && item21875 == item && this21875 == this && tid21875 == tid && $pc21875 == $pc;
 assume $recorded.state21875 == 1;                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != Node.null;                                                                         
 } else {                                                                                           
  assert this != Node.null;                                                                                // (14.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover21875);                                                                
 assert $pc != PhaseError;                                                                                 // (14.9): Reduction failure
 Node.item[this] := item;                                                                           
                                                                                                    
 // 13.27: // return;                                                                               
                                                                                                    
 assume Node._state21876 == Node._state && Node.item21876 == Node.item && Node.next21876 == Node.next && Node._lock21876 == Node._lock && TreiberStack._state21876 == TreiberStack._state && TreiberStack.head21876 == TreiberStack.head && TreiberStack._lock21876 == TreiberStack._lock && TreiberStack.head_nextThread21876 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21876 == TreiberStack.head_nextValue && item21876 == item && this21876 == this && tid21876 == tid;
 assume $recorded.state21876 == 1;                                                                  
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl TreiberStack ***/                                                                   
                                                                                                    
type TreiberStack;                                                                                  
const unique TreiberStack.null: TreiberStack;                                                       
var TreiberStack._state: [TreiberStack]State;                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var TreiberStack.head: [TreiberStack]Node;                                                          
                                                                                                    
function {:inline} ReadEval.TreiberStack.head(tid: Tid,this : TreiberStack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 moverPath(_N, 0)                                                                                   
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.TreiberStack.head(tid: Tid,this : TreiberStack,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 moverPath(_N, 0)                                                                                   
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var TreiberStack._lock: [TreiberStack]Tid;                                                          
                                                                                                    
function {:inline} ReadEval.TreiberStack._lock(tid: Tid,this : TreiberStack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((TreiberStack._lock[this]==tid)) then                                                        
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((TreiberStack._lock[this]==Tid.null)&&(newValue==tid))) then                                
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((TreiberStack._lock[this]==tid)&&(newValue==Tid.null))) then                               
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.TreiberStack._lock(tid: Tid,this : TreiberStack,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((TreiberStack._lock[this]==tid)) then                                                        
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((TreiberStack._lock[this]==Tid.null)&&(newValue==tid))) then                                
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((TreiberStack._lock[this]==tid)&&(newValue==Tid.null))) then                               
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var TreiberStack.head_nextThread: [TreiberStack]Tid;                                                
                                                                                                    
function {:inline} ReadEval.TreiberStack.head_nextThread(tid: Tid,this : TreiberStack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((TreiberStack.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.TreiberStack.head_nextThread(tid: Tid,this : TreiberStack,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((TreiberStack.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var TreiberStack.head_nextValue: [TreiberStack]Node;                                                
                                                                                                    
function {:inline} ReadEval.TreiberStack.head_nextValue(tid: Tid,this : TreiberStack,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((TreiberStack.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.TreiberStack.head_nextValue(tid: Tid,this : TreiberStack,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(TreiberStack._state[this], tid)) then                                                  
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((TreiberStack.head_nextThread[this]==tid)) then                                               
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  TreiberStack.push(tid:Tid, this : TreiberStack, item : int)                              
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies TreiberStack._state;                                                                       
modifies TreiberStack.head;                                                                         
modifies TreiberStack._lock;                                                                        
modifies TreiberStack.head_nextThread;                                                              
modifies TreiberStack.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (21.5): Bad tid
requires isShared(TreiberStack._state[this]);                                                              // (21.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
{                                                                                                   
 var newHead22022: Node;                                                                            
 var TreiberStack._state22130: [TreiberStack]State;                                                 
 var TreiberStack.head_nextValue22022_post: [TreiberStack]Node;                                     
 var this22147: TreiberStack;                                                                       
 var tmp222085: bool;                                                                               
 var $pc22092: Phase;                                                                               
 var TreiberStack._lock22022: [TreiberStack]Tid;                                                    
 var path22088: int;                                                                                
 var this22130: TreiberStack;                                                                       
 var tid22155: Tid;                                                                                 
 var $recorded.state22115: int;                                                                     
 var Node._lock22130: [Node]Tid;                                                                    
 var TreiberStack.head22085: [TreiberStack]Node;                                                    
 var Node._lock22092: [Node]Tid;                                                                    
 var oldHead22085: Node;                                                                            
 var newHead22013: Node;                                                                            
 var this22025: TreiberStack;                                                                       
 var TreiberStack.head_nextValue22155: [TreiberStack]Node;                                          
 var TreiberStack.head_nextValue22118: [TreiberStack]Node;                                          
 var TreiberStack.head_nextThread22025: [TreiberStack]Tid;                                          
 var tid22118: Tid;                                                                                 
 var TreiberStack._state22085: [TreiberStack]State;                                                 
 var TreiberStack.head22130: [TreiberStack]Node;                                                    
 var _C_t: Tid;                                                                                     
 var item22092: int;                                                                                
 var moverPath22092: MoverPath;                                                                     
 var Node.next22137: [Node]Node;                                                                    
 var _C_v21975: Node;                                                                               
 var Node.next22154_bottom: [Node]Node;                                                             
 var TreiberStack._lock22018: [TreiberStack]Tid;                                                    
 var TreiberStack.head_nextValue22137: [TreiberStack]Node;                                          
 var Node._state22022_post: [Node]State;                                                            
 var path22085: int;                                                                                
 var tmp121942: bool;                                                                               
 var item21942: int;                                                                                
 var TreiberStack.head_nextThread22092: [TreiberStack]Tid;                                          
 var TreiberStack.head22022_post: [TreiberStack]Node;                                               
 var newHead22018: Node;                                                                            
 var $recorded.state22022_post: int;                                                                
 var _R_t22013: Mover;                                                                              
 var TreiberStack._state22147: [TreiberStack]State;                                                 
 var $pc22154: Phase;                                                                               
 var ctmp358222130: bool;                                                                           
 var $recorded.state22118: int;                                                                     
 var Node.item22013: [Node]int;                                                                     
 var $pc21975: Phase;                                                                               
 var TreiberStack.head_nextThread22115: [TreiberStack]Tid;                                          
 var this22088: TreiberStack;                                                                       
 var mover22092: Mover;                                                                             
 var tmpValue22092: Node;                                                                           
 var mover22115: Mover;                                                                             
 var tmpValue: Node;                                                                                
 var Node.next22115: [Node]Node;                                                                    
 var _casable: bool;                                                                                
 var tmpTid22088: Tid;                                                                              
 var TreiberStack.head21963: [TreiberStack]Node;                                                    
 var oldHead22092: Node;                                                                            
 var _casable22013: bool;                                                                           
 var tmp121963: bool;                                                                               
 var TreiberStack._state22118: [TreiberStack]State;                                                 
 var TreiberStack._lock21963: [TreiberStack]Tid;                                                    
 var oldHead22130: Node;                                                                            
 var Node._lock22118: [Node]Tid;                                                                    
 var TreiberStack.head_nextThread22022_post: [TreiberStack]Tid;                                     
 var this22022: TreiberStack;                                                                       
 var path22025: int;                                                                                
 var TreiberStack.head_nextThread22118: [TreiberStack]Tid;                                          
 var TreiberStack._lock22147: [TreiberStack]Tid;                                                    
 var newHead22118: Node;                                                                            
 var Node._state21942: [Node]State;                                                                 
 var path22115: int;                                                                                
 var _m22092: Mover;                                                                                
 var item22088: int;                                                                                
 var TreiberStack.head_nextThread22154_bottom: [TreiberStack]Tid;                                   
 var tid22137: Tid;                                                                                 
 var TreiberStack.head_nextThread22088: [TreiberStack]Tid;                                          
 var newHead22025: Node;                                                                            
 var mover21975: Mover;                                                                             
 var oldHead22022_post: Node;                                                                       
 var _m22085: Mover;                                                                                
 var tmp222115: bool;                                                                               
 var Node._lock22022: [Node]Tid;                                                                    
 var item21969: int;                                                                                
 var _m22130: Mover;                                                                                
 var newHead: Node;                                                                                 
 var mover21963: Mover;                                                                             
 var Node._state21963: [Node]State;                                                                 
 var ctmp358222115: bool;                                                                           
 var TreiberStack._lock21975: [TreiberStack]Tid;                                                    
 var tmp1: bool;                                                                                    
 var Node.item22118: [Node]int;                                                                     
 var _currentValue22118: Node;                                                                      
 var TreiberStack._lock21969: [TreiberStack]Tid;                                                    
 var TreiberStack.head22022: [TreiberStack]Node;                                                    
 var Node.next22022_post: [Node]Node;                                                               
 var TreiberStack.head_nextThread21942: [TreiberStack]Tid;                                          
 var this21975: TreiberStack;                                                                       
 var TreiberStack._lock22022_post: [TreiberStack]Tid;                                               
 var tmpValue22088: Node;                                                                           
 var ctmp3582: bool;                                                                                
 var Node._state22118: [Node]State;                                                                 
 var mover22130: Mover;                                                                             
 var Node.item22154_bottom: [Node]int;                                                              
 var tmpValue22085: Node;                                                                           
 var TreiberStack._lock22130: [TreiberStack]Tid;                                                    
 var this21963: TreiberStack;                                                                       
 var _C_t21975: Tid;                                                                                
 var item22154: int;                                                                                
 var newHead22130: Node;                                                                            
 var $recorded.state22155: int;                                                                     
 var tid22022: Tid;                                                                                 
 var Node._state22154: [Node]State;                                                                 
 var TreiberStack.head_nextThread22022: [TreiberStack]Tid;                                          
 var Node._lock22137: [Node]Tid;                                                                    
 var tmp2: bool;                                                                                    
 var Node.next22147: [Node]Node;                                                                    
 var item22118: int;                                                                                
 var item22147: int;                                                                                
 var path21942: int;                                                                                
 var item21975: int;                                                                                
 var item22130: int;                                                                                
 var item$1: int;                                                                                   
 var TreiberStack.head22155: [TreiberStack]Node;                                                    
 var oldHead22025: Node;                                                                            
 var $pc22115: Phase;                                                                               
 var oldHead21963: Node;                                                                            
 var Node._lock22115: [Node]Tid;                                                                    
 var tid22088: Tid;                                                                                 
 var moverPath22085: MoverPath;                                                                     
 var TreiberStack.head22092: [TreiberStack]Node;                                                    
 var item22013: int;                                                                                
 var Node._state22022: [Node]State;                                                                 
 var Node.item22130: [Node]int;                                                                     
 var tmp122022_post: bool;                                                                          
 var Node._lock22147: [Node]Tid;                                                                    
 var TreiberStack.head22137: [TreiberStack]Node;                                                    
 var Node.item22092: [Node]int;                                                                     
 var Node._state22137: [Node]State;                                                                 
 var Node.item22115: [Node]int;                                                                     
 var this22118: TreiberStack;                                                                       
 var this22154_bottom: TreiberStack;                                                                
 var path22118: int;                                                                                
 var _casable22018: bool;                                                                           
 var tmp122013: bool;                                                                               
 var tmp121969: bool;                                                                               
 var $pc21969: Phase;                                                                               
 var $recorded.state22088: int;                                                                     
 var TreiberStack.head_nextThread22154: [TreiberStack]Tid;                                          
 var oldHead22147: Node;                                                                            
 var TreiberStack.head_nextValue21975: [TreiberStack]Node;                                          
 var Node.next22025: [Node]Node;                                                                    
 var Node._state22115: [Node]State;                                                                 
 var Node._state22092: [Node]State;                                                                 
 var tmp122137: bool;                                                                               
 var _C_t22013: Tid;                                                                                
 var this21969: TreiberStack;                                                                       
 var TreiberStack._state22013: [TreiberStack]State;                                                 
 var Node._lock22154_bottom: [Node]Tid;                                                             
 var this22115: TreiberStack;                                                                       
 var _currentValue22130: Node;                                                                      
 var tid22022_post: Tid;                                                                            
 var Node.next21942: [Node]Node;                                                                    
 var _currentValue22115: Node;                                                                      
 var newHead21942: Node;                                                                            
 var Node._lock21975: [Node]Tid;                                                                    
 var moverPath22115: MoverPath;                                                                     
 var moverPath22130: MoverPath;                                                                     
 var _C_v: Node;                                                                                    
 var moverPath22018: MoverPath;                                                                     
 var TreiberStack.head22088: [TreiberStack]Node;                                                    
 var tid21975: Tid;                                                                                 
 var Node._lock21969: [Node]Tid;                                                                    
 var TreiberStack._state22022: [TreiberStack]State;                                                 
 var $recorded.state22013: int;                                                                     
 var TreiberStack.head22154: [TreiberStack]Node;                                                    
 var TreiberStack._state21963: [TreiberStack]State;                                                 
 var TreiberStack._state22115: [TreiberStack]State;                                                 
 var tid22013: Tid;                                                                                 
 var Node._state22155: [Node]State;                                                                 
 var ctmp358222118: bool;                                                                           
 var TreiberStack._state22137: [TreiberStack]State;                                                 
 var newHead22137: Node;                                                                            
 var Node._lock22018: [Node]Tid;                                                                    
 var Node._lock22154: [Node]Tid;                                                                    
 var TreiberStack._state21975: [TreiberStack]State;                                                 
 var Node.item22022_post: [Node]int;                                                                
 var $recorded.state22025: int;                                                                     
 var moverPath21975: MoverPath;                                                                     
 var $recorded.state21942: int;                                                                     
 var Node._lock22085: [Node]Tid;                                                                    
 var moverPath22137: MoverPath;                                                                     
 var _currentValue21975: Node;                                                                      
 var tid21942: Tid;                                                                                 
 var $pc22147: Phase;                                                                               
 var newHead22022_post: Node;                                                                       
 var _C_t21963: Tid;                                                                                
 var Node.next22130: [Node]Node;                                                                    
 var mover22018: Mover;                                                                             
 var ctmp358222092: bool;                                                                           
 var TreiberStack.head_nextValue21963: [TreiberStack]Node;                                          
 var Node._state22013: [Node]State;                                                                 
 var TreiberStack._state22025: [TreiberStack]State;                                                 
 var Node.item22018: [Node]int;                                                                     
 var tid22025: Tid;                                                                                 
 var Node._state22130: [Node]State;                                                                 
 var TreiberStack._state21942: [TreiberStack]State;                                                 
 var TreiberStack._lock22085: [TreiberStack]Tid;                                                    
 var _C_v22018: Node;                                                                               
 var this22137: TreiberStack;                                                                       
 var $recorded.state22137: int;                                                                     
 var item22137: int;                                                                                
 var $pc22088: Phase;                                                                               
 var $recorded.state22085: int;                                                                     
 var tid22092: Tid;                                                                                 
 var newHead21975: Node;                                                                            
 var TreiberStack.head22018: [TreiberStack]Node;                                                    
 var Node.item22155: [Node]int;                                                                     
 var newHead21969: Node;                                                                            
 var oldHead: Node;                                                                                 
 var TreiberStack._lock22154: [TreiberStack]Tid;                                                    
 var Node.item21975: [Node]int;                                                                     
 var item22018: int;                                                                                
 var TreiberStack.head_nextThread21969: [TreiberStack]Tid;                                          
 var this$1: Node;                                                                                  
 var TreiberStack.head22118: [TreiberStack]Node;                                                    
 var TreiberStack._lock22154_bottom: [TreiberStack]Tid;                                             
 var TreiberStack.head_nextThread22137: [TreiberStack]Tid;                                          
 var Node.item22088: [Node]int;                                                                     
 var TreiberStack.head21969: [TreiberStack]Node;                                                    
 var Node._lock21963: [Node]Tid;                                                                    
 var Node.next22088: [Node]Node;                                                                    
 var mover22013: Mover;                                                                             
 var Node.next22013: [Node]Node;                                                                    
 var this$121942: Node;                                                                             
 var $pc22118: Phase;                                                                               
 var TreiberStack._lock21942: [TreiberStack]Tid;                                                    
 var newHead21963: Node;                                                                            
 var TreiberStack.head_nextThread21963: [TreiberStack]Tid;                                          
 var TreiberStack.head22025: [TreiberStack]Node;                                                    
 var $recorded.state21969: int;                                                                     
 var Node._state21975: [Node]State;                                                                 
 var newHead22115: Node;                                                                            
 var this22013: TreiberStack;                                                                       
 var mover21942: Mover;                                                                             
 var $recorded.state21975: int;                                                                     
 var tmp122018: bool;                                                                               
 var _m22137: Mover;                                                                                
 var item$121942: int;                                                                              
 var $recorded.state22130: int;                                                                     
 var $pc22130: Phase;                                                                               
 var tmpTid22085: Tid;                                                                              
 var TreiberStack._lock22025: [TreiberStack]Tid;                                                    
 var tmp222088: bool;                                                                               
 var TreiberStack.head22013: [TreiberStack]Node;                                                    
 var Node._lock21942: [Node]Tid;                                                                    
 var TreiberStack._state22155: [TreiberStack]State;                                                 
 var _C_t21969: Tid;                                                                                
 var moverPath22013: MoverPath;                                                                     
 var $recorded.state22018: int;                                                                     
 var mover22088: Mover;                                                                             
 var moverPath21963: MoverPath;                                                                     
 var oldHead21975: Node;                                                                            
 var tmp122147: bool;                                                                               
 var $pc22013: Phase;                                                                               
 var _currentValue: Node;                                                                           
 var ctmp358222085: bool;                                                                           
 var _C_v21969: Node;                                                                               
 var path21969: int;                                                                                
 var tmp222118: bool;                                                                               
 var TreiberStack._lock22092: [TreiberStack]Tid;                                                    
 var oldHead22013: Node;                                                                            
 var Node._state22154_bottom: [Node]State;                                                          
 var TreiberStack.head_nextValue22115: [TreiberStack]Node;                                          
 var TreiberStack.head_nextValue22154: [TreiberStack]Node;                                          
 var TreiberStack.head_nextValue21942: [TreiberStack]Node;                                          
 var TreiberStack._state22154_bottom: [TreiberStack]State;                                          
 var TreiberStack.head_nextValue22013: [TreiberStack]Node;                                          
 var _R_t: Mover;                                                                                   
 var tmp122088: bool;                                                                               
 var path22018: int;                                                                                
 var moverPath22088: MoverPath;                                                                     
 var tid22085: Tid;                                                                                 
 var path22013: int;                                                                                
 var this22092: TreiberStack;                                                                       
 var oldHead22137: Node;                                                                            
 var _C_t22018: Tid;                                                                                
 var _m: Mover;                                                                                     
 var Node.next22018: [Node]Node;                                                                    
 var newHead22147: Node;                                                                            
 var TreiberStack.head22115: [TreiberStack]Node;                                                    
 var Node._state21969: [Node]State;                                                                 
 var Node.next21969: [Node]Node;                                                                    
 var newHead22085: Node;                                                                            
 var item22115: int;                                                                                
 var _R_t22018: Mover;                                                                              
 var $recorded.state22022: int;                                                                     
 var this22085: TreiberStack;                                                                       
 var TreiberStack.head_nextValue22088: [TreiberStack]Node;                                          
 var TreiberStack.head_nextValue22085: [TreiberStack]Node;                                          
 var TreiberStack._state22022_post: [TreiberStack]State;                                            
 var TreiberStack.head_nextValue22130: [TreiberStack]Node;                                          
 var Node.item21969: [Node]int;                                                                     
 var TreiberStack.head_nextThread22013: [TreiberStack]Tid;                                          
 var tmp222092: bool;                                                                               
 var Node._lock22025: [Node]Tid;                                                                    
 var mover22118: Mover;                                                                             
 var oldHead22022: Node;                                                                            
 var item22085: int;                                                                                
 var $recorded.state21963: int;                                                                     
 var oldHead22018: Node;                                                                            
 var oldHead22118: Node;                                                                            
 var tid21963: Tid;                                                                                 
 var oldHead21969: Node;                                                                            
 var TreiberStack.head22147: [TreiberStack]Node;                                                    
 var $recorded.state22154_bottom: int;                                                              
 var ctmp358222088: bool;                                                                           
 var Node._state22025: [Node]State;                                                                 
 var Node._lock22088: [Node]Tid;                                                                    
 var $pc22022_post: Phase;                                                                          
 var Node.next22085: [Node]Node;                                                                    
 var $pc22022: Phase;                                                                               
 var item22025: int;                                                                                
 var tmp222147: bool;                                                                               
 var Node._lock22013: [Node]Tid;                                                                    
 var TreiberStack.head_nextThread21975: [TreiberStack]Tid;                                          
 var item22154_bottom: int;                                                                         
 var oldHead22115: Node;                                                                            
 var Node.item21942: [Node]int;                                                                     
 var Node.item22022: [Node]int;                                                                     
 var item22022_post: int;                                                                           
 var TreiberStack.head_nextThread22018: [TreiberStack]Tid;                                          
 var Node._state22018: [Node]State;                                                                 
 var Node.item22147: [Node]int;                                                                     
 var Node.next22154: [Node]Node;                                                                    
 var Node.next21975: [Node]Node;                                                                    
 var TreiberStack.head22154_bottom: [TreiberStack]Node;                                             
 var TreiberStack.head_nextValue22022: [TreiberStack]Node;                                          
 var Node._lock22155: [Node]Tid;                                                                    
 var path22137: int;                                                                                
 var tmp122130: bool;                                                                               
 var this22022_post: TreiberStack;                                                                  
 var tmp122118: bool;                                                                               
 var TreiberStack.head_nextValue22147: [TreiberStack]Node;                                          
 var mover22025: Mover;                                                                             
 var this22154: TreiberStack;                                                                       
 var mover21969: Mover;                                                                             
 var $pc22018: Phase;                                                                               
 var tmp122085: bool;                                                                               
 var tmpTid: Tid;                                                                                   
 var $pc22154_bottom: Phase;                                                                        
 var this22155: TreiberStack;                                                                       
 var item22022: int;                                                                                
 var TreiberStack._lock22118: [TreiberStack]Tid;                                                    
 var path21975: int;                                                                                
 var item21963: int;                                                                                
 var TreiberStack._lock22088: [TreiberStack]Tid;                                                    
 var tid22154: Tid;                                                                                 
 var this21942: TreiberStack;                                                                       
 var Node.next21963: [Node]Node;                                                                    
 var TreiberStack.head21975: [TreiberStack]Node;                                                    
 var tid22154_bottom: Tid;                                                                          
 var $pc22085: Phase;                                                                               
 var tmp122092: bool;                                                                               
 var TreiberStack._lock22155: [TreiberStack]Tid;                                                    
 var TreiberStack._state22154: [TreiberStack]State;                                                 
 var TreiberStack.head_nextThread22085: [TreiberStack]Tid;                                          
 var TreiberStack.head_nextValue22092: [TreiberStack]Node;                                          
 var $recorded.state22092: int;                                                                     
 var tmpTid22092: Tid;                                                                              
 var TreiberStack.head21942: [TreiberStack]Node;                                                    
 var TreiberStack._state22092: [TreiberStack]State;                                                 
 var tid22147: Tid;                                                                                 
 var Node._lock22022_post: [Node]Tid;                                                               
 var TreiberStack._state22088: [TreiberStack]State;                                                 
 var tmp122115: bool;                                                                               
 var moverPath22118: MoverPath;                                                                     
 var $pc22025: Phase;                                                                               
 var tid22115: Tid;                                                                                 
 var TreiberStack.head_nextThread22147: [TreiberStack]Tid;                                          
 var phase22154: Phase;                                                                             
 var tid21969: Tid;                                                                                 
 var Node.next22022: [Node]Node;                                                                    
 var Node._state22147: [Node]State;                                                                 
 var oldHead22088: Node;                                                                            
 var TreiberStack.head_nextValue21969: [TreiberStack]Node;                                          
 var _currentValue22137: Node;                                                                      
 var tid22130: Tid;                                                                                 
 var path21963: int;                                                                                
 var $pc22155: Phase;                                                                               
 var $recorded.state22147: int;                                                                     
 var this22018: TreiberStack;                                                                       
 var TreiberStack.head_nextThread22155: [TreiberStack]Tid;                                          
 var mover22085: Mover;                                                                             
 var moverPath22025: MoverPath;                                                                     
 var newHead22088: Node;                                                                            
 var Node.item22025: [Node]int;                                                                     
 var Node.item22154: [Node]int;                                                                     
 var TreiberStack._lock22137: [TreiberStack]Tid;                                                    
 var tmp122025: bool;                                                                               
 var tmp121975: bool;                                                                               
 var item22155: int;                                                                                
 var newHead22092: Node;                                                                            
 var $pc22137: Phase;                                                                               
 var tid22018: Tid;                                                                                 
 var _currentValue22018: Node;                                                                      
 var path22130: int;                                                                                
 var Node.item22085: [Node]int;                                                                     
 var TreiberStack.head_nextValue22154_bottom: [TreiberStack]Node;                                   
 var TreiberStack._lock22013: [TreiberStack]Tid;                                                    
 var $pc21963: Phase;                                                                               
 var tmp122022: bool;                                                                               
 var path22092: int;                                                                                
 var Node.item22137: [Node]int;                                                                     
 var ctmp358222137: bool;                                                                           
 var TreiberStack.head_nextValue22018: [TreiberStack]Node;                                          
 var TreiberStack._lock22115: [TreiberStack]Tid;                                                    
 var _currentValue22013: Node;                                                                      
 var TreiberStack._state21969: [TreiberStack]State;                                                 
 var tmp222130: bool;                                                                               
 var moverPath21942: MoverPath;                                                                     
 var Node.item21963: [Node]int;                                                                     
 var tmp222137: bool;                                                                               
 var Node._state22088: [Node]State;                                                                 
 var Node.next22118: [Node]Node;                                                                    
 var $pc21942: Phase;                                                                               
 var Node._state22085: [Node]State;                                                                 
 var TreiberStack.head_nextValue22025: [TreiberStack]Node;                                          
 var Node.next22092: [Node]Node;                                                                    
 var _C_v22013: Node;                                                                               
 var moverPath21969: MoverPath;                                                                     
 var Node.next22155: [Node]Node;                                                                    
 var mover22137: Mover;                                                                             
 var $recorded.state22154: int;                                                                     
 var _m22088: Mover;                                                                                
 var TreiberStack.head_nextThread22130: [TreiberStack]Tid;                                          
 var TreiberStack._state22018: [TreiberStack]State;                                                 
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state22154 == Node._state && Node.item22154 == Node.item && Node.next22154 == Node.next && Node._lock22154 == Node._lock && TreiberStack._state22154 == TreiberStack._state && TreiberStack.head22154 == TreiberStack.head && TreiberStack._lock22154 == TreiberStack._lock && TreiberStack.head_nextThread22154 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22154 == TreiberStack.head_nextValue && item22154 == item && this22154 == this && tid22154 == tid;
 assume $recorded.state22154 == 1;                                                                  
                                                                                                    
 // 39.9: while (true)   {                                                                          
                                                                                                    
 phase22154 := $pc;                                                                                 
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (21.5): Bad tid
  invariant isShared(TreiberStack._state[this]);                                                           // (21.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state22154,Node.item22154,Node.next22154,Node._lock22154,TreiberStack._state22154,TreiberStack.head22154,TreiberStack._lock22154,TreiberStack.head_nextThread22154,TreiberStack.head_nextValue22154));       // (39.9): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state22154,Node.item22154,Node.next22154,Node._lock22154,TreiberStack._state22154,TreiberStack.head22154,TreiberStack._lock22154,TreiberStack.head_nextThread22154,TreiberStack.head_nextValue22154));       // (39.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : TreiberStack :: Invariant.Y_TreiberStack.head(tid : Tid, _this, TreiberStack.head[_this] ,Node._state22154,Node.item22154,Node.next22154,Node._lock22154,TreiberStack._state22154,TreiberStack.head22154,TreiberStack._lock22154,TreiberStack.head_nextThread22154,TreiberStack.head_nextValue22154));       // (39.9): Loop does not preserve yields_as annotation for field head
  invariant phase22154 == $pc;                                                                             // (39.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (39.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 39.16: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 39.16: tmp1 = true;                                                                            
                                                                                                    
  tmp1 := true;                                                                                     
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 39.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 40.13: Node newHead;                                                                           
                                                                                                    
                                                                                                    
  // 40.13: newHead = new Node();                                                                   
                                                                                                    
  havoc newHead;                                                                                    
  assume newHead != Node.null && isFresh(Node._state[newHead]);                                     
  Node._state[newHead] := LOCAL(tid);                                                               
  assume Node.item[newHead]  == 0;                                                                  
  assume Node.next[newHead]  == Node.null;                                                          
  assume Node._lock[newHead]  == Tid.null;                                                          
  // inlined: newHead.init(item)}                                                                   
  exit$1_top:                                                                                       
                                                                                                    
  // 40.13: int item$1;                                                                             
                                                                                                    
                                                                                                    
  // 40.13: Node this$1;                                                                            
                                                                                                    
                                                                                                    
  // 40.13: item$1 = item;                                                                          
                                                                                                    
  item$1 := item;                                                                                   
                                                                                                    
  // 40.13: this$1 = newHead;                                                                       
                                                                                                    
  this$1 := newHead;                                                                                
                                                                                                    
  // 13.5: assume this$1.item == 0;                                                                 
                                                                                                    
  assume (Node.item[this$1]==0);                                                                    
                                                                                                    
  // 13.5: assume this$1.next == Node.null;                                                         
                                                                                                    
  assume (Node.next[this$1]==Node.null);                                                            
                                                                                                    
                                                                                                    
  // 14.9: this$1.item := item$1;                                                                   
                                                                                                    
                                                                                                    
  moverPath21942 := WriteEval.Node.item(tid: Tid,this$1: Node,item$1: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover21942 := m#moverPath(moverPath21942);                                                        
  path21942 := p#moverPath(moverPath21942);                                                         
  assume Node._state21942 == Node._state && Node.item21942 == Node.item && Node.next21942 == Node.next && Node._lock21942 == Node._lock && TreiberStack._state21942 == TreiberStack._state && TreiberStack.head21942 == TreiberStack.head && TreiberStack._lock21942 == TreiberStack._lock && TreiberStack.head_nextThread21942 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21942 == TreiberStack.head_nextValue && this$121942 == this$1 && item$121942 == item$1 && newHead21942 == newHead && tmp121942 == tmp1 && item21942 == item && this21942 == this && tid21942 == tid && $pc21942 == $pc;
  assume $recorded.state21942 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this$1 != Node.null;                                                                      
  } else {                                                                                          
   assert this$1 != Node.null;                                                                             // (14.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover21942);                                                               
  assert $pc != PhaseError;                                                                                // (14.9): Reduction failure
  Node.item[this$1] := item$1;                                                                      
                                                                                                    
  // 13.27: break exit$1;                                                                           
                                                                                                    
  goto exit$1_bottom;                                                                               
  exit$1_bottom:                                                                                    
                                                                                                    
  // 41.13: Node oldHead;                                                                           
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 41.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 41.13: _C_t := this.head_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath21963 := ReadEval.TreiberStack.head_nextThread(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover21963 := m#moverPath(moverPath21963);                                                        
  path21963 := p#moverPath(moverPath21963);                                                         
  assume Node._state21963 == Node._state && Node.item21963 == Node.item && Node.next21963 == Node.next && Node._lock21963 == Node._lock && TreiberStack._state21963 == TreiberStack._state && TreiberStack.head21963 == TreiberStack.head && TreiberStack._lock21963 == TreiberStack._lock && TreiberStack.head_nextThread21963 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21963 == TreiberStack.head_nextValue && _C_t21963 == _C_t && oldHead21963 == oldHead && newHead21963 == newHead && tmp121963 == tmp1 && item21963 == item && this21963 == this && tid21963 == tid && $pc21963 == $pc;
  assume $recorded.state21963 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (41.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (41.13): Reduction failure
  _C_t := TreiberStack.head_nextThread[this];                                                       
                                                                                                    
  // 41.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 41.13: _C_v := this.head_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath21969 := ReadEval.TreiberStack.head_nextValue(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover21969 := m#moverPath(moverPath21969);                                                        
  path21969 := p#moverPath(moverPath21969);                                                         
  assume Node._state21969 == Node._state && Node.item21969 == Node.item && Node.next21969 == Node.next && Node._lock21969 == Node._lock && TreiberStack._state21969 == TreiberStack._state && TreiberStack.head21969 == TreiberStack.head && TreiberStack._lock21969 == TreiberStack._lock && TreiberStack.head_nextThread21969 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21969 == TreiberStack.head_nextValue && _C_v21969 == _C_v && _C_t21969 == _C_t && oldHead21969 == oldHead && newHead21969 == newHead && tmp121969 == tmp1 && item21969 == item && this21969 == this && tid21969 == tid && $pc21969 == $pc;
  assume $recorded.state21969 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (41.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (41.13): Reduction failure
  _C_v := TreiberStack.head_nextValue[this];                                                        
                                                                                                    
  // 41.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 41.13: _currentValue := this.head  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath21975 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover21975 := m#moverPath(moverPath21975);                                                        
  path21975 := p#moverPath(moverPath21975);                                                         
  assume Node._state21975 == Node._state && Node.item21975 == Node.item && Node.next21975 == Node.next && Node._lock21975 == Node._lock && TreiberStack._state21975 == TreiberStack._state && TreiberStack.head21975 == TreiberStack.head && TreiberStack._lock21975 == TreiberStack._lock && TreiberStack.head_nextThread21975 == TreiberStack.head_nextThread && TreiberStack.head_nextValue21975 == TreiberStack.head_nextValue && _currentValue21975 == _currentValue && _C_v21975 == _C_v && _C_t21975 == _C_t && oldHead21975 == oldHead && newHead21975 == newHead && tmp121975 == tmp1 && item21975 == item && this21975 == this && tid21975 == tid && $pc21975 == $pc;
  assume $recorded.state21975 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (41.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (41.13): Reduction failure
  _currentValue := TreiberStack.head[this];                                                         
                                                                                                    
  // 41.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 41.13: _R_t = readPermission(this.head);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
  // 41.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 41.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 41.13: oldHead := this.head  as R;                                                            
                                                                                                    
                                                                                                    
   moverPath22013 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
   mover22013 := m#moverPath(moverPath22013);                                                       
   path22013 := p#moverPath(moverPath22013);                                                        
   assume Node._state22013 == Node._state && Node.item22013 == Node.item && Node.next22013 == Node.next && Node._lock22013 == Node._lock && TreiberStack._state22013 == TreiberStack._state && TreiberStack.head22013 == TreiberStack.head && TreiberStack._lock22013 == TreiberStack._lock && TreiberStack.head_nextThread22013 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22013 == TreiberStack.head_nextValue && _casable22013 == _casable && _R_t22013 == _R_t && _currentValue22013 == _currentValue && _C_v22013 == _C_v && _C_t22013 == _C_t && oldHead22013 == oldHead && newHead22013 == newHead && tmp122013 == tmp1 && item22013 == item && this22013 == this && tid22013 == tid && $pc22013 == $pc;
   assume $recorded.state22013 == 1;                                                                
   if ($pc == PreCommit) {                                                                          
    assume this != TreiberStack.null;                                                               
   } else {                                                                                         
    assert this != TreiberStack.null;                                                                      // (41.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (41.13): Reduction failure
   oldHead := TreiberStack.head[this];                                                              
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 41.13: oldHead := this.head;                                                                  
                                                                                                    
                                                                                                    
   moverPath22018 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
   mover22018 := m#moverPath(moverPath22018);                                                       
   path22018 := p#moverPath(moverPath22018);                                                        
   assume Node._state22018 == Node._state && Node.item22018 == Node.item && Node.next22018 == Node.next && Node._lock22018 == Node._lock && TreiberStack._state22018 == TreiberStack._state && TreiberStack.head22018 == TreiberStack.head && TreiberStack._lock22018 == TreiberStack._lock && TreiberStack.head_nextThread22018 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22018 == TreiberStack.head_nextValue && _casable22018 == _casable && _R_t22018 == _R_t && _currentValue22018 == _currentValue && _C_v22018 == _C_v && _C_t22018 == _C_t && oldHead22018 == oldHead && newHead22018 == newHead && tmp122018 == tmp1 && item22018 == item && this22018 == this && tid22018 == tid && $pc22018 == $pc;
   assume $recorded.state22018 == 1;                                                                
   if ($pc == PreCommit) {                                                                          
    assume this != TreiberStack.null;                                                               
   } else {                                                                                         
    assert this != TreiberStack.null;                                                                      // (41.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover22018);                                                              
   assert $pc != PhaseError;                                                                               // (41.13): Reduction failure
   oldHead := TreiberStack.head[this];                                                              
  }                                                                                                 
                                                                                                    
  // 42.13: yield;                                                                                  
                                                                                                    
  assume Node._state22022 == Node._state && Node.item22022 == Node.item && Node.next22022 == Node.next && Node._lock22022 == Node._lock && TreiberStack._state22022 == TreiberStack._state && TreiberStack.head22022 == TreiberStack.head && TreiberStack._lock22022 == TreiberStack._lock && TreiberStack.head_nextThread22022 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22022 == TreiberStack.head_nextValue && oldHead22022 == oldHead && newHead22022 == newHead && tmp122022 == tmp1 && item22022 == item && this22022 == this && tid22022 == tid;
  assume $recorded.state22022 == 1;                                                                 
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state22022_post == Node._state && Node.item22022_post == Node.item && Node.next22022_post == Node.next && Node._lock22022_post == Node._lock && TreiberStack._state22022_post == TreiberStack._state && TreiberStack.head22022_post == TreiberStack.head && TreiberStack._lock22022_post == TreiberStack._lock && TreiberStack.head_nextThread22022_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue22022_post == TreiberStack.head_nextValue && oldHead22022_post == oldHead && newHead22022_post == newHead && tmp122022_post == tmp1 && item22022_post == item && this22022_post == this && tid22022_post == tid;
  assume $recorded.state22022_post == 1;                                                            
                                                                                                    
                                                                                                    
  // 43.13: newHead.next := oldHead;                                                                
                                                                                                    
                                                                                                    
  moverPath22025 := WriteEval.Node.next(tid: Tid,newHead: Node,oldHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover22025 := m#moverPath(moverPath22025);                                                        
  path22025 := p#moverPath(moverPath22025);                                                         
  assume Node._state22025 == Node._state && Node.item22025 == Node.item && Node.next22025 == Node.next && Node._lock22025 == Node._lock && TreiberStack._state22025 == TreiberStack._state && TreiberStack.head22025 == TreiberStack.head && TreiberStack._lock22025 == TreiberStack._lock && TreiberStack.head_nextThread22025 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22025 == TreiberStack.head_nextValue && oldHead22025 == oldHead && newHead22025 == newHead && tmp122025 == tmp1 && item22025 == item && this22025 == this && tid22025 == tid && $pc22025 == $pc;
  assume $recorded.state22025 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume newHead != Node.null;                                                                     
  } else {                                                                                          
   assert newHead != Node.null;                                                                            // (43.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover22025);                                                               
  assert $pc != PhaseError;                                                                                // (43.13): Reduction failure
  Node.next[newHead] := oldHead;                                                                    
  if (isLocal(Node._state[oldHead], tid)) {                                                         
   Node._state[oldHead] := SHARED();                                                                
   assert isSharedAssignable(Node._state[Node.next[oldHead]]);                                             // (43.13): oldHead became shared, but oldHead.next may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 44.13: boolean tmp2;                                                                           
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 44.13: boolean ctmp3582;                                                                       
                                                                                                    
                                                                                                    
  // 44.13: ctmp3582 = *;                                                                           
                                                                                                    
  havoc ctmp3582;                                                                                   
  if (ctmp3582) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 44.13: tmp2 = false;                                                                          
                                                                                                    
   tmp2 := false;                                                                                   
  } else {                                                                                          
                                                                                                    
   // 44.13: ctmp3582 = *;                                                                          
                                                                                                    
   havoc ctmp3582;                                                                                  
   if (ctmp3582) {                                                                                  
                                                                                                    
    // 44.13: Tid tmpTid;                                                                           
                                                                                                    
                                                                                                    
    // 44.13: Node tmpValue;                                                                        
                                                                                                    
                                                                                                    
    // 44.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 44.13: _m = writePermission(this.head, newHead);                                             
                                                                                                    
    _m := m#moverPath(WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
    // 44.13: assume this.head == oldHead;                                                          
                                                                                                    
    assume (TreiberStack.head[this]==oldHead);                                                      
                                                                                                    
    // 44.13: assume !goesWrong(_m);                                                                
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 44.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (TreiberStack.head_nextThread[this]==tid);                                               
                                                                                                    
    // 44.13: assume this.head_nextValue == oldHead;                                                
                                                                                                    
    assume (TreiberStack.head_nextValue[this]==oldHead);                                            
                                                                                                    
                                                                                                    
    // 44.13: this.head_nextThread := tmpTid as B;                                                  
                                                                                                    
                                                                                                    
    moverPath22085 := WriteEval.TreiberStack.head_nextThread(tid: Tid,this: TreiberStack,tmpTid: Tid,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22085 := m#moverPath(moverPath22085);                                                      
    path22085 := p#moverPath(moverPath22085);                                                       
    assume Node._state22085 == Node._state && Node.item22085 == Node.item && Node.next22085 == Node.next && Node._lock22085 == Node._lock && TreiberStack._state22085 == TreiberStack._state && TreiberStack.head22085 == TreiberStack.head && TreiberStack._lock22085 == TreiberStack._lock && TreiberStack.head_nextThread22085 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22085 == TreiberStack.head_nextValue && _m22085 == _m && tmpValue22085 == tmpValue && tmpTid22085 == tmpTid && ctmp358222085 == ctmp3582 && tmp222085 == tmp2 && oldHead22085 == oldHead && newHead22085 == newHead && tmp122085 == tmp1 && item22085 == item && this22085 == this && tid22085 == tid && $pc22085 == $pc;
    assume $recorded.state22085 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head_nextThread[this] := tmpTid;                                                   
                                                                                                    
                                                                                                    
    // 44.13: this.head_nextValue := tmpValue as B;                                                 
                                                                                                    
                                                                                                    
    moverPath22088 := WriteEval.TreiberStack.head_nextValue(tid: Tid,this: TreiberStack,tmpValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22088 := m#moverPath(moverPath22088);                                                      
    path22088 := p#moverPath(moverPath22088);                                                       
    assume Node._state22088 == Node._state && Node.item22088 == Node.item && Node.next22088 == Node.next && Node._lock22088 == Node._lock && TreiberStack._state22088 == TreiberStack._state && TreiberStack.head22088 == TreiberStack.head && TreiberStack._lock22088 == TreiberStack._lock && TreiberStack.head_nextThread22088 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22088 == TreiberStack.head_nextValue && _m22088 == _m && tmpValue22088 == tmpValue && tmpTid22088 == tmpTid && ctmp358222088 == ctmp3582 && tmp222088 == tmp2 && oldHead22088 == oldHead && newHead22088 == newHead && tmp122088 == tmp1 && item22088 == item && this22088 == this && tid22088 == tid && $pc22088 == $pc;
    assume $recorded.state22088 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head_nextValue[this] := tmpValue;                                                  
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 44.13: this.head := newHead;                                                                 
                                                                                                    
                                                                                                    
    moverPath22092 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22092 := m#moverPath(moverPath22092);                                                      
    path22092 := p#moverPath(moverPath22092);                                                       
    assume Node._state22092 == Node._state && Node.item22092 == Node.item && Node.next22092 == Node.next && Node._lock22092 == Node._lock && TreiberStack._state22092 == TreiberStack._state && TreiberStack.head22092 == TreiberStack.head && TreiberStack._lock22092 == TreiberStack._lock && TreiberStack.head_nextThread22092 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22092 == TreiberStack.head_nextValue && _m22092 == _m && tmpValue22092 == tmpValue && tmpTid22092 == tmpTid && ctmp358222092 == ctmp3582 && tmp222092 == tmp2 && oldHead22092 == oldHead && newHead22092 == newHead && tmp122092 == tmp1 && item22092 == item && this22092 == this && tid22092 == tid && $pc22092 == $pc;
    assume $recorded.state22092 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover22092);                                                             
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head[this] := newHead;                                                             
    if (isLocal(Node._state[newHead], tid)) {                                                       
     Node._state[newHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[newHead]]);                                           // (44.13): newHead became shared, but newHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 44.13: tmp2 = true;                                                                          
                                                                                                    
    tmp2 := true;                                                                                   
   } else {                                                                                         
                                                                                                    
    // 44.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (TreiberStack.head_nextThread[this]==tid);                                               
                                                                                                    
    // 44.13: assume this.head_nextValue == oldHead;                                                
                                                                                                    
    assume (TreiberStack.head_nextValue[this]==oldHead);                                            
                                                                                                    
    // 44.13: Node _currentValue;                                                                   
                                                                                                    
                                                                                                    
    // 44.13: _currentValue := this.head  as B;                                                     
                                                                                                    
                                                                                                    
    moverPath22115 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22115 := m#moverPath(moverPath22115);                                                      
    path22115 := p#moverPath(moverPath22115);                                                       
    assume Node._state22115 == Node._state && Node.item22115 == Node.item && Node.next22115 == Node.next && Node._lock22115 == Node._lock && TreiberStack._state22115 == TreiberStack._state && TreiberStack.head22115 == TreiberStack.head && TreiberStack._lock22115 == TreiberStack._lock && TreiberStack.head_nextThread22115 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22115 == TreiberStack.head_nextValue && _currentValue22115 == _currentValue && ctmp358222115 == ctmp3582 && tmp222115 == tmp2 && oldHead22115 == oldHead && newHead22115 == newHead && tmp122115 == tmp1 && item22115 == item && this22115 == this && tid22115 == tid && $pc22115 == $pc;
    assume $recorded.state22115 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    _currentValue := TreiberStack.head[this];                                                       
                                                                                                    
                                                                                                    
    // 44.13: this.head := oldHead as B;                                                            
                                                                                                    
                                                                                                    
    moverPath22118 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,oldHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22118 := m#moverPath(moverPath22118);                                                      
    path22118 := p#moverPath(moverPath22118);                                                       
    assume Node._state22118 == Node._state && Node.item22118 == Node.item && Node.next22118 == Node.next && Node._lock22118 == Node._lock && TreiberStack._state22118 == TreiberStack._state && TreiberStack.head22118 == TreiberStack.head && TreiberStack._lock22118 == TreiberStack._lock && TreiberStack.head_nextThread22118 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22118 == TreiberStack.head_nextValue && _currentValue22118 == _currentValue && ctmp358222118 == ctmp3582 && tmp222118 == tmp2 && oldHead22118 == oldHead && newHead22118 == newHead && tmp122118 == tmp1 && item22118 == item && this22118 == this && tid22118 == tid && $pc22118 == $pc;
    assume $recorded.state22118 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head[this] := oldHead;                                                             
    if (isLocal(Node._state[oldHead], tid)) {                                                       
     Node._state[oldHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[oldHead]]);                                           // (44.13): oldHead became shared, but oldHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 44.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 44.13: _m = writePermission(this.head, newHead);                                             
                                                                                                    
    _m := m#moverPath(WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
                                                                                                    
    // 44.13: this.head := _currentValue as B;                                                      
                                                                                                    
                                                                                                    
    moverPath22130 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,_currentValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22130 := m#moverPath(moverPath22130);                                                      
    path22130 := p#moverPath(moverPath22130);                                                       
    assume Node._state22130 == Node._state && Node.item22130 == Node.item && Node.next22130 == Node.next && Node._lock22130 == Node._lock && TreiberStack._state22130 == TreiberStack._state && TreiberStack.head22130 == TreiberStack.head && TreiberStack._lock22130 == TreiberStack._lock && TreiberStack.head_nextThread22130 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22130 == TreiberStack.head_nextValue && _m22130 == _m && _currentValue22130 == _currentValue && ctmp358222130 == ctmp3582 && tmp222130 == tmp2 && oldHead22130 == oldHead && newHead22130 == newHead && tmp122130 == tmp1 && item22130 == item && this22130 == this && tid22130 == tid && $pc22130 == $pc;
    assume $recorded.state22130 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head[this] := _currentValue;                                                       
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (44.13): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 44.13: assume goesWrong(_m);                                                                 
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 44.13: this.head := newHead;                                                                 
                                                                                                    
                                                                                                    
    moverPath22137 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22137 := m#moverPath(moverPath22137);                                                      
    path22137 := p#moverPath(moverPath22137);                                                       
    assume Node._state22137 == Node._state && Node.item22137 == Node.item && Node.next22137 == Node.next && Node._lock22137 == Node._lock && TreiberStack._state22137 == TreiberStack._state && TreiberStack.head22137 == TreiberStack.head && TreiberStack._lock22137 == TreiberStack._lock && TreiberStack.head_nextThread22137 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22137 == TreiberStack.head_nextValue && _m22137 == _m && _currentValue22137 == _currentValue && ctmp358222137 == ctmp3582 && tmp222137 == tmp2 && oldHead22137 == oldHead && newHead22137 == newHead && tmp122137 == tmp1 && item22137 == item && this22137 == this && tid22137 == tid && $pc22137 == $pc;
    assume $recorded.state22137 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (44.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover22137);                                                             
    assert $pc != PhaseError;                                                                              // (44.13): Reduction failure
    TreiberStack.head[this] := newHead;                                                             
    if (isLocal(Node._state[newHead], tid)) {                                                       
     Node._state[newHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[newHead]]);                                           // (44.13): newHead became shared, but newHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 44.13: tmp2 = false;                                                                         
                                                                                                    
    tmp2 := false;                                                                                  
   }                                                                                                
  }                                                                                                 
  if (tmp2) {                                                                                       
                                                                                                    
   // 45.17:  return;                                                                               
                                                                                                    
   assume Node._state22147 == Node._state && Node.item22147 == Node.item && Node.next22147 == Node.next && Node._lock22147 == Node._lock && TreiberStack._state22147 == TreiberStack._state && TreiberStack.head22147 == TreiberStack.head && TreiberStack._lock22147 == TreiberStack._lock && TreiberStack.head_nextThread22147 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22147 == TreiberStack.head_nextValue && tmp222147 == tmp2 && oldHead22147 == oldHead && newHead22147 == newHead && tmp122147 == tmp1 && item22147 == item && this22147 == this && tid22147 == tid;
   assume $recorded.state22147 == 1;                                                                
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
  assume Node._state22154_bottom == Node._state && Node.item22154_bottom == Node.item && Node.next22154_bottom == Node.next && Node._lock22154_bottom == Node._lock && TreiberStack._state22154_bottom == TreiberStack._state && TreiberStack.head22154_bottom == TreiberStack.head && TreiberStack._lock22154_bottom == TreiberStack._lock && TreiberStack.head_nextThread22154_bottom == TreiberStack.head_nextThread && TreiberStack.head_nextValue22154_bottom == TreiberStack.head_nextValue && item22154_bottom == item && this22154_bottom == this && tid22154_bottom == tid;
  assume $recorded.state22154_bottom == 1;                                                          
  assert phase22154 == $pc;                                                                                // (39.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 25.32: // return;                                                                               
                                                                                                    
 assume Node._state22155 == Node._state && Node.item22155 == Node.item && Node.next22155 == Node.next && Node._lock22155 == Node._lock && TreiberStack._state22155 == TreiberStack._state && TreiberStack.head22155 == TreiberStack.head && TreiberStack._lock22155 == TreiberStack._lock && TreiberStack.head_nextThread22155 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22155 == TreiberStack.head_nextValue && item22155 == item && this22155 == this && tid22155 == tid;
 assume $recorded.state22155 == 1;                                                                  
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  TreiberStack.pop(tid:Tid, this : TreiberStack)                                           
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies TreiberStack._state;                                                                       
modifies TreiberStack.head;                                                                         
modifies TreiberStack._lock;                                                                        
modifies TreiberStack.head_nextThread;                                                              
modifies TreiberStack.head_nextValue;                                                               
                                                                                                    
requires ValidTid(tid);                                                                                    // (50.5): Bad tid
requires isShared(TreiberStack._state[this]);                                                              // (50.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
{                                                                                                   
 var $pc22349: Phase;                                                                               
 var $result22373: int;                                                                             
 var TreiberStack._state22373: [TreiberStack]State;                                                 
 var tmpTid22311: Tid;                                                                              
 var TreiberStack.head22238_post: [TreiberStack]Node;                                               
 var $recorded.state22311: int;                                                                     
 var tmp422307: bool;                                                                               
 var path22234: int;                                                                                
 var TreiberStack._lock22238: [TreiberStack]Tid;                                                    
 var tmp322371: bool;                                                                               
 var Node.item22380: [Node]int;                                                                     
 var Node._lock22337: [Node]Tid;                                                                    
 var TreiberStack.head_nextValue22244: [TreiberStack]Node;                                          
 var TreiberStack.head22383: [TreiberStack]Node;                                                    
 var tid22238: Tid;                                                                                 
 var this22371: TreiberStack;                                                                       
 var TreiberStack._state22311: [TreiberStack]State;                                                 
 var mover22185: Mover;                                                                             
 var Node._state22383: [Node]State;                                                                 
 var path22349: int;                                                                                
 var $pc22238_post: Phase;                                                                          
 var Node.next22304: [Node]Node;                                                                    
 var TreiberStack.head_nextValue22311: [TreiberStack]Node;                                          
 var ctmp364922349: bool;                                                                           
 var Node._state22334: [Node]State;                                                                 
 var Node._lock22380_bottom: [Node]Tid;                                                             
 var Node._lock22229: [Node]Tid;                                                                    
 var $result22349: int;                                                                             
 var newHead22244: Node;                                                                            
 var TreiberStack.head_nextValue22229: [TreiberStack]Node;                                          
 var tmp422337: bool;                                                                               
 var tmp322179: bool;                                                                               
 var tmp322311: bool;                                                                               
 var tmp322307: bool;                                                                               
 var $pc22383: Phase;                                                                               
 var Node.item22244: [Node]int;                                                                     
 var moverPath22356: MoverPath;                                                                     
 var Node._lock22191: [Node]Tid;                                                                    
 var $recorded.state22304: int;                                                                     
 var Node._state22337: [Node]State;                                                                 
 var TreiberStack._lock22238_post: [TreiberStack]Tid;                                               
 var _C_t: Tid;                                                                                     
 var $result22356: int;                                                                             
 var _m22356: Mover;                                                                                
 var TreiberStack.head_nextValue22191: [TreiberStack]Node;                                          
 var tid22383: Tid;                                                                                 
 var TreiberStack._lock22191: [TreiberStack]Tid;                                                    
 var oldHead22229: Node;                                                                            
 var TreiberStack._lock22383: [TreiberStack]Tid;                                                    
 var tid22373: Tid;                                                                                 
 var Node.item22349: [Node]int;                                                                     
 var TreiberStack.head22356: [TreiberStack]Node;                                                    
 var TreiberStack._lock22349: [TreiberStack]Tid;                                                    
 var _currentValue22356: Node;                                                                      
 var TreiberStack._lock22311: [TreiberStack]Tid;                                                    
 var TreiberStack.head_nextThread22380_bottom: [TreiberStack]Tid;                                   
 var Node.item22238_post: [Node]int;                                                                
 var newHead22304: Node;                                                                            
 var tmp322191: bool;                                                                               
 var oldHead22356: Node;                                                                            
 var tmp5: int;                                                                                     
 var TreiberStack._lock22234: [TreiberStack]Tid;                                                    
 var TreiberStack.head22373: [TreiberStack]Node;                                                    
 var $pc22380: Phase;                                                                               
 var tmpValue22311: Node;                                                                           
 var tmpValue: Node;                                                                                
 var _casable: bool;                                                                                
 var TreiberStack.head_nextValue22304: [TreiberStack]Node;                                          
 var Node.item22373: [Node]int;                                                                     
 var TreiberStack._lock22304: [TreiberStack]Tid;                                                    
 var Node.next22334: [Node]Node;                                                                    
 var mover22349: Mover;                                                                             
 var TreiberStack._state22349: [TreiberStack]State;                                                 
 var TreiberStack._state22380_bottom: [TreiberStack]State;                                          
 var TreiberStack.head_nextValue22179: [TreiberStack]Node;                                          
 var _C_t22179: Tid;                                                                                
 var TreiberStack.head_nextThread22238: [TreiberStack]Tid;                                          
 var TreiberStack.head_nextValue22337: [TreiberStack]Node;                                          
 var moverPath22234: MoverPath;                                                                     
 var oldHead22244: Node;                                                                            
 var this22337: TreiberStack;                                                                       
 var $result22238: int;                                                                             
 var $pc22337: Phase;                                                                               
 var mover22179: Mover;                                                                             
 var $recorded.state22356: int;                                                                     
 var $recorded.state22238_post: int;                                                                
 var Node.item22371: [Node]int;                                                                     
 var tid22371: Tid;                                                                                 
 var tid22307: Tid;                                                                                 
 var Node._state22380_bottom: [Node]State;                                                          
 var tmp322356: bool;                                                                               
 var mover22311: Mover;                                                                             
 var this22234: TreiberStack;                                                                       
 var $pc22244: Phase;                                                                               
 var _C_v22191: Node;                                                                               
 var Node.item22307: [Node]int;                                                                     
 var this22304: TreiberStack;                                                                       
 var newHead: Node;                                                                                 
 var TreiberStack.head_nextValue22383: [TreiberStack]Node;                                          
 var TreiberStack._lock22380_bottom: [TreiberStack]Tid;                                             
 var tmp422334: bool;                                                                               
 var tmp322373: bool;                                                                               
 var TreiberStack.head_nextThread22191: [TreiberStack]Tid;                                          
 var Node._lock22238: [Node]Tid;                                                                    
 var TreiberStack.head_nextValue22356: [TreiberStack]Node;                                          
 var tid22337: Tid;                                                                                 
 var oldHead22238: Node;                                                                            
 var _currentValue22349: Node;                                                                      
 var _currentValue22191: Node;                                                                      
 var tmpTid22307: Tid;                                                                              
 var _C_t22185: Tid;                                                                                
 var Node._lock22383: [Node]Tid;                                                                    
 var oldHead22307: Node;                                                                            
 var $result22371: int;                                                                             
 var ctmp364922307: bool;                                                                           
 var TreiberStack.head_nextValue22380_bottom: [TreiberStack]Node;                                   
 var TreiberStack.head_nextThread22349: [TreiberStack]Tid;                                          
 var TreiberStack._lock22356: [TreiberStack]Tid;                                                    
 var _casable22229: bool;                                                                           
 var tmp322238: bool;                                                                               
 var $recorded.state22383: int;                                                                     
 var TreiberStack._state22307: [TreiberStack]State;                                                 
 var tid22380_bottom: Tid;                                                                          
 var TreiberStack.head_nextValue22307: [TreiberStack]Node;                                          
 var TreiberStack.head_nextThread22185: [TreiberStack]Tid;                                          
 var Node._lock22238_post: [Node]Tid;                                                               
 var TreiberStack.head_nextThread22238_post: [TreiberStack]Tid;                                     
 var oldHead22337: Node;                                                                            
 var Node.next22349: [Node]Node;                                                                    
 var $result22229: int;                                                                             
 var Node._state22244: [Node]State;                                                                 
 var this22179: TreiberStack;                                                                       
 var Node.next22383: [Node]Node;                                                                    
 var path22304: int;                                                                                
 var this22191: TreiberStack;                                                                       
 var TreiberStack.head_nextThread22234: [TreiberStack]Tid;                                          
 var path22334: int;                                                                                
 var $recorded.state22373: int;                                                                     
 var TreiberStack.head_nextValue22334: [TreiberStack]Node;                                          
 var this22380: TreiberStack;                                                                       
 var Node._lock22373: [Node]Tid;                                                                    
 var $pc22229: Phase;                                                                               
 var Node._lock22307: [Node]Tid;                                                                    
 var Node.next22371: [Node]Node;                                                                    
 var newHead22311: Node;                                                                            
 var this22238: TreiberStack;                                                                       
 var TreiberStack._state22334: [TreiberStack]State;                                                 
 var Node.next22191: [Node]Node;                                                                    
 var tid22334: Tid;                                                                                 
 var Node.item22238: [Node]int;                                                                     
 var $recorded.state22185: int;                                                                     
 var tmp322304: bool;                                                                               
 var $result22380: int;                                                                             
 var ctmp3649: bool;                                                                                
 var Node._state22238_post: [Node]State;                                                            
 var Node._state22373: [Node]State;                                                                 
 var tid22304: Tid;                                                                                 
 var TreiberStack.head_nextThread22229: [TreiberStack]Tid;                                          
 var TreiberStack.head_nextValue22380: [TreiberStack]Node;                                          
 var Node.item22304: [Node]int;                                                                     
 var moverPath22304: MoverPath;                                                                     
 var TreiberStack.head22234: [TreiberStack]Node;                                                    
 var this22334: TreiberStack;                                                                       
 var TreiberStack.head_nextThread22337: [TreiberStack]Tid;                                          
 var TreiberStack.head22380_bottom: [TreiberStack]Node;                                             
 var Node._state22307: [Node]State;                                                                 
 var newHead22373: Node;                                                                            
 var Node._state22349: [Node]State;                                                                 
 var tmpTid22304: Tid;                                                                              
 var Node.next22337: [Node]Node;                                                                    
 var tmp322185: bool;                                                                               
 var moverPath22371: MoverPath;                                                                     
 var $result22238_post: int;                                                                        
 var TreiberStack.head22334: [TreiberStack]Node;                                                    
 var Node._lock22185: [Node]Tid;                                                                    
 var _currentValue22234: Node;                                                                      
 var this22244: TreiberStack;                                                                       
 var _m22304: Mover;                                                                                
 var $pc22179: Phase;                                                                               
 var TreiberStack._lock22337: [TreiberStack]Tid;                                                    
 var TreiberStack.head_nextThread22311: [TreiberStack]Tid;                                          
 var _C_v: Node;                                                                                    
 var TreiberStack._state22380: [TreiberStack]State;                                                 
 var TreiberStack.head_nextThread22371: [TreiberStack]Tid;                                          
 var moverPath22337: MoverPath;                                                                     
 var $result22380_bottom: int;                                                                      
 var moverPath22179: MoverPath;                                                                     
 var moverPath22185: MoverPath;                                                                     
 var TreiberStack.head_nextValue22373: [TreiberStack]Node;                                          
 var $pc22373: Phase;                                                                               
 var _R_t22229: Mover;                                                                              
 var moverPath22311: MoverPath;                                                                     
 var TreiberStack.head_nextValue22371: [TreiberStack]Node;                                          
 var TreiberStack.head22191: [TreiberStack]Node;                                                    
 var TreiberStack._state22191: [TreiberStack]State;                                                 
 var $result22191: int;                                                                             
 var Node._state22229: [Node]State;                                                                 
 var _m22311: Mover;                                                                                
 var this22383: TreiberStack;                                                                       
 var moverPath22307: MoverPath;                                                                     
 var Node.item22311: [Node]int;                                                                     
 var mover22371: Mover;                                                                             
 var Node._state22311: [Node]State;                                                                 
 var Node.item22380_bottom: [Node]int;                                                              
 var path22311: int;                                                                                
 var TreiberStack.head_nextThread22383: [TreiberStack]Tid;                                          
 var Node._state22238: [Node]State;                                                                 
 var TreiberStack._lock22371: [TreiberStack]Tid;                                                    
 var tid22311: Tid;                                                                                 
 var Node.next22307: [Node]Node;                                                                    
 var oldHead22179: Node;                                                                            
 var Node._lock22244: [Node]Tid;                                                                    
 var this22373: TreiberStack;                                                                       
 var $recorded.state22307: int;                                                                     
 var TreiberStack._state22244: [TreiberStack]State;                                                 
 var TreiberStack.head22229: [TreiberStack]Node;                                                    
 var this22229: TreiberStack;                                                                       
 var $recorded.state22234: int;                                                                     
 var tmp322229: bool;                                                                               
 var Node.item22191: [Node]int;                                                                     
 var TreiberStack._lock22334: [TreiberStack]Tid;                                                    
 var TreiberStack._state22238_post: [TreiberStack]State;                                            
 var tmp422349: bool;                                                                               
 var TreiberStack.head_nextValue22234: [TreiberStack]Node;                                          
 var Node.item22337: [Node]int;                                                                     
 var oldHead: Node;                                                                                 
 var _m22307: Mover;                                                                                
 var $pc22191: Phase;                                                                               
 var TreiberStack.head_nextThread22179: [TreiberStack]Tid;                                          
 var oldHead22185: Node;                                                                            
 var Node._state22185: [Node]State;                                                                 
 var this22311: TreiberStack;                                                                       
 var ctmp364922337: bool;                                                                           
 var path22191: int;                                                                                
 var path22244: int;                                                                                
 var TreiberStack.head22371: [TreiberStack]Node;                                                    
 var tmp322334: bool;                                                                               
 var mover22337: Mover;                                                                             
 var ctmp364922356: bool;                                                                           
 var TreiberStack.head22304: [TreiberStack]Node;                                                    
 var TreiberStack._state22337: [TreiberStack]State;                                                 
 var Node._lock22311: [Node]Tid;                                                                    
 var TreiberStack._state22179: [TreiberStack]State;                                                 
 var TreiberStack.head_nextValue22185: [TreiberStack]Node;                                          
 var Node._lock22356: [Node]Tid;                                                                    
 var Node.item22234: [Node]int;                                                                     
 var mover22307: Mover;                                                                             
 var TreiberStack.head_nextThread22304: [TreiberStack]Tid;                                          
 var this22238_post: TreiberStack;                                                                  
 var this22380_bottom: TreiberStack;                                                                
 var Node._lock22234: [Node]Tid;                                                                    
 var Node._state22371: [Node]State;                                                                 
 var _m22349: Mover;                                                                                
 var tmp422304: bool;                                                                               
 var path22229: int;                                                                                
 var TreiberStack.head22349: [TreiberStack]Node;                                                    
 var newHead22334: Node;                                                                            
 var Node._lock22334: [Node]Tid;                                                                    
 var _currentValue22337: Node;                                                                      
 var Node.next22356: [Node]Node;                                                                    
 var _currentValue: Node;                                                                           
 var oldHead22373: Node;                                                                            
 var Node.item22356: [Node]int;                                                                     
 var tid22349: Tid;                                                                                 
 var TreiberStack._lock22229: [TreiberStack]Tid;                                                    
 var Node._state22356: [Node]State;                                                                 
 var $result22334: int;                                                                             
 var ctmp364922304: bool;                                                                           
 var _R_t: Mover;                                                                                   
 var Node.next22234: [Node]Node;                                                                    
 var TreiberStack._state22356: [TreiberStack]State;                                                 
 var $recorded.state22380: int;                                                                     
 var $recorded.state22371: int;                                                                     
 var $pc22380_bottom: Phase;                                                                        
 var Node.next22238: [Node]Node;                                                                    
 var TreiberStack._lock22185: [TreiberStack]Tid;                                                    
 var tid22185: Tid;                                                                                 
 var newHead22371: Node;                                                                            
 var Node._lock22380: [Node]Tid;                                                                    
 var newHead22337: Node;                                                                            
 var tmp422311: bool;                                                                               
 var TreiberStack._state22383: [TreiberStack]State;                                                 
 var moverPath22229: MoverPath;                                                                     
 var TreiberStack._state22229: [TreiberStack]State;                                                 
 var this22349: TreiberStack;                                                                       
 var _m: Mover;                                                                                     
 var tmp322244: bool;                                                                               
 var TreiberStack._lock22244: [TreiberStack]Tid;                                                    
 var TreiberStack._lock22380: [TreiberStack]Tid;                                                    
 var TreiberStack._lock22373: [TreiberStack]Tid;                                                    
 var TreiberStack._state22371: [TreiberStack]State;                                                 
 var Node._state22304: [Node]State;                                                                 
 var tmp322337: bool;                                                                               
 var TreiberStack._lock22179: [TreiberStack]Tid;                                                    
 var $pc22185: Phase;                                                                               
 var TreiberStack.head22337: [TreiberStack]Node;                                                    
 var Node.item22334: [Node]int;                                                                     
 var tmpValue22307: Node;                                                                           
 var TreiberStack.head_nextThread22244: [TreiberStack]Tid;                                          
 var TreiberStack.head22185: [TreiberStack]Node;                                                    
 var newHead22307: Node;                                                                            
 var $recorded.state22337: int;                                                                     
 var mover22191: Mover;                                                                             
 var TreiberStack.head22244: [TreiberStack]Node;                                                    
 var $result22311: int;                                                                             
 var tmp322349: bool;                                                                               
 var _C_v22229: Node;                                                                               
 var $result22179: int;                                                                             
 var Node._lock22371: [Node]Tid;                                                                    
 var Node.item22185: [Node]int;                                                                     
 var Node.next22380_bottom: [Node]Node;                                                             
 var this22185: TreiberStack;                                                                       
 var mover22229: Mover;                                                                             
 var path22185: int;                                                                                
 var $pc22304: Phase;                                                                               
 var _C_t22191: Tid;                                                                                
 var tid22191: Tid;                                                                                 
 var $result22244: int;                                                                             
 var TreiberStack.head22238: [TreiberStack]Node;                                                    
 var tmp422373: bool;                                                                               
 var TreiberStack.head_nextValue22349: [TreiberStack]Node;                                          
 var oldHead22238_post: Node;                                                                       
 var $result22337: int;                                                                             
 var newHead22356: Node;                                                                            
 var oldHead22334: Node;                                                                            
 var $result22304: int;                                                                             
 var Node._lock22179: [Node]Tid;                                                                    
 var TreiberStack.head_nextThread22307: [TreiberStack]Tid;                                          
 var tid22229: Tid;                                                                                 
 var Node._state22234: [Node]State;                                                                 
 var mover22304: Mover;                                                                             
 var _C_v22185: Node;                                                                               
 var Node._state22179: [Node]State;                                                                 
 var tmp322234: bool;                                                                               
 var Node.next22238_post: [Node]Node;                                                               
 var tmp3: bool;                                                                                    
 var TreiberStack.head_nextThread22373: [TreiberStack]Tid;                                          
 var tmpTid: Tid;                                                                                   
 var path22371: int;                                                                                
 var _C_t22229: Tid;                                                                                
 var $result22185: int;                                                                             
 var tmp4: bool;                                                                                    
 var Node._lock22304: [Node]Tid;                                                                    
 var path22307: int;                                                                                
 var tmp522371: int;                                                                                
 var $pc22371: Phase;                                                                               
 var $recorded.state22238: int;                                                                     
 var tid22238_post: Tid;                                                                            
 var oldHead22371: Node;                                                                            
 var $pc22311: Phase;                                                                               
 var TreiberStack.head22311: [TreiberStack]Node;                                                    
 var TreiberStack.head_nextThread22334: [TreiberStack]Tid;                                          
 var tmpValue22304: Node;                                                                           
 var oldHead22311: Node;                                                                            
 var oldHead22191: Node;                                                                            
 var Node._lock22349: [Node]Tid;                                                                    
 var _C_v22234: Node;                                                                               
 var _casable22234: bool;                                                                           
 var _C_t22234: Tid;                                                                                
 var Node.next22244: [Node]Node;                                                                    
 var $recorded.state22349: int;                                                                     
 var TreiberStack.head_nextValue22238_post: [TreiberStack]Node;                                     
 var tmp422356: bool;                                                                               
 var tmp422371: bool;                                                                               
 var Node.next22185: [Node]Node;                                                                    
 var $recorded.state22179: int;                                                                     
 var $result22234: int;                                                                             
 var Node.next22179: [Node]Node;                                                                    
 var mover22334: Mover;                                                                             
 var Node._state22191: [Node]State;                                                                 
 var $recorded.state22380_bottom: int;                                                              
 var this22356: TreiberStack;                                                                       
 var TreiberStack.head22307: [TreiberStack]Node;                                                    
 var moverPath22244: MoverPath;                                                                     
 var $pc22234: Phase;                                                                               
 var oldHead22349: Node;                                                                            
 var Node.next22311: [Node]Node;                                                                    
 var moverPath22191: MoverPath;                                                                     
 var TreiberStack._state22304: [TreiberStack]State;                                                 
 var $pc22334: Phase;                                                                               
 var ctmp364922311: bool;                                                                           
 var TreiberStack._state22238: [TreiberStack]State;                                                 
 var Node.item22383: [Node]int;                                                                     
 var mover22244: Mover;                                                                             
 var oldHead22304: Node;                                                                            
 var tid22179: Tid;                                                                                 
 var path22356: int;                                                                                
 var $recorded.state22191: int;                                                                     
 var $recorded.state22334: int;                                                                     
 var $pc22307: Phase;                                                                               
 var Node.next22380: [Node]Node;                                                                    
 var ctmp364922334: bool;                                                                           
 var $recorded.state22244: int;                                                                     
 var _currentValue22334: Node;                                                                      
 var _R_t22234: Mover;                                                                              
 var phase22380: Phase;                                                                             
 var tid22234: Tid;                                                                                 
 var Node.next22373: [Node]Node;                                                                    
 var oldHead22234: Node;                                                                            
 var TreiberStack.head22380: [TreiberStack]Node;                                                    
 var Node.next22229: [Node]Node;                                                                    
 var TreiberStack.head_nextThread22356: [TreiberStack]Tid;                                          
 var tid22244: Tid;                                                                                 
 var tmp322238_post: bool;                                                                          
 var TreiberStack.head22179: [TreiberStack]Node;                                                    
 var Node.item22229: [Node]int;                                                                     
 var Node.item22179: [Node]int;                                                                     
 var path22337: int;                                                                                
 var $result22307: int;                                                                             
 var moverPath22349: MoverPath;                                                                     
 var Node._state22380: [Node]State;                                                                 
 var _currentValue22229: Node;                                                                      
 var $pc22238: Phase;                                                                               
 var newHead22349: Node;                                                                            
 var TreiberStack.head_nextThread22380: [TreiberStack]Tid;                                          
 var $result22383: int;                                                                             
 var tid22380: Tid;                                                                                 
 var this22307: TreiberStack;                                                                       
 var path22179: int;                                                                                
 var $recorded.state22229: int;                                                                     
 var TreiberStack.head_nextValue22238: [TreiberStack]Node;                                          
 var tid22356: Tid;                                                                                 
 var $pc22356: Phase;                                                                               
 var moverPath22334: MoverPath;                                                                     
 var TreiberStack._state22234: [TreiberStack]State;                                                 
 var tmp522373: int;                                                                                
 var TreiberStack._lock22307: [TreiberStack]Tid;                                                    
 var mover22356: Mover;                                                                             
 var mover22234: Mover;                                                                             
 var TreiberStack._state22185: [TreiberStack]State;                                                 
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state22380 == Node._state && Node.item22380 == Node.item && Node.next22380 == Node.next && Node._lock22380 == Node._lock && TreiberStack._state22380 == TreiberStack._state && TreiberStack.head22380 == TreiberStack.head && TreiberStack._lock22380 == TreiberStack._lock && TreiberStack.head_nextThread22380 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22380 == TreiberStack.head_nextValue && $result22380 == $result && this22380 == this && tid22380 == tid;
 assume $recorded.state22380 == 1;                                                                  
                                                                                                    
 // 54.9: while (true)   {                                                                          
                                                                                                    
 phase22380 := $pc;                                                                                 
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (50.5): Bad tid
  invariant isShared(TreiberStack._state[this]);                                                           // (50.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state22380,Node.item22380,Node.next22380,Node._lock22380,TreiberStack._state22380,TreiberStack.head22380,TreiberStack._lock22380,TreiberStack.head_nextThread22380,TreiberStack.head_nextValue22380));       // (54.9): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state22380,Node.item22380,Node.next22380,Node._lock22380,TreiberStack._state22380,TreiberStack.head22380,TreiberStack._lock22380,TreiberStack.head_nextThread22380,TreiberStack.head_nextValue22380));       // (54.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : TreiberStack :: Invariant.Y_TreiberStack.head(tid : Tid, _this, TreiberStack.head[_this] ,Node._state22380,Node.item22380,Node.next22380,Node._lock22380,TreiberStack._state22380,TreiberStack.head22380,TreiberStack._lock22380,TreiberStack.head_nextThread22380,TreiberStack.head_nextValue22380));       // (54.9): Loop does not preserve yields_as annotation for field head
  invariant phase22380 == $pc;                                                                             // (54.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (54.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 54.16: boolean tmp3;                                                                           
                                                                                                    
                                                                                                    
  // 54.16: tmp3 = true;                                                                            
                                                                                                    
  tmp3 := true;                                                                                     
  if (!(tmp3)) {                                                                                    
                                                                                                    
   // 54.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 55.13: Node oldHead;                                                                           
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 55.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 55.13: _C_t := this.head_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath22179 := ReadEval.TreiberStack.head_nextThread(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover22179 := m#moverPath(moverPath22179);                                                        
  path22179 := p#moverPath(moverPath22179);                                                         
  assume Node._state22179 == Node._state && Node.item22179 == Node.item && Node.next22179 == Node.next && Node._lock22179 == Node._lock && TreiberStack._state22179 == TreiberStack._state && TreiberStack.head22179 == TreiberStack.head && TreiberStack._lock22179 == TreiberStack._lock && TreiberStack.head_nextThread22179 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22179 == TreiberStack.head_nextValue && _C_t22179 == _C_t && oldHead22179 == oldHead && tmp322179 == tmp3 && $result22179 == $result && this22179 == this && tid22179 == tid && $pc22179 == $pc;
  assume $recorded.state22179 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (55.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (55.13): Reduction failure
  _C_t := TreiberStack.head_nextThread[this];                                                       
                                                                                                    
  // 55.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 55.13: _C_v := this.head_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath22185 := ReadEval.TreiberStack.head_nextValue(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover22185 := m#moverPath(moverPath22185);                                                        
  path22185 := p#moverPath(moverPath22185);                                                         
  assume Node._state22185 == Node._state && Node.item22185 == Node.item && Node.next22185 == Node.next && Node._lock22185 == Node._lock && TreiberStack._state22185 == TreiberStack._state && TreiberStack.head22185 == TreiberStack.head && TreiberStack._lock22185 == TreiberStack._lock && TreiberStack.head_nextThread22185 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22185 == TreiberStack.head_nextValue && _C_v22185 == _C_v && _C_t22185 == _C_t && oldHead22185 == oldHead && tmp322185 == tmp3 && $result22185 == $result && this22185 == this && tid22185 == tid && $pc22185 == $pc;
  assume $recorded.state22185 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (55.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (55.13): Reduction failure
  _C_v := TreiberStack.head_nextValue[this];                                                        
                                                                                                    
  // 55.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 55.13: _currentValue := this.head  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath22191 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover22191 := m#moverPath(moverPath22191);                                                        
  path22191 := p#moverPath(moverPath22191);                                                         
  assume Node._state22191 == Node._state && Node.item22191 == Node.item && Node.next22191 == Node.next && Node._lock22191 == Node._lock && TreiberStack._state22191 == TreiberStack._state && TreiberStack.head22191 == TreiberStack.head && TreiberStack._lock22191 == TreiberStack._lock && TreiberStack.head_nextThread22191 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22191 == TreiberStack.head_nextValue && _currentValue22191 == _currentValue && _C_v22191 == _C_v && _C_t22191 == _C_t && oldHead22191 == oldHead && tmp322191 == tmp3 && $result22191 == $result && this22191 == this && tid22191 == tid && $pc22191 == $pc;
  assume $recorded.state22191 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume this != TreiberStack.null;                                                                
  } else {                                                                                          
   assert this != TreiberStack.null;                                                                       // (55.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (55.13): Reduction failure
  _currentValue := TreiberStack.head[this];                                                         
                                                                                                    
  // 55.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 55.13: _R_t = readPermission(this.head);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
  // 55.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 55.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 55.13: oldHead := this.head  as R;                                                            
                                                                                                    
                                                                                                    
   moverPath22229 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
   mover22229 := m#moverPath(moverPath22229);                                                       
   path22229 := p#moverPath(moverPath22229);                                                        
   assume Node._state22229 == Node._state && Node.item22229 == Node.item && Node.next22229 == Node.next && Node._lock22229 == Node._lock && TreiberStack._state22229 == TreiberStack._state && TreiberStack.head22229 == TreiberStack.head && TreiberStack._lock22229 == TreiberStack._lock && TreiberStack.head_nextThread22229 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22229 == TreiberStack.head_nextValue && _casable22229 == _casable && _R_t22229 == _R_t && _currentValue22229 == _currentValue && _C_v22229 == _C_v && _C_t22229 == _C_t && oldHead22229 == oldHead && tmp322229 == tmp3 && $result22229 == $result && this22229 == this && tid22229 == tid && $pc22229 == $pc;
   assume $recorded.state22229 == 1;                                                                
   if ($pc == PreCommit) {                                                                          
    assume this != TreiberStack.null;                                                               
   } else {                                                                                         
    assert this != TreiberStack.null;                                                                      // (55.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (55.13): Reduction failure
   oldHead := TreiberStack.head[this];                                                              
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 55.13: oldHead := this.head;                                                                  
                                                                                                    
                                                                                                    
   moverPath22234 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
   mover22234 := m#moverPath(moverPath22234);                                                       
   path22234 := p#moverPath(moverPath22234);                                                        
   assume Node._state22234 == Node._state && Node.item22234 == Node.item && Node.next22234 == Node.next && Node._lock22234 == Node._lock && TreiberStack._state22234 == TreiberStack._state && TreiberStack.head22234 == TreiberStack.head && TreiberStack._lock22234 == TreiberStack._lock && TreiberStack.head_nextThread22234 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22234 == TreiberStack.head_nextValue && _casable22234 == _casable && _R_t22234 == _R_t && _currentValue22234 == _currentValue && _C_v22234 == _C_v && _C_t22234 == _C_t && oldHead22234 == oldHead && tmp322234 == tmp3 && $result22234 == $result && this22234 == this && tid22234 == tid && $pc22234 == $pc;
   assume $recorded.state22234 == 1;                                                                
   if ($pc == PreCommit) {                                                                          
    assume this != TreiberStack.null;                                                               
   } else {                                                                                         
    assert this != TreiberStack.null;                                                                      // (55.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover22234);                                                              
   assert $pc != PhaseError;                                                                               // (55.13): Reduction failure
   oldHead := TreiberStack.head[this];                                                              
  }                                                                                                 
                                                                                                    
  // 56.13: yield;                                                                                  
                                                                                                    
  assume Node._state22238 == Node._state && Node.item22238 == Node.item && Node.next22238 == Node.next && Node._lock22238 == Node._lock && TreiberStack._state22238 == TreiberStack._state && TreiberStack.head22238 == TreiberStack.head && TreiberStack._lock22238 == TreiberStack._lock && TreiberStack.head_nextThread22238 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22238 == TreiberStack.head_nextValue && oldHead22238 == oldHead && tmp322238 == tmp3 && $result22238 == $result && this22238 == this && tid22238 == tid;
  assume $recorded.state22238 == 1;                                                                 
  call Yield(tid);                                                                                  
  $pc := PreCommit;                                                                                 
  assume Node._state22238_post == Node._state && Node.item22238_post == Node.item && Node.next22238_post == Node.next && Node._lock22238_post == Node._lock && TreiberStack._state22238_post == TreiberStack._state && TreiberStack.head22238_post == TreiberStack.head && TreiberStack._lock22238_post == TreiberStack._lock && TreiberStack.head_nextThread22238_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue22238_post == TreiberStack.head_nextValue && oldHead22238_post == oldHead && tmp322238_post == tmp3 && $result22238_post == $result && this22238_post == this && tid22238_post == tid;
  assume $recorded.state22238_post == 1;                                                            
                                                                                                    
  // 57.13: Node newHead;                                                                           
                                                                                                    
                                                                                                    
  // 57.13: newHead := oldHead.next;                                                                
                                                                                                    
                                                                                                    
  moverPath22244 := ReadEval.Node.next(tid: Tid,oldHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
  mover22244 := m#moverPath(moverPath22244);                                                        
  path22244 := p#moverPath(moverPath22244);                                                         
  assume Node._state22244 == Node._state && Node.item22244 == Node.item && Node.next22244 == Node.next && Node._lock22244 == Node._lock && TreiberStack._state22244 == TreiberStack._state && TreiberStack.head22244 == TreiberStack.head && TreiberStack._lock22244 == TreiberStack._lock && TreiberStack.head_nextThread22244 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22244 == TreiberStack.head_nextValue && newHead22244 == newHead && oldHead22244 == oldHead && tmp322244 == tmp3 && $result22244 == $result && this22244 == this && tid22244 == tid && $pc22244 == $pc;
  assume $recorded.state22244 == 1;                                                                 
  if ($pc == PreCommit) {                                                                           
   assume oldHead != Node.null;                                                                     
  } else {                                                                                          
   assert oldHead != Node.null;                                                                            // (57.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover22244);                                                               
  assert $pc != PhaseError;                                                                                // (57.13): Reduction failure
  newHead := Node.next[oldHead];                                                                    
                                                                                                    
  // 58.13: boolean tmp4;                                                                           
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 58.13: boolean ctmp3649;                                                                       
                                                                                                    
                                                                                                    
  // 58.13: ctmp3649 = *;                                                                           
                                                                                                    
  havoc ctmp3649;                                                                                   
  if (ctmp3649) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 58.13: tmp4 = false;                                                                          
                                                                                                    
   tmp4 := false;                                                                                   
  } else {                                                                                          
                                                                                                    
   // 58.13: ctmp3649 = *;                                                                          
                                                                                                    
   havoc ctmp3649;                                                                                  
   if (ctmp3649) {                                                                                  
                                                                                                    
    // 58.13: Tid tmpTid;                                                                           
                                                                                                    
                                                                                                    
    // 58.13: Node tmpValue;                                                                        
                                                                                                    
                                                                                                    
    // 58.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 58.13: _m = writePermission(this.head, newHead);                                             
                                                                                                    
    _m := m#moverPath(WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
    // 58.13: assume this.head == oldHead;                                                          
                                                                                                    
    assume (TreiberStack.head[this]==oldHead);                                                      
                                                                                                    
    // 58.13: assume !goesWrong(_m);                                                                
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 58.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (TreiberStack.head_nextThread[this]==tid);                                               
                                                                                                    
    // 58.13: assume this.head_nextValue == oldHead;                                                
                                                                                                    
    assume (TreiberStack.head_nextValue[this]==oldHead);                                            
                                                                                                    
                                                                                                    
    // 58.13: this.head_nextThread := tmpTid as B;                                                  
                                                                                                    
                                                                                                    
    moverPath22304 := WriteEval.TreiberStack.head_nextThread(tid: Tid,this: TreiberStack,tmpTid: Tid,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22304 := m#moverPath(moverPath22304);                                                      
    path22304 := p#moverPath(moverPath22304);                                                       
    assume Node._state22304 == Node._state && Node.item22304 == Node.item && Node.next22304 == Node.next && Node._lock22304 == Node._lock && TreiberStack._state22304 == TreiberStack._state && TreiberStack.head22304 == TreiberStack.head && TreiberStack._lock22304 == TreiberStack._lock && TreiberStack.head_nextThread22304 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22304 == TreiberStack.head_nextValue && _m22304 == _m && tmpValue22304 == tmpValue && tmpTid22304 == tmpTid && ctmp364922304 == ctmp3649 && tmp422304 == tmp4 && newHead22304 == newHead && oldHead22304 == oldHead && tmp322304 == tmp3 && $result22304 == $result && this22304 == this && tid22304 == tid && $pc22304 == $pc;
    assume $recorded.state22304 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head_nextThread[this] := tmpTid;                                                   
                                                                                                    
                                                                                                    
    // 58.13: this.head_nextValue := tmpValue as B;                                                 
                                                                                                    
                                                                                                    
    moverPath22307 := WriteEval.TreiberStack.head_nextValue(tid: Tid,this: TreiberStack,tmpValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22307 := m#moverPath(moverPath22307);                                                      
    path22307 := p#moverPath(moverPath22307);                                                       
    assume Node._state22307 == Node._state && Node.item22307 == Node.item && Node.next22307 == Node.next && Node._lock22307 == Node._lock && TreiberStack._state22307 == TreiberStack._state && TreiberStack.head22307 == TreiberStack.head && TreiberStack._lock22307 == TreiberStack._lock && TreiberStack.head_nextThread22307 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22307 == TreiberStack.head_nextValue && _m22307 == _m && tmpValue22307 == tmpValue && tmpTid22307 == tmpTid && ctmp364922307 == ctmp3649 && tmp422307 == tmp4 && newHead22307 == newHead && oldHead22307 == oldHead && tmp322307 == tmp3 && $result22307 == $result && this22307 == this && tid22307 == tid && $pc22307 == $pc;
    assume $recorded.state22307 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head_nextValue[this] := tmpValue;                                                  
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 58.13: this.head := newHead;                                                                 
                                                                                                    
                                                                                                    
    moverPath22311 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22311 := m#moverPath(moverPath22311);                                                      
    path22311 := p#moverPath(moverPath22311);                                                       
    assume Node._state22311 == Node._state && Node.item22311 == Node.item && Node.next22311 == Node.next && Node._lock22311 == Node._lock && TreiberStack._state22311 == TreiberStack._state && TreiberStack.head22311 == TreiberStack.head && TreiberStack._lock22311 == TreiberStack._lock && TreiberStack.head_nextThread22311 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22311 == TreiberStack.head_nextValue && _m22311 == _m && tmpValue22311 == tmpValue && tmpTid22311 == tmpTid && ctmp364922311 == ctmp3649 && tmp422311 == tmp4 && newHead22311 == newHead && oldHead22311 == oldHead && tmp322311 == tmp3 && $result22311 == $result && this22311 == this && tid22311 == tid && $pc22311 == $pc;
    assume $recorded.state22311 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover22311);                                                             
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head[this] := newHead;                                                             
    if (isLocal(Node._state[newHead], tid)) {                                                       
     Node._state[newHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[newHead]]);                                           // (58.13): newHead became shared, but newHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 58.13: tmp4 = true;                                                                          
                                                                                                    
    tmp4 := true;                                                                                   
   } else {                                                                                         
                                                                                                    
    // 58.13: assume this.head_nextThread == tid;                                                   
                                                                                                    
    assume (TreiberStack.head_nextThread[this]==tid);                                               
                                                                                                    
    // 58.13: assume this.head_nextValue == oldHead;                                                
                                                                                                    
    assume (TreiberStack.head_nextValue[this]==oldHead);                                            
                                                                                                    
    // 58.13: Node _currentValue;                                                                   
                                                                                                    
                                                                                                    
    // 58.13: _currentValue := this.head  as B;                                                     
                                                                                                    
                                                                                                    
    moverPath22334 := ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22334 := m#moverPath(moverPath22334);                                                      
    path22334 := p#moverPath(moverPath22334);                                                       
    assume Node._state22334 == Node._state && Node.item22334 == Node.item && Node.next22334 == Node.next && Node._lock22334 == Node._lock && TreiberStack._state22334 == TreiberStack._state && TreiberStack.head22334 == TreiberStack.head && TreiberStack._lock22334 == TreiberStack._lock && TreiberStack.head_nextThread22334 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22334 == TreiberStack.head_nextValue && _currentValue22334 == _currentValue && ctmp364922334 == ctmp3649 && tmp422334 == tmp4 && newHead22334 == newHead && oldHead22334 == oldHead && tmp322334 == tmp3 && $result22334 == $result && this22334 == this && tid22334 == tid && $pc22334 == $pc;
    assume $recorded.state22334 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    _currentValue := TreiberStack.head[this];                                                       
                                                                                                    
                                                                                                    
    // 58.13: this.head := oldHead as B;                                                            
                                                                                                    
                                                                                                    
    moverPath22337 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,oldHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22337 := m#moverPath(moverPath22337);                                                      
    path22337 := p#moverPath(moverPath22337);                                                       
    assume Node._state22337 == Node._state && Node.item22337 == Node.item && Node.next22337 == Node.next && Node._lock22337 == Node._lock && TreiberStack._state22337 == TreiberStack._state && TreiberStack.head22337 == TreiberStack.head && TreiberStack._lock22337 == TreiberStack._lock && TreiberStack.head_nextThread22337 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22337 == TreiberStack.head_nextValue && _currentValue22337 == _currentValue && ctmp364922337 == ctmp3649 && tmp422337 == tmp4 && newHead22337 == newHead && oldHead22337 == oldHead && tmp322337 == tmp3 && $result22337 == $result && this22337 == this && tid22337 == tid && $pc22337 == $pc;
    assume $recorded.state22337 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head[this] := oldHead;                                                             
    if (isLocal(Node._state[oldHead], tid)) {                                                       
     Node._state[oldHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[oldHead]]);                                           // (58.13): oldHead became shared, but oldHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 58.13: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 58.13: _m = writePermission(this.head, newHead);                                             
                                                                                                    
    _m := m#moverPath(WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue));
                                                                                                    
                                                                                                    
    // 58.13: this.head := _currentValue as B;                                                      
                                                                                                    
                                                                                                    
    moverPath22349 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,_currentValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22349 := m#moverPath(moverPath22349);                                                      
    path22349 := p#moverPath(moverPath22349);                                                       
    assume Node._state22349 == Node._state && Node.item22349 == Node.item && Node.next22349 == Node.next && Node._lock22349 == Node._lock && TreiberStack._state22349 == TreiberStack._state && TreiberStack.head22349 == TreiberStack.head && TreiberStack._lock22349 == TreiberStack._lock && TreiberStack.head_nextThread22349 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22349 == TreiberStack.head_nextValue && _m22349 == _m && _currentValue22349 == _currentValue && ctmp364922349 == ctmp3649 && tmp422349 == tmp4 && newHead22349 == newHead && oldHead22349 == oldHead && tmp322349 == tmp3 && $result22349 == $result && this22349 == this && tid22349 == tid && $pc22349 == $pc;
    assume $recorded.state22349 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head[this] := _currentValue;                                                       
    if (isLocal(Node._state[_currentValue], tid)) {                                                 
     Node._state[_currentValue] := SHARED();                                                        
     assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                     // (58.13): _currentValue became shared, but _currentValue.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 58.13: assume goesWrong(_m);                                                                 
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 58.13: this.head := newHead;                                                                 
                                                                                                    
                                                                                                    
    moverPath22356 := WriteEval.TreiberStack.head(tid: Tid,this: TreiberStack,newHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
    mover22356 := m#moverPath(moverPath22356);                                                      
    path22356 := p#moverPath(moverPath22356);                                                       
    assume Node._state22356 == Node._state && Node.item22356 == Node.item && Node.next22356 == Node.next && Node._lock22356 == Node._lock && TreiberStack._state22356 == TreiberStack._state && TreiberStack.head22356 == TreiberStack.head && TreiberStack._lock22356 == TreiberStack._lock && TreiberStack.head_nextThread22356 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22356 == TreiberStack.head_nextValue && _m22356 == _m && _currentValue22356 == _currentValue && ctmp364922356 == ctmp3649 && tmp422356 == tmp4 && newHead22356 == newHead && oldHead22356 == oldHead && tmp322356 == tmp3 && $result22356 == $result && this22356 == this && tid22356 == tid && $pc22356 == $pc;
    assume $recorded.state22356 == 1;                                                               
    if ($pc == PreCommit) {                                                                         
     assume this != TreiberStack.null;                                                              
    } else {                                                                                        
     assert this != TreiberStack.null;                                                                     // (58.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover22356);                                                             
    assert $pc != PhaseError;                                                                              // (58.13): Reduction failure
    TreiberStack.head[this] := newHead;                                                             
    if (isLocal(Node._state[newHead], tid)) {                                                       
     Node._state[newHead] := SHARED();                                                              
     assert isSharedAssignable(Node._state[Node.next[newHead]]);                                           // (58.13): newHead became shared, but newHead.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 58.13: tmp4 = false;                                                                         
                                                                                                    
    tmp4 := false;                                                                                  
   }                                                                                                
  }                                                                                                 
  if (tmp4) {                                                                                       
                                                                                                    
   // 59.17: int tmp5;                                                                              
                                                                                                    
                                                                                                    
   // 59.17: tmp5 := oldHead.item;                                                                  
                                                                                                    
                                                                                                    
   moverPath22371 := ReadEval.Node.item(tid: Tid,oldHead: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
   mover22371 := m#moverPath(moverPath22371);                                                       
   path22371 := p#moverPath(moverPath22371);                                                        
   assume Node._state22371 == Node._state && Node.item22371 == Node.item && Node.next22371 == Node.next && Node._lock22371 == Node._lock && TreiberStack._state22371 == TreiberStack._state && TreiberStack.head22371 == TreiberStack.head && TreiberStack._lock22371 == TreiberStack._lock && TreiberStack.head_nextThread22371 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22371 == TreiberStack.head_nextValue && tmp522371 == tmp5 && tmp422371 == tmp4 && newHead22371 == newHead && oldHead22371 == oldHead && tmp322371 == tmp3 && $result22371 == $result && this22371 == this && tid22371 == tid && $pc22371 == $pc;
   assume $recorded.state22371 == 1;                                                                
   if ($pc == PreCommit) {                                                                          
    assume oldHead != Node.null;                                                                    
   } else {                                                                                         
    assert oldHead != Node.null;                                                                           // (59.17): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover22371);                                                              
   assert $pc != PhaseError;                                                                               // (59.17): Reduction failure
   tmp5 := Node.item[oldHead];                                                                      
                                                                                                    
   // 59.17:  return tmp5;                                                                          
                                                                                                    
   assume Node._state22373 == Node._state && Node.item22373 == Node.item && Node.next22373 == Node.next && Node._lock22373 == Node._lock && TreiberStack._state22373 == TreiberStack._state && TreiberStack.head22373 == TreiberStack.head && TreiberStack._lock22373 == TreiberStack._lock && TreiberStack.head_nextThread22373 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22373 == TreiberStack.head_nextValue && tmp522373 == tmp5 && tmp422373 == tmp4 && newHead22373 == newHead && oldHead22373 == oldHead && tmp322373 == tmp3 && $result22373 == $result && this22373 == this && tid22373 == tid;
   assume $recorded.state22373 == 1;                                                                
   $result := tmp5;                                                                                 
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
  assume Node._state22380_bottom == Node._state && Node.item22380_bottom == Node.item && Node.next22380_bottom == Node.next && Node._lock22380_bottom == Node._lock && TreiberStack._state22380_bottom == TreiberStack._state && TreiberStack.head22380_bottom == TreiberStack.head && TreiberStack._lock22380_bottom == TreiberStack._lock && TreiberStack.head_nextThread22380_bottom == TreiberStack.head_nextThread && TreiberStack.head_nextValue22380_bottom == TreiberStack.head_nextValue && $result22380_bottom == $result && this22380_bottom == this && tid22380_bottom == tid;
  assume $recorded.state22380_bottom == 1;                                                          
  assert phase22380 == $pc;                                                                                // (54.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 53.22: // return -1;                                                                            
                                                                                                    
 assume Node._state22383 == Node._state && Node.item22383 == Node.item && Node.next22383 == Node.next && Node._lock22383 == Node._lock && TreiberStack._state22383 == TreiberStack._state && TreiberStack.head22383 == TreiberStack.head && TreiberStack._lock22383 == TreiberStack._lock && TreiberStack.head_nextThread22383 == TreiberStack.head_nextThread && TreiberStack.head_nextValue22383 == TreiberStack.head_nextValue && $result22383 == $result && this22383 == this && tid22383 == tid;
 assume $recorded.state22383 == 1;                                                                  
 $result := -1;                                                                                     
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,TreiberStack._state: [TreiberStack]State,TreiberStack.head: [TreiberStack]Node,TreiberStack._lock: [TreiberStack]Tid,TreiberStack.head_nextThread: [TreiberStack]Tid,TreiberStack.head_nextValue: [TreiberStack]Node) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: TreiberStack  :: _i == TreiberStack.null <==> isNull(TreiberStack._state[_i])) &&     
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: TreiberStack ::  (isShared(TreiberStack._state[_i]) ==> isSharedAssignable(Node._state[TreiberStack.head[_i]]))) &&
  (forall _i: TreiberStack ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(TreiberStack._state[_i],_t) ==> isLocalAssignable(Node._state[TreiberStack.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.5): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.5): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (11.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (11.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (11.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (11.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (11.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (11.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.TreiberStack.head(u: Tid,x: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): TreiberStack.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.TreiberStack.head(u: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (19.5): TreiberStack.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == TreiberStack.head[x];                                                                  
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 TreiberStack.head[x] := havocValue;                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.TreiberStack.head(u: Tid,x: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): TreiberStack.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == TreiberStack.head[x];                                                                  
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.TreiberStack.head(u: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (19.5): TreiberStack.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.TreiberStack.head(u: Tid,x: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): TreiberStack.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, x: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[x], u);                                                  
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == TreiberStack.head[x];                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 TreiberStack.head[x] := havocValue;                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.TreiberStack.head(u: Tid,x: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): TreiberStack.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var w_mid: int;                                                                                    
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var w_mid: int;                                                                                    
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.TreiberStack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.TreiberStack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.TreiberStack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.TreiberStack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.TreiberStack.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.item;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies Node.next;                                                                                
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.TreiberStack.head.Node.item(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w1: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.item[y];                                                                              
 Node.item[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.item(u: Tid,y: Node,w2: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.item[y] := tmpW;                                                                              
                                                                                                    
 TreiberStack.head[x] := v;                                                                         
 Node.item[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.item(u: Tid,y: Node,w2: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.TreiberStack.head.Node.item(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var w_mid: int;                                                                                    
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var v1_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 TreiberStack.head[x] := tmpV;                                                                      
                                                                                                    
 Node.item[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v1: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.TreiberStack.head.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var w2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w2_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 TreiberStack.head[x] := v;                                                                         
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.TreiberStack.head.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: TreiberStack, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(Node._state[y], u);                                                          
 modifies TreiberStack.head;                                                                        
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var v1_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 TreiberStack.head[x] := tmpV;                                                                      
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v1: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 TreiberStack.head[x] := tmpV;                                                                      
 TreiberStack.head[y] := w;                                                                         
 _writeByTPost := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[y] := w;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.TreiberStack.head(t: Tid,x: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 TreiberStack.head[x] := v;                                                                         
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.TreiberStack.head(u: Tid,y: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var w2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var v_pre: Node;                                                                                   
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var v_mid: Node;                                                                                   
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var w2_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w1: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := TreiberStack.head[y];                                                                      
 TreiberStack.head[y] := w1;                                                                        
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 TreiberStack.head[y] := tmpW;                                                                      
                                                                                                    
 TreiberStack.head[x] := v;                                                                         
 TreiberStack.head[y] := w1;                                                                        
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.TreiberStack.head.TreiberStack.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: TreiberStack, y: TreiberStack)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(TreiberStack._state[x], t);                                                  
 requires isAccessible(TreiberStack._state[y], u);                                                  
 modifies TreiberStack.head;                                                                        
 modifies TreiberStack.head;                                                                        
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var y_pre: TreiberStack;                                                                           
 var TreiberStack._state_pre: [TreiberStack]State;                                                  
 var v2_pre: Node;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var TreiberStack._lock_pre: [TreiberStack]Tid;                                                     
 var TreiberStack.head_pre: [TreiberStack]Node;                                                     
 var v1_pre: Node;                                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                           
 var Node.item_pre: [Node]int;                                                                      
 var x_pre: TreiberStack;                                                                           
 var t_pre: Tid;                                                                                    
 var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                           
                                                                                                    
 var TreiberStack._lock_mid: [TreiberStack]Tid;                                                     
 var TreiberStack.head_nextValue_mid: [TreiberStack]Node;                                           
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var y_mid: TreiberStack;                                                                           
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var TreiberStack.head_nextThread_mid: [TreiberStack]Tid;                                           
 var x_mid: TreiberStack;                                                                           
 var TreiberStack._state_mid: [TreiberStack]State;                                                  
 var v1_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var TreiberStack.head_mid: [TreiberStack]Node;                                                     
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var y_post: TreiberStack;                                                                          
 var TreiberStack.head_post: [TreiberStack]Node;                                                    
 var $pc_post: Phase;                                                                               
 var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                          
 var Node._lock_post: [Node]Tid;                                                                    
 var TreiberStack._state_post: [TreiberStack]State;                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                          
 var TreiberStack._lock_post: [TreiberStack]Tid;                                                    
 var x_post: TreiberStack;                                                                          
 var v2_post: Node;                                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.TreiberStack.head(u: Tid,y: TreiberStack,w: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := TreiberStack.head[x];                                                                      
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 TreiberStack.head[x] := tmpV;                                                                      
                                                                                                    
 TreiberStack.head[y] := w;                                                                         
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && TreiberStack._state_mid == TreiberStack._state && TreiberStack.head_mid == TreiberStack.head && TreiberStack._lock_mid == TreiberStack._lock && TreiberStack.head_nextThread_mid == TreiberStack.head_nextThread && TreiberStack.head_nextValue_mid == TreiberStack.head_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v1: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 TreiberStack.head[x] := v1;                                                                        
 _writeByTAfterUAndT := WriteEval.TreiberStack.head(t: Tid,x: TreiberStack,v2: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && TreiberStack._state_post == TreiberStack._state && TreiberStack.head_post == TreiberStack.head && TreiberStack._lock_post == TreiberStack._lock && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
requires ValidTid(tid);                                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies TreiberStack._state;                                                                       
modifies TreiberStack.head;                                                                         
modifies TreiberStack._lock;                                                                        
modifies TreiberStack.head_nextThread;                                                              
modifies TreiberStack.head_nextValue;                                                               
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
ensures Y(tid , old(Node._state), old(Node.item), old(Node.next), old(Node._lock), old(TreiberStack._state), old(TreiberStack.head), old(TreiberStack._lock), old(TreiberStack.head_nextThread), old(TreiberStack.head_nextValue) , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
                                                                                                    
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var newValue_yield: int;                                                                            
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var TreiberStack._state_pre: [TreiberStack]State;                                                   
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var newValue_pre: int;                                                                              
var Node._state_pre: [Node]State;                                                                   
var TreiberStack._lock_pre: [TreiberStack]Tid;                                                      
var TreiberStack.head_pre: [TreiberStack]Node;                                                      
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                            
var Node.item_pre: [Node]int;                                                                       
var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                            
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var newValue_post: int;                                                                             
var TreiberStack.head_post: [TreiberStack]Node;                                                     
var $pc_post: Phase;                                                                                
var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                           
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var TreiberStack._state_post: [TreiberStack]State;                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                           
var TreiberStack._lock_post: [TreiberStack]Tid;                                                     
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 assume Y_Node.item(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && TreiberStack._state_post == TreiberStack._state_p && TreiberStack.head_post == TreiberStack.head_p && TreiberStack._lock_post == TreiberStack._lock_p && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread_p && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var TreiberStack._state_pre: [TreiberStack]State;                                                   
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Node._state_pre: [Node]State;                                                                   
var TreiberStack._lock_pre: [TreiberStack]Tid;                                                      
var TreiberStack.head_pre: [TreiberStack]Node;                                                      
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                            
var Node.item_pre: [Node]int;                                                                       
var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                            
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var TreiberStack.head_post: [TreiberStack]Node;                                                     
var $pc_post: Phase;                                                                                
var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                           
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var TreiberStack._state_post: [TreiberStack]State;                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                           
var TreiberStack._lock_post: [TreiberStack]Tid;                                                     
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && TreiberStack._state_post == TreiberStack._state_p && TreiberStack.head_post == TreiberStack.head_p && TreiberStack._lock_post == TreiberStack._lock_p && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread_p && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var TreiberStack._state_pre: [TreiberStack]State;                                                   
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Node._state_pre: [Node]State;                                                                   
var TreiberStack._lock_pre: [TreiberStack]Tid;                                                      
var TreiberStack.head_pre: [TreiberStack]Node;                                                      
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                            
var Node.item_pre: [Node]int;                                                                       
var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                            
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var TreiberStack.head_post: [TreiberStack]Node;                                                     
var $pc_post: Phase;                                                                                
var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                           
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var TreiberStack._state_post: [TreiberStack]State;                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                           
var TreiberStack._lock_post: [TreiberStack]Tid;                                                     
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && TreiberStack._state_post == TreiberStack._state_p && TreiberStack.head_post == TreiberStack.head_p && TreiberStack._lock_post == TreiberStack._lock_p && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread_p && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
// TreiberStack.head:                                                                               
                                                                                                    
function {:inline} Y_TreiberStack.head(tid : Tid, this: TreiberStack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(TreiberStack._state[this], tid) && leq(m#moverPath(ReadEval.TreiberStack.head(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (TreiberStack.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_TreiberStack.head(tid : Tid, this: TreiberStack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack.head.Subsumes.W(tid : Tid, u : Tid, this: TreiberStack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: TreiberStack;                                                                       
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
 assume isAccessible(TreiberStack._state[this], u);                                                 
 assume !isError(m#moverPath(WriteEval.TreiberStack.head(u: Tid,this: TreiberStack,newValue: Node,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_TreiberStack.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack.head.Reflexive(tid : Tid, this: TreiberStack , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: TreiberStack;                                                                       
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_TreiberStack.head(tid, this, TreiberStack.head[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack.head.Transitive(tid : Tid, this: TreiberStack, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var TreiberStack._state_pre: [TreiberStack]State;                                                   
var $recorded.state_pre: int;                                                                       
var this_pre: TreiberStack;                                                                         
var Node._state_pre: [Node]State;                                                                   
var TreiberStack._lock_pre: [TreiberStack]Tid;                                                      
var TreiberStack.head_pre: [TreiberStack]Node;                                                      
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                            
var Node.item_pre: [Node]int;                                                                       
var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                            
                                                                                                    
var this_post: TreiberStack;                                                                        
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var TreiberStack.head_post: [TreiberStack]Node;                                                     
var $pc_post: Phase;                                                                                
var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                           
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var TreiberStack._state_post: [TreiberStack]State;                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                           
var TreiberStack._lock_post: [TreiberStack]Tid;                                                     
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 assume Y_TreiberStack.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && TreiberStack._state_post == TreiberStack._state_p && TreiberStack.head_post == TreiberStack.head_p && TreiberStack._lock_post == TreiberStack._lock_p && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread_p && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_TreiberStack.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
// TreiberStack._lock:                                                                              
                                                                                                    
function {:inline} Y_TreiberStack._lock(tid : Tid, this: TreiberStack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(TreiberStack._state[this], tid) && leq(m#moverPath(ReadEval.TreiberStack._lock(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (TreiberStack._lock[this] == newValue))
 &&(((TreiberStack._lock[this]==tid)==(newValue==tid)))                                             
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_TreiberStack._lock(tid : Tid, this: TreiberStack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack._lock.Subsumes.W(tid : Tid, u : Tid, this: TreiberStack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: TreiberStack;                                                                       
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
 assume isAccessible(TreiberStack._state[this], u);                                                 
 assume !isError(m#moverPath(WriteEval.TreiberStack._lock(u: Tid,this: TreiberStack,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)));
 assume leq(m#moverPath(ReadEval.TreiberStack._lock(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_TreiberStack._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack._lock.Reflexive(tid : Tid, this: TreiberStack , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var TreiberStack.head_nextValue_yield: [TreiberStack]Node;                                          
var Node.item_yield: [Node]int;                                                                     
var TreiberStack._state_yield: [TreiberStack]State;                                                 
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var this_yield: TreiberStack;                                                                       
var TreiberStack._lock_yield: [TreiberStack]Tid;                                                    
var TreiberStack.head_yield: [TreiberStack]Node;                                                    
var TreiberStack.head_nextThread_yield: [TreiberStack]Tid;                                          
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && TreiberStack._state_yield == TreiberStack._state && TreiberStack.head_yield == TreiberStack.head && TreiberStack._lock_yield == TreiberStack._lock && TreiberStack.head_nextThread_yield == TreiberStack.head_nextThread && TreiberStack.head_nextValue_yield == TreiberStack.head_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_TreiberStack._lock(tid, this, TreiberStack._lock[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_TreiberStack._lock.Transitive(tid : Tid, this: TreiberStack, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var TreiberStack._state_pre: [TreiberStack]State;                                                   
var $recorded.state_pre: int;                                                                       
var this_pre: TreiberStack;                                                                         
var Node._state_pre: [Node]State;                                                                   
var TreiberStack._lock_pre: [TreiberStack]Tid;                                                      
var TreiberStack.head_pre: [TreiberStack]Node;                                                      
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var TreiberStack.head_nextValue_pre: [TreiberStack]Node;                                            
var Node.item_pre: [Node]int;                                                                       
var TreiberStack.head_nextThread_pre: [TreiberStack]Tid;                                            
                                                                                                    
var this_post: TreiberStack;                                                                        
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var TreiberStack.head_post: [TreiberStack]Node;                                                     
var $pc_post: Phase;                                                                                
var TreiberStack.head_nextThread_post: [TreiberStack]Tid;                                           
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var TreiberStack._state_post: [TreiberStack]State;                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var TreiberStack.head_nextValue_post: [TreiberStack]Node;                                           
var TreiberStack._lock_post: [TreiberStack]Tid;                                                     
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && TreiberStack._state_pre == TreiberStack._state && TreiberStack.head_pre == TreiberStack.head && TreiberStack._lock_pre == TreiberStack._lock && TreiberStack.head_nextThread_pre == TreiberStack.head_nextThread && TreiberStack.head_nextValue_pre == TreiberStack.head_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(TreiberStack._state[this], tid);                                               
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
 assume Y_TreiberStack._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, TreiberStack._state_p, TreiberStack.head_p, TreiberStack._lock_p, TreiberStack.head_nextThread_p, TreiberStack.head_nextValue_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && TreiberStack._state_post == TreiberStack._state_p && TreiberStack.head_post == TreiberStack.head_p && TreiberStack._lock_post == TreiberStack._lock_p && TreiberStack.head_nextThread_post == TreiberStack.head_nextThread_p && TreiberStack.head_nextValue_post == TreiberStack.head_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_TreiberStack._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue);
}                                                                                                   
// TreiberStack.head_nextThread:                                                                    
                                                                                                    
function {:inline} Y_TreiberStack.head_nextThread(tid : Tid, this: TreiberStack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(TreiberStack._state[this], tid) && leq(m#moverPath(ReadEval.TreiberStack.head_nextThread(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (TreiberStack.head_nextThread[this] == newValue))
 &&(((TreiberStack.head_nextThread[this]==tid)==>(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_TreiberStack.head_nextThread(tid : Tid, this: TreiberStack, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// TreiberStack.head_nextValue:                                                                     
                                                                                                    
function {:inline} Y_TreiberStack.head_nextValue(tid : Tid, this: TreiberStack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 ((isAccessible(TreiberStack._state[this], tid) && leq(m#moverPath(ReadEval.TreiberStack.head_nextValue(tid: Tid,this: TreiberStack,Node._state,Node.item,Node.next,Node._lock,TreiberStack._state,TreiberStack.head,TreiberStack._lock,TreiberStack.head_nextThread,TreiberStack.head_nextValue)), _R)) ==> (TreiberStack.head_nextValue[this] == newValue))
 &&(((TreiberStack.head_nextThread[this]==tid)==>(newValue==TreiberStack.head_nextValue[this])))    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_TreiberStack.head_nextValue(tid : Tid, this: TreiberStack, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, TreiberStack._state: [TreiberStack]State, TreiberStack.head: [TreiberStack]Node, TreiberStack._lock: [TreiberStack]Tid, TreiberStack.head_nextThread: [TreiberStack]Tid, TreiberStack.head_nextValue: [TreiberStack]Node , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, TreiberStack._state_p: [TreiberStack]State, TreiberStack.head_p: [TreiberStack]Node, TreiberStack._lock_p: [TreiberStack]Tid, TreiberStack.head_nextThread_p: [TreiberStack]Tid, TreiberStack.head_nextValue_p: [TreiberStack]Node): bool
{                                                                                                   
 (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: TreiberStack :: Y_TreiberStack.head(tid : Tid, this, TreiberStack.head_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: TreiberStack :: Y_TreiberStack._lock(tid : Tid, this, TreiberStack._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: TreiberStack :: Y_TreiberStack.head_nextThread(tid : Tid, this, TreiberStack.head_nextThread_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall this: TreiberStack :: Y_TreiberStack.head_nextValue(tid : Tid, this, TreiberStack.head_nextValue_p[this] , Node._state, Node.item, Node.next, Node._lock, TreiberStack._state, TreiberStack.head, TreiberStack._lock, TreiberStack.head_nextThread, TreiberStack.head_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : TreiberStack :: isShared(TreiberStack._state[_i]) ==> isShared(TreiberStack._state_p[_i]))
 && (forall _i : TreiberStack :: isLocal(TreiberStack._state[_i], tid) <==> isLocal(TreiberStack._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1240.1-1332.2: (Method:13.5)
// 1253.1-1253.24: (13.5): Bad tid
// 1298.1-1298.235: (13.5): Can only have right-mover memory accesses in requires clause
// 1300.2-1303.30: (class anchor.sink.Assume:13.5)
// 1304.2-1307.38: (class anchor.sink.Assume:13.5)
// 1309.2-1325.26: (class anchor.sink.Write:14.9)
// 1321.1-1321.28: (14.9): Cannot have potential null deference in left-mover part.
// 1324.1-1324.27: (14.9): Reduction failure
// 1326.2-1331.9: (class anchor.sink.Return:13.27)
// 1494.1-2452.2: (Method:21.5)
// 1507.1-1507.24: (21.5): Bad tid
// 1508.1-1508.46: (21.5): this is not global
// 1957.2-1961.14: (class anchor.sink.While:39.9)
// 1963.1-1963.27: (21.5): Bad tid
// 1964.1-1964.49: (21.5): this is not global
// 1967.1-1967.299: (39.9): Loop does not preserve yields_as annotation for field item
// 1968.1-1968.299: (39.9): Loop does not preserve yields_as annotation for field next
// 1969.1-1969.323: (39.9): Loop does not preserve yields_as annotation for field head
// 1970.1-1970.31: (39.9): Phase must be invariant at loop head
// 1971.1-1971.30: (39.9): Potentially infinite loop cannot be in post-commit phase.
// 1973.3-1975.3: (class anchor.sink.VarDeclStmt:39.16)
// 1976.3-1979.16: (class anchor.sink.Assign:39.16)
// 1981.4-1984.10: (class anchor.sink.Break:39.9)
// 1987.3-1989.3: (class anchor.sink.VarDeclStmt:40.13)
// 1990.3-1998.43: (class anchor.sink.Alloc:40.13)
// 2001.3-2003.3: (class anchor.sink.VarDeclStmt:40.13)
// 2004.3-2006.3: (class anchor.sink.VarDeclStmt:40.13)
// 2007.3-2010.18: (class anchor.sink.Assign:40.13)
// 2011.3-2014.21: (class anchor.sink.Assign:40.13)
// 2015.3-2018.33: (class anchor.sink.Assume:13.5)
// 2019.3-2022.41: (class anchor.sink.Assume:13.5)
// 2024.3-2040.31: (class anchor.sink.Write:14.9)
// 2036.1-2036.31: (14.9): Cannot have potential null deference in left-mover part.
// 2039.1-2039.28: (14.9): Reduction failure
// 2041.3-2044.22: (class anchor.sink.Break:13.27)
// 2046.3-2048.3: (class anchor.sink.VarDeclStmt:41.13)
// 2050.3-2052.3: (class anchor.sink.VarDeclStmt:41.13)
// 2053.3-2070.46: (class anchor.sink.Read:41.13)
// 2065.1-2065.37: (41.13): Cannot have potential null deference in left-mover part.
// 2069.1-2069.28: (41.13): Reduction failure
// 2071.3-2073.3: (class anchor.sink.VarDeclStmt:41.13)
// 2074.3-2091.45: (class anchor.sink.Read:41.13)
// 2086.1-2086.37: (41.13): Cannot have potential null deference in left-mover part.
// 2090.1-2090.28: (41.13): Reduction failure
// 2092.3-2094.3: (class anchor.sink.VarDeclStmt:41.13)
// 2095.3-2112.44: (class anchor.sink.Read:41.13)
// 2107.1-2107.37: (41.13): Cannot have potential null deference in left-mover part.
// 2111.1-2111.28: (41.13): Reduction failure
// 2113.3-2115.3: (class anchor.sink.VarDeclStmt:41.13)
// 2116.3-2119.237: (class anchor.sink.Assign:41.13)
// 2120.3-2122.3: (class anchor.sink.VarDeclStmt:41.13)
// 2123.3-2126.75: (class anchor.sink.Assign:41.13)
// 2129.4-2146.39: (class anchor.sink.Read:41.13)
// 2141.1-2141.38: (41.13): Cannot have potential null deference in left-mover part.
// 2145.1-2145.29: (41.13): Reduction failure
// 2149.4-2166.39: (class anchor.sink.Read:41.13)
// 2161.1-2161.38: (41.13): Cannot have potential null deference in left-mover part.
// 2165.1-2165.29: (41.13): Reduction failure
// 2168.3-2176.41: (class anchor.sink.Yield:42.13)
// 2178.3-2199.3: (class anchor.sink.Write:43.13)
// 2190.1-2190.32: (43.13): Cannot have potential null deference in left-mover part.
// 2193.1-2193.28: (43.13): Reduction failure
// 2197.1-2197.63: (43.13): oldHead became shared, but oldHead.next may not be shared.
// 2200.3-2202.3: (class anchor.sink.VarDeclStmt:44.13)
// 2204.3-2206.3: (class anchor.sink.VarDeclStmt:44.13)
// 2207.3-2210.18: (class anchor.sink.Assign:44.13)
// 2213.4-2216.18: (class anchor.sink.Assign:44.13)
// 2218.4-2221.19: (class anchor.sink.Assign:44.13)
// 2223.5-2225.5: (class anchor.sink.VarDeclStmt:44.13)
// 2226.5-2228.5: (class anchor.sink.VarDeclStmt:44.13)
// 2229.5-2231.5: (class anchor.sink.VarDeclStmt:44.13)
// 2232.5-2235.252: (class anchor.sink.Assign:44.13)
// 2236.5-2239.47: (class anchor.sink.Assume:44.13)
// 2240.5-2243.49: (class anchor.sink.Assume:44.13)
// 2244.5-2247.54: (class anchor.sink.Assume:44.13)
// 2248.5-2251.57: (class anchor.sink.Assume:44.13)
// 2253.5-2269.50: (class anchor.sink.Write:44.13)
// 2265.1-2265.39: (44.13): Cannot have potential null deference in left-mover part.
// 2268.1-2268.30: (44.13): Reduction failure
// 2271.5-2287.51: (class anchor.sink.Write:44.13)
// 2283.1-2283.39: (44.13): Cannot have potential null deference in left-mover part.
// 2286.1-2286.30: (44.13): Reduction failure
// 2290.5-2311.5: (class anchor.sink.Write:44.13)
// 2302.1-2302.39: (44.13): Cannot have potential null deference in left-mover part.
// 2305.1-2305.30: (44.13): Reduction failure
// 2309.1-2309.65: (44.13): newHead became shared, but newHead.next may not be shared.
// 2312.5-2315.18: (class anchor.sink.Assign:44.13)
// 2317.5-2320.54: (class anchor.sink.Assume:44.13)
// 2321.5-2324.57: (class anchor.sink.Assume:44.13)
// 2325.5-2327.5: (class anchor.sink.VarDeclStmt:44.13)
// 2328.5-2345.46: (class anchor.sink.Read:44.13)
// 2340.1-2340.39: (44.13): Cannot have potential null deference in left-mover part.
// 2344.1-2344.30: (44.13): Reduction failure
// 2347.5-2368.5: (class anchor.sink.Write:44.13)
// 2359.1-2359.39: (44.13): Cannot have potential null deference in left-mover part.
// 2362.1-2362.30: (44.13): Reduction failure
// 2366.1-2366.65: (44.13): oldHead became shared, but oldHead.next may not be shared.
// 2369.5-2371.5: (class anchor.sink.VarDeclStmt:44.13)
// 2372.5-2375.252: (class anchor.sink.Assign:44.13)
// 2377.5-2398.5: (class anchor.sink.Write:44.13)
// 2389.1-2389.39: (44.13): Cannot have potential null deference in left-mover part.
// 2392.1-2392.30: (44.13): Reduction failure
// 2396.1-2396.71: (44.13): _currentValue became shared, but _currentValue.next may not be shared.
// 2399.5-2402.46: (class anchor.sink.Assume:44.13)
// 2405.5-2426.5: (class anchor.sink.Write:44.13)
// 2417.1-2417.39: (44.13): Cannot have potential null deference in left-mover part.
// 2420.1-2420.30: (44.13): Reduction failure
// 2424.1-2424.65: (44.13): newHead became shared, but newHead.next may not be shared.
// 2427.5-2430.19: (class anchor.sink.Assign:44.13)
// 2434.4-2439.11: (class anchor.sink.Return:45.17)
// 2444.1-2444.28: (39.9): Phase must be invariant at loop head
// 2446.2-2451.9: (class anchor.sink.Return:25.32)
// 2453.1-3368.2: (Method:50.5)
// 2467.1-2467.24: (50.5): Bad tid
// 2468.1-2468.46: (50.5): this is not global
// 2911.2-2915.14: (class anchor.sink.While:54.9)
// 2917.1-2917.27: (50.5): Bad tid
// 2918.1-2918.49: (50.5): this is not global
// 2921.1-2921.299: (54.9): Loop does not preserve yields_as annotation for field item
// 2922.1-2922.299: (54.9): Loop does not preserve yields_as annotation for field next
// 2923.1-2923.323: (54.9): Loop does not preserve yields_as annotation for field head
// 2924.1-2924.31: (54.9): Phase must be invariant at loop head
// 2925.1-2925.30: (54.9): Potentially infinite loop cannot be in post-commit phase.
// 2927.3-2929.3: (class anchor.sink.VarDeclStmt:54.16)
// 2930.3-2933.16: (class anchor.sink.Assign:54.16)
// 2935.4-2938.10: (class anchor.sink.Break:54.9)
// 2941.3-2943.3: (class anchor.sink.VarDeclStmt:55.13)
// 2945.3-2947.3: (class anchor.sink.VarDeclStmt:55.13)
// 2948.3-2965.46: (class anchor.sink.Read:55.13)
// 2960.1-2960.37: (55.13): Cannot have potential null deference in left-mover part.
// 2964.1-2964.28: (55.13): Reduction failure
// 2966.3-2968.3: (class anchor.sink.VarDeclStmt:55.13)
// 2969.3-2986.45: (class anchor.sink.Read:55.13)
// 2981.1-2981.37: (55.13): Cannot have potential null deference in left-mover part.
// 2985.1-2985.28: (55.13): Reduction failure
// 2987.3-2989.3: (class anchor.sink.VarDeclStmt:55.13)
// 2990.3-3007.44: (class anchor.sink.Read:55.13)
// 3002.1-3002.37: (55.13): Cannot have potential null deference in left-mover part.
// 3006.1-3006.28: (55.13): Reduction failure
// 3008.3-3010.3: (class anchor.sink.VarDeclStmt:55.13)
// 3011.3-3014.237: (class anchor.sink.Assign:55.13)
// 3015.3-3017.3: (class anchor.sink.VarDeclStmt:55.13)
// 3018.3-3021.75: (class anchor.sink.Assign:55.13)
// 3024.4-3041.39: (class anchor.sink.Read:55.13)
// 3036.1-3036.38: (55.13): Cannot have potential null deference in left-mover part.
// 3040.1-3040.29: (55.13): Reduction failure
// 3044.4-3061.39: (class anchor.sink.Read:55.13)
// 3056.1-3056.38: (55.13): Cannot have potential null deference in left-mover part.
// 3060.1-3060.29: (55.13): Reduction failure
// 3063.3-3071.41: (class anchor.sink.Yield:56.13)
// 3072.3-3074.3: (class anchor.sink.VarDeclStmt:57.13)
// 3075.3-3092.33: (class anchor.sink.Read:57.13)
// 3087.1-3087.32: (57.13): Cannot have potential null deference in left-mover part.
// 3091.1-3091.28: (57.13): Reduction failure
// 3093.3-3095.3: (class anchor.sink.VarDeclStmt:58.13)
// 3097.3-3099.3: (class anchor.sink.VarDeclStmt:58.13)
// 3100.3-3103.18: (class anchor.sink.Assign:58.13)
// 3106.4-3109.18: (class anchor.sink.Assign:58.13)
// 3111.4-3114.19: (class anchor.sink.Assign:58.13)
// 3116.5-3118.5: (class anchor.sink.VarDeclStmt:58.13)
// 3119.5-3121.5: (class anchor.sink.VarDeclStmt:58.13)
// 3122.5-3124.5: (class anchor.sink.VarDeclStmt:58.13)
// 3125.5-3128.252: (class anchor.sink.Assign:58.13)
// 3129.5-3132.47: (class anchor.sink.Assume:58.13)
// 3133.5-3136.49: (class anchor.sink.Assume:58.13)
// 3137.5-3140.54: (class anchor.sink.Assume:58.13)
// 3141.5-3144.57: (class anchor.sink.Assume:58.13)
// 3146.5-3162.50: (class anchor.sink.Write:58.13)
// 3158.1-3158.39: (58.13): Cannot have potential null deference in left-mover part.
// 3161.1-3161.30: (58.13): Reduction failure
// 3164.5-3180.51: (class anchor.sink.Write:58.13)
// 3176.1-3176.39: (58.13): Cannot have potential null deference in left-mover part.
// 3179.1-3179.30: (58.13): Reduction failure
// 3183.5-3204.5: (class anchor.sink.Write:58.13)
// 3195.1-3195.39: (58.13): Cannot have potential null deference in left-mover part.
// 3198.1-3198.30: (58.13): Reduction failure
// 3202.1-3202.65: (58.13): newHead became shared, but newHead.next may not be shared.
// 3205.5-3208.18: (class anchor.sink.Assign:58.13)
// 3210.5-3213.54: (class anchor.sink.Assume:58.13)
// 3214.5-3217.57: (class anchor.sink.Assume:58.13)
// 3218.5-3220.5: (class anchor.sink.VarDeclStmt:58.13)
// 3221.5-3238.46: (class anchor.sink.Read:58.13)
// 3233.1-3233.39: (58.13): Cannot have potential null deference in left-mover part.
// 3237.1-3237.30: (58.13): Reduction failure
// 3240.5-3261.5: (class anchor.sink.Write:58.13)
// 3252.1-3252.39: (58.13): Cannot have potential null deference in left-mover part.
// 3255.1-3255.30: (58.13): Reduction failure
// 3259.1-3259.65: (58.13): oldHead became shared, but oldHead.next may not be shared.
// 3262.5-3264.5: (class anchor.sink.VarDeclStmt:58.13)
// 3265.5-3268.252: (class anchor.sink.Assign:58.13)
// 3270.5-3291.5: (class anchor.sink.Write:58.13)
// 3282.1-3282.39: (58.13): Cannot have potential null deference in left-mover part.
// 3285.1-3285.30: (58.13): Reduction failure
// 3289.1-3289.71: (58.13): _currentValue became shared, but _currentValue.next may not be shared.
// 3292.5-3295.46: (class anchor.sink.Assume:58.13)
// 3298.5-3319.5: (class anchor.sink.Write:58.13)
// 3310.1-3310.39: (58.13): Cannot have potential null deference in left-mover part.
// 3313.1-3313.30: (58.13): Reduction failure
// 3317.1-3317.65: (58.13): newHead became shared, but newHead.next may not be shared.
// 3320.5-3323.19: (class anchor.sink.Assign:58.13)
// 3327.4-3329.4: (class anchor.sink.VarDeclStmt:59.17)
// 3330.4-3347.31: (class anchor.sink.Read:59.17)
// 3342.1-3342.33: (59.17): Cannot have potential null deference in left-mover part.
// 3346.1-3346.29: (59.17): Reduction failure
// 3348.4-3354.11: (class anchor.sink.Return:59.17)
// 3359.1-3359.28: (54.9): Phase must be invariant at loop head
// 3361.2-3367.9: (class anchor.sink.Return:53.22)
// 3459.1-3459.34: (10.5): Node.item failed Write-Write Right-Mover Check
// 3528.1-3528.30: (10.5): Node.item failed Write-Read Right-Mover Check
// 3601.1-3601.34: (10.5): Node.item failed Write-Write Left-Mover Check
// 3671.1-3671.30: (10.5): Node.item failed Write-Read Left-Mover Check
// 3738.1-3738.34: (10.5): Node.item failed Read-Write Right-Mover Check
// 3808.1-3808.34: (10.5): Node.item failed Read-Write Left-Mover Check
// 3877.1-3877.34: (11.5): Node.next failed Write-Write Right-Mover Check
// 3946.1-3946.30: (11.5): Node.next failed Write-Read Right-Mover Check
// 4019.1-4019.34: (11.5): Node.next failed Write-Write Left-Mover Check
// 4089.1-4089.30: (11.5): Node.next failed Write-Read Left-Mover Check
// 4156.1-4156.34: (11.5): Node.next failed Read-Write Right-Mover Check
// 4226.1-4226.34: (11.5): Node.next failed Read-Write Left-Mover Check
// 4295.1-4295.34: (19.5): TreiberStack.head failed Write-Write Right-Mover Check
// 4364.1-4364.30: (19.5): TreiberStack.head failed Write-Read Right-Mover Check
// 4437.1-4437.34: (19.5): TreiberStack.head failed Write-Write Left-Mover Check
// 4507.1-4507.30: (19.5): TreiberStack.head failed Write-Read Left-Mover Check
// 4574.1-4574.34: (19.5): TreiberStack.head failed Read-Write Right-Mover Check
// 4644.1-4644.34: (19.5): TreiberStack.head failed Read-Write Left-Mover Check
// 4725.1-4725.140: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 4726.1-4726.101: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 4727.1-4727.158: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 4838.1-4838.140: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 4954.1-4954.144: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 4955.1-4955.144: (10.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 5036.1-5036.136: (10.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 5037.1-5037.136: (10.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 5038.1-5038.146: (10.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 5118.1-5118.136: (10.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 5119.1-5119.136: (10.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 5120.1-5120.99: (10.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 5202.1-5202.140: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 5203.1-5203.101: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 5204.1-5204.158: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 5315.1-5315.140: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 5431.1-5431.144: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 5432.1-5432.144: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 5513.1-5513.136: (10.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 5514.1-5514.136: (10.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 5515.1-5515.146: (10.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 5595.1-5595.136: (11.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 5596.1-5596.136: (11.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 5597.1-5597.99: (11.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 5679.1-5679.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.1)
// 5680.1-5680.101: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.2)
// 5681.1-5681.156: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case A.3)
// 5792.1-5792.140: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case C)
// 5908.1-5908.144: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case D)
// 5909.1-5909.144: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case R)
// 5990.1-5990.136: (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case F)
// 5991.1-5991.136: (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case H)
// 5992.1-5992.144: (10.5): Node.item is not Read-Write Stable with respect to TreiberStack.head (case I)
// 6072.1-6072.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case J)
// 6073.1-6073.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case K)
// 6074.1-6074.99: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.item (case L)
// 6156.1-6156.140: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 6157.1-6157.101: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 6158.1-6158.158: (10.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 6269.1-6269.140: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 6385.1-6385.144: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 6386.1-6386.144: (11.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 6467.1-6467.136: (11.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 6468.1-6468.136: (11.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 6469.1-6469.146: (11.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 6549.1-6549.136: (10.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 6550.1-6550.136: (10.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 6551.1-6551.99: (10.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 6633.1-6633.140: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 6634.1-6634.101: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 6635.1-6635.158: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 6746.1-6746.140: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 6862.1-6862.144: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 6863.1-6863.144: (11.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 6944.1-6944.136: (11.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 6945.1-6945.136: (11.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 6946.1-6946.146: (11.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 7026.1-7026.136: (11.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 7027.1-7027.136: (11.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 7028.1-7028.99: (11.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 7110.1-7110.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.1)
// 7111.1-7111.101: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.2)
// 7112.1-7112.156: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case A.3)
// 7223.1-7223.140: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case C)
// 7339.1-7339.144: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case D)
// 7340.1-7340.144: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case R)
// 7421.1-7421.136: (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case F)
// 7422.1-7422.136: (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case H)
// 7423.1-7423.144: (11.5): Node.next is not Read-Write Stable with respect to TreiberStack.head (case I)
// 7503.1-7503.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case J)
// 7504.1-7504.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case K)
// 7505.1-7505.99: (19.5): TreiberStack.head is not Write-Read Stable with respect to Node.next (case L)
// 7587.1-7587.140: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.1)
// 7588.1-7588.101: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.2)
// 7589.1-7589.156: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case A.3)
// 7700.1-7700.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case C)
// 7816.1-7816.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case D)
// 7817.1-7817.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.item (case R)
// 7898.1-7898.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case F)
// 7899.1-7899.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case H)
// 7900.1-7900.144: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.item (case I)
// 7980.1-7980.136: (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case J)
// 7981.1-7981.136: (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case K)
// 7982.1-7982.99: (10.5): Node.item is not Write-Read Stable with respect to TreiberStack.head (case L)
// 8103.1-8103.142: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case M)
// 8222.1-8222.130: (10.5): Node.item is not Write-Write Stable with respect to TreiberStack.head (case N)
// 8305.1-8305.140: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.1)
// 8306.1-8306.101: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.2)
// 8307.1-8307.156: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case A.3)
// 8418.1-8418.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case C)
// 8534.1-8534.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case D)
// 8535.1-8535.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to Node.next (case R)
// 8616.1-8616.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case F)
// 8617.1-8617.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case H)
// 8618.1-8618.144: (19.5): TreiberStack.head is not Read-Write Stable with respect to Node.next (case I)
// 8698.1-8698.136: (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case J)
// 8699.1-8699.136: (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case K)
// 8700.1-8700.99: (11.5): Node.next is not Write-Read Stable with respect to TreiberStack.head (case L)
// 8821.1-8821.142: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case M)
// 8940.1-8940.130: (11.5): Node.next is not Write-Write Stable with respect to TreiberStack.head (case N)
// 9023.1-9023.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.1)
// 9024.1-9024.101: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.2)
// 9025.1-9025.158: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case A.3)
// 9136.1-9136.140: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case C)
// 9252.1-9252.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case D)
// 9253.1-9253.144: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case R)
// 9334.1-9334.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case F)
// 9335.1-9335.136: (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case H)
// 9336.1-9336.146: (19.5): TreiberStack.head is not Read-Write Stable with respect to TreiberStack.head (case I)
// 9416.1-9416.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case J)
// 9417.1-9417.136: (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case K)
// 9418.1-9418.99: (19.5): TreiberStack.head is not Write-Read Stable with respect to TreiberStack.head (case L)
// 9539.1-9539.142: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case M)
// 9658.1-9658.130: (19.5): TreiberStack.head is not Write-Write Stable with respect to TreiberStack.head (case N)
// 9696.1-9721.2: (10.5): yields_as clause for Node.item is not valid
// 9726.1-9746.2: (10.5): yields_as clause for Node.item is not reflexive
// 9752.1-9792.2: (10.5): yields_as clause for Node.item is not transitive
// 9811.1-9836.2: (11.5): yields_as clause for Node.next is not valid
// 9841.1-9861.2: (11.5): yields_as clause for Node.next is not reflexive
// 9867.1-9907.2: (11.5): yields_as clause for Node.next is not transitive
// 9927.1-9952.2: (7.32): yields_as clause for Node._lock is not valid
// 9957.1-9977.2: (7.32): yields_as clause for Node._lock is not reflexive
// 9983.1-10023.2: (7.32): yields_as clause for Node._lock is not transitive
// 10042.1-10067.2: (19.5): yields_as clause for TreiberStack.head is not valid
// 10072.1-10092.2: (19.5): yields_as clause for TreiberStack.head is not reflexive
// 10098.1-10138.2: (19.5): yields_as clause for TreiberStack.head is not transitive
// 10158.1-10183.2: (7.32): yields_as clause for TreiberStack._lock is not valid
// 10188.1-10208.2: (7.32): yields_as clause for TreiberStack._lock is not reflexive
// 10214.1-10254.2: (7.32): yields_as clause for TreiberStack._lock is not transitive
