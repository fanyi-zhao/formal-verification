                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/parallel-writes-bug.anchor:             
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next this.item < 1073741823                                                             
       ? holds(this.owner, tid) ? B : E                                                             
       : isRead ? B : E                                                                             
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        synchronized (this) {                                                                       
          pred := this.head;                                                                        
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant isShared(pred);                                                               
            invariant pred.item < item;                                                             
            invariant pred.owner == this;                                                           
            invariant curr.owner == this;                                                           
            {                                                                                       
            boolean tmp1;                                                                           
            int tmp2;                                                                               
            tmp2 := curr.item;                                                                      
            tmp1 = tmp2 < item;                                                                     
            if (!tmp1) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp3;                                                                             
          int tmp4;                                                                                 
          tmp4 := curr.item;                                                                        
          tmp3 = item == tmp4;                                                                      
          if (tmp3 /* == item == curr.item */) {                                                    
             return false;                                                                          
          } else {                                                                                  
            Node node;                                                                              
            node = new Node();                                                                      
            node.init(item,this)                                                                    
            node.next := curr;                                                                      
            pred.next := node;                                                                      
             return true;                                                                           
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        synchronized (this) {                                                                       
          pred := this.head;                                                                        
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant isShared(pred);                                                               
            invariant pred.item < item;                                                             
            invariant pred.owner == this;                                                           
            invariant curr.owner == this;                                                           
            {                                                                                       
            boolean tmp5;                                                                           
            int tmp6;                                                                               
            tmp6 := curr.item;                                                                      
            tmp5 = tmp6 < item;                                                                     
            if (!tmp5) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp7;                                                                             
          int tmp8;                                                                                 
          tmp8 := curr.item;                                                                        
          tmp7 = item == tmp8;                                                                      
          if (tmp7 /* == item == curr.item */) {                                                    
            Node tmp9;                                                                              
            tmp9 := curr.next;                                                                      
            pred.next := tmp9;                                                                      
             return true;                                                                           
          } else {                                                                                  
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        synchronized (this) {                                                                       
          Node pred;                                                                                
          pred := this.head;                                                                        
          Node curr;                                                                                
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant curr.owner == this;                                                           
            {                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := curr.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            if (!tmp10) break; else {                                                               
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp12;                                                                            
          int tmp13;                                                                                
          tmp13 := curr.item;                                                                       
          tmp12 = item == tmp13;                                                                    
           return tmp12;                                                                            
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void main() {                                                                          
        List list;                                                                                  
        list = new List();                                                                          
        list.init()                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next this.item < 1073741823                                                             
       ? holds(this.owner, tid) ? B : E                                                             
       : isRead ? B : E                                                                             
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              node.init(item,this)                                                                  
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void main() {                                                                          
        List list;                                                                                  
        list = new List();                                                                          
        list.init()                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next this.item < 1073741823                                                             
       ? holds(this.owner, tid) ? B : E                                                             
       : isRead ? B : E                                                                             
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              {                                                                                     
                inlined node.init(item,this);                                                       
                exit$222: {                                                                         
                  int item$222;                                                                     
                  List owner$222;                                                                   
                  Node this$222;                                                                    
                  item$222 = item;                                                                  
                  owner$222 = this;                                                                 
                  this$222 = node;                                                                  
                  {                                                                                 
                    assume this$222.item == 0;                                                      
                    assume this$222.next == Node.null;                                              
                    assume this$222.owner == List.null;                                             
                    {                                                                               
                      this$222.item := item$222;                                                    
                      this$222.owner := owner$222;                                                  
                      {                                                                             
                        break exit$222;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void main() {                                                                          
        List list;                                                                                  
        list = new List();                                                                          
        {                                                                                           
          inlined list.init();                                                                      
          exit$223: {                                                                               
            List this$223;                                                                          
            this$223 = list;                                                                        
            {                                                                                       
              assume this$223.head == Node.null;                                                    
              {                                                                                     
                Node tail$223;                                                                      
                tail$223 = new Node();                                                              
                {                                                                                   
                  inlined tail$223.init(1073741823,List.null);                                      
                  exit$224: {                                                                       
                    int item$224;                                                                   
                    List owner$224;                                                                 
                    Node this$224;                                                                  
                    item$224 = 1073741823;                                                          
                    owner$224 = List.null;                                                          
                    this$224 = tail$223;                                                            
                    {                                                                               
                      assume this$224.item == 0;                                                    
                      assume this$224.next == Node.null;                                            
                      assume this$224.owner == List.null;                                           
                      {                                                                             
                        this$224.item := item$224;                                                  
                        this$224.owner := owner$224;                                                
                        {                                                                           
                          break exit$224;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                Node head$223;                                                                      
                head$223 = new Node();                                                              
                {                                                                                   
                  inlined head$223.init(-1073741824,List.null);                                     
                  exit$225: {                                                                       
                    int item$225;                                                                   
                    List owner$225;                                                                 
                    Node this$225;                                                                  
                    item$225 = -1073741824;                                                         
                    owner$225 = List.null;                                                          
                    this$225 = head$223;                                                            
                    {                                                                               
                      assume this$225.item == 0;                                                    
                      assume this$225.next == Node.null;                                            
                      assume this$225.owner == List.null;                                           
                      {                                                                             
                        this$225.item := item$225;                                                  
                        this$225.owner := owner$225;                                                
                        {                                                                           
                          break exit$225;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                tail$223.owner := this$223, this$223.head := head$223, head$223.owner := this$223, head$223.next := tail$223;
                {                                                                                   
                  break exit$223;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next this.item < 1073741823                                                             
       ? holds(this.owner, tid) ? B : E                                                             
       : isRead ? B : E                                                                             
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              {                                                                                     
                inlined node.init(item,this);                                                       
                exit$222: {                                                                         
                  int item$222;                                                                     
                  List owner$222;                                                                   
                  Node this$222;                                                                    
                  item$222 = item;                                                                  
                  owner$222 = this;                                                                 
                  this$222 = node;                                                                  
                  {                                                                                 
                    assume this$222.item == 0;                                                      
                    assume this$222.next == Node.null;                                              
                    assume this$222.owner == List.null;                                             
                    {                                                                               
                      this$222.item := item$222;                                                    
                      this$222.owner := owner$222;                                                  
                      {                                                                             
                        break exit$222;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void main() {                                                                          
        List list;                                                                                  
        list = new List();                                                                          
        {                                                                                           
          inlined list.init();                                                                      
          exit$223: {                                                                               
            List this$223;                                                                          
            this$223 = list;                                                                        
            {                                                                                       
              assume this$223.head == Node.null;                                                    
              {                                                                                     
                Node tail$223;                                                                      
                tail$223 = new Node();                                                              
                {                                                                                   
                  inlined tail$223.init(1073741823,List.null);                                      
                  exit$224: {                                                                       
                    int item$224;                                                                   
                    List owner$224;                                                                 
                    Node this$224;                                                                  
                    item$224 = 1073741823;                                                          
                    owner$224 = List.null;                                                          
                    this$224 = tail$223;                                                            
                    {                                                                               
                      assume this$224.item == 0;                                                    
                      assume this$224.next == Node.null;                                            
                      assume this$224.owner == List.null;                                           
                      {                                                                             
                        this$224.item := item$224;                                                  
                        this$224.owner := owner$224;                                                
                        {                                                                           
                          break exit$224;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                Node head$223;                                                                      
                head$223 = new Node();                                                              
                {                                                                                   
                  inlined head$223.init(-1073741824,List.null);                                     
                  exit$225: {                                                                       
                    int item$225;                                                                   
                    List owner$225;                                                                 
                    Node this$225;                                                                  
                    item$225 = -1073741824;                                                         
                    owner$225 = List.null;                                                          
                    this$225 = head$223;                                                            
                    {                                                                               
                      assume this$225.item == 0;                                                    
                      assume this$225.next == Node.null;                                            
                      assume this$225.owner == List.null;                                           
                      {                                                                             
                        this$225.item := item$225;                                                  
                        this$225.owner := owner$225;                                                
                        {                                                                           
                          break exit$225;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                tail$223.owner := this$223, this$223.head := head$223, head$223.owner := this$223, head$223.next := tail$223;
                {                                                                                   
                  break exit$223;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if ((Node.item[this]<1073741823)) then                                                             
  if ((isAccessible(List._state[Node.owner[this]], tid) && List._lock[Node.owner[this]] == tid)) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((Node.item[this]<1073741823)) then                                                             
  if ((isAccessible(List._state[Node.owner[this]], tid) && List._lock[Node.owner[this]] == tid)) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.owner: [Node]List;                                                                         
                                                                                                    
function {:inline} ReadEval.Node.owner(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := List.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.owner(tid: Tid,this : Node,newValue: List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Node.2849981(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 ((Node.next[this]!=Node.null)==>(Node.owner[this]==Node.owner[Node.next[this]]))                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2849989(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (Node.owner[this]!=List.null)                                                                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2850004(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 ((-1073741824<=Node.item[this])&&(Node.item[this]<=1073741823))                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2850021(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 ((Node.next[this]!=Node.null)==>(Node.item[this]<Node.item[Node.next[this]]))                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2850037(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 ((Node.next[this]==Node.null)==>(Node.item[this]==1073741823))                                     
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl List ***/                                                                           
                                                                                                    
type List;                                                                                          
const unique List.null: List;                                                                       
var List._state: [List]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var List.head: [List]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.List.head(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List.head(tid: Tid,this : List,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var List._lock: [List]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.List._lock(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List._lock(tid: Tid,this : List,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.List.2850637(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 ((List.head[this]!=Node.null)&&(Node.item[List.head[this]]==-1073741824))                          
}                                                                                                   
                                                                                                    
function {:inline} Invariant.List.2850644(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (Node.owner[List.head[this]]==this)                                                                
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  List.add(tid:Tid, this : List, item : int)                                               
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (39.5): Bad tid
requires isShared(List._state[this]);                                                                      // (39.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (39.5): Object invariant may not hold.
{                                                                                                   
 var mover2857127: Mover;                                                                           
 var Node._lock2857234: [Node]Tid;                                                                  
 var item$222: int;                                                                                 
 var moverPath2857234: MoverPath;                                                                   
 var item$2222857219: int;                                                                          
 var tid2857252: Tid;                                                                               
 var curr2857155: Node;                                                                             
 var path2857115: int;                                                                              
 var List.head2857166: [List]Node;                                                                  
 var Node.owner2857252: [Node]List;                                                                 
 var Node.item2857237: [Node]int;                                                                   
 var List.head2857146: [List]Node;                                                                  
 var Main._state2857118: [Main]State;                                                               
 var $result2857234: bool;                                                                          
 var $result2857242: bool;                                                                          
 var $result2857166: bool;                                                                          
 var tid2857234: Tid;                                                                               
 var $result2857216: bool;                                                                          
 var item2857146_bottom: int;                                                                       
 var moverPath2857237: MoverPath;                                                                   
 var tmp32857155: bool;                                                                             
 var node2857237: Node;                                                                             
 var tmp32857216: bool;                                                                             
 var pred2857237: Node;                                                                             
 var Main._lock2857166: [Main]Tid;                                                                  
 var $pc2857242: Phase;                                                                             
 var Node._lock2857237: [Node]Tid;                                                                  
 var List._state2857146_bottom: [List]State;                                                        
 var pred2857127: Node;                                                                             
 var pred2857242: Node;                                                                             
 var Node.owner2857118: [Node]List;                                                                 
 var item2857219: int;                                                                              
 var moverPath2857118: MoverPath;                                                                   
 var Node._state2857155: [Node]State;                                                               
 var Main._state2857143: [Main]State;                                                               
 var moverPath2857127: MoverPath;                                                                   
 var $pc2857155: Phase;                                                                             
 var pred2857146_bottom: Node;                                                                      
 var $pc2857146_bottom: Phase;                                                                      
 var Node.owner2857127: [Node]List;                                                                 
 var this2857146: List;                                                                             
 var Node.next2857143: [Node]Node;                                                                  
 var Main._state2857146: [Main]State;                                                               
 var List.head2857115: [List]Node;                                                                  
 var Node.owner2857216: [Node]List;                                                                 
 var node: Node;                                                                                    
 var Node.next2857166: [Node]Node;                                                                  
 var Node._state2857252: [Node]State;                                                               
 var node2857216: Node;                                                                             
 var curr2857216: Node;                                                                             
 var moverPath2857143: MoverPath;                                                                   
 var curr2857146: Node;                                                                             
 var pred2857166: Node;                                                                             
 var Node._lock2857118: [Node]Tid;                                                                  
 var List._state2857216: [List]State;                                                               
 var tid2857155: Tid;                                                                               
 var List._state2857252: [List]State;                                                               
 var tid2857216: Tid;                                                                               
 var curr2857127: Node;                                                                             
 var this$2222857219: Node;                                                                         
 var $recorded.state2857115: int;                                                                   
 var item2857216: int;                                                                              
 var Node._lock2857242: [Node]Tid;                                                                  
 var List._lock2857115: [List]Tid;                                                                  
 var $pc2857146: Phase;                                                                             
 var $result2857252: bool;                                                                          
 var Node.next2857219: [Node]Node;                                                                  
 var tmp22857127: int;                                                                              
 var item2857237: int;                                                                              
 var tid2857115: Tid;                                                                               
 var moverPath2857216: MoverPath;                                                                   
 var tmp1: bool;                                                                                    
 var Main._lock2857237: [Main]Tid;                                                                  
 var tmp22857143: int;                                                                              
 var key2857146_bottom: int;                                                                        
 var item$2222857216: int;                                                                          
 var tmp32857242: bool;                                                                             
 var List._state2857166: [List]State;                                                               
 var tmp42857234: int;                                                                              
 var Node.item2857166: [Node]int;                                                                   
 var List._state2857242: [List]State;                                                               
 var tmp32857234: bool;                                                                             
 var Main._state2857155: [Main]State;                                                               
 var this2857155: List;                                                                             
 var Node.item2857155: [Node]int;                                                                   
 var $pc2857252: Phase;                                                                             
 var List.head2857155: [List]Node;                                                                  
 var Main._state2857146_bottom: [Main]State;                                                        
 var Node._state2857237: [Node]State;                                                               
 var List._lock2857242: [List]Tid;                                                                  
 var key2857155: int;                                                                               
 var tid2857143: Tid;                                                                               
 var this2857216: List;                                                                             
 var tid2857237: Tid;                                                                               
 var this2857118: List;                                                                             
 var mover2857219: Mover;                                                                           
 var Node.owner2857143: [Node]List;                                                                 
 var $recorded.state2857143: int;                                                                   
 var Main._lock2857219: [Main]Tid;                                                                  
 var Node.owner2857237: [Node]List;                                                                 
 var List._state2857155: [List]State;                                                               
 var this2857143: List;                                                                             
 var tmp12857127: bool;                                                                             
 var List._lock2857146_bottom: [List]Tid;                                                           
 var Node._state2857146_bottom: [Node]State;                                                        
 var Node.next2857118: [Node]Node;                                                                  
 var mover2857118: Mover;                                                                           
 var List._state2857219: [List]State;                                                               
 var $pc2857216: Phase;                                                                             
 var owner$2222857219: List;                                                                        
 var key2857237: int;                                                                               
 var $result2857127: bool;                                                                          
 var tid2857219: Tid;                                                                               
 var List._lock2857118: [List]Tid;                                                                  
 var Node.next2857146_bottom: [Node]Node;                                                           
 var Node.next2857155: [Node]Node;                                                                  
 var List._lock2857166: [List]Tid;                                                                  
 var List._lock2857216: [List]Tid;                                                                  
 var List._lock2857237: [List]Tid;                                                                  
 var Node._state2857219: [Node]State;                                                               
 var Node.owner2857155: [Node]List;                                                                 
 var List._state2857143: [List]State;                                                               
 var Main._state2857166: [Main]State;                                                               
 var Node.item2857146: [Node]int;                                                                   
 var phase2857146: Phase;                                                                           
 var $recorded.state2857252: int;                                                                   
 var curr2857242: Node;                                                                             
 var Node.item2857118: [Node]int;                                                                   
 var tmp42857166: int;                                                                              
 var item2857252: int;                                                                              
 var tid2857146: Tid;                                                                               
 var $recorded.state2857146_bottom: int;                                                            
 var tid2857118: Tid;                                                                               
 var Node.owner2857166: [Node]List;                                                                 
 var Node._lock2857155: [Node]Tid;                                                                  
 var List.head2857234: [List]Node;                                                                  
 var $result2857155: bool;                                                                          
 var this2857127: List;                                                                             
 var path2857127: int;                                                                              
 var moverPath2857115: MoverPath;                                                                   
 var $recorded.state2857216: int;                                                                   
 var List.head2857237: [List]Node;                                                                  
 var Node.item2857146_bottom: [Node]int;                                                            
 var Node._state2857118: [Node]State;                                                               
 var Main._lock2857143: [Main]Tid;                                                                  
 var Main._lock2857118: [Main]Tid;                                                                  
 var curr: Node;                                                                                    
 var Main._state2857242: [Main]State;                                                               
 var pred2857146: Node;                                                                             
 var key2857234: int;                                                                               
 var Main._state2857234: [Main]State;                                                               
 var mover2857155: Mover;                                                                           
 var pred2857115: Node;                                                                             
 var Node.owner2857146: [Node]List;                                                                 
 var List.head2857143: [List]Node;                                                                  
 var Main._lock2857146_bottom: [Main]Tid;                                                           
 var key2857166: int;                                                                               
 var tmp42857237: int;                                                                              
 var $result2857237: bool;                                                                          
 var List._lock2857155: [List]Tid;                                                                  
 var List._state2857234: [List]State;                                                               
 var item2857155: int;                                                                              
 var this2857234: List;                                                                             
 var tmp32857237: bool;                                                                             
 var List.head2857219: [List]Node;                                                                  
 var List.head2857118: [List]Node;                                                                  
 var $pc2857237: Phase;                                                                             
 var tmp42857219: int;                                                                              
 var Main._state2857115: [Main]State;                                                               
 var item2857115: int;                                                                              
 var Node.next2857234: [Node]Node;                                                                  
 var key2857143: int;                                                                               
 var Node._lock2857146_bottom: [Node]Tid;                                                           
 var Node.item2857115: [Node]int;                                                                   
 var $recorded.state2857118: int;                                                                   
 var List._state2857118: [List]State;                                                               
 var List.head2857127: [List]Node;                                                                  
 var tid2857127: Tid;                                                                               
 var Node.next2857216: [Node]Node;                                                                  
 var Node.next2857242: [Node]Node;                                                                  
 var $recorded.state2857166: int;                                                                   
 var pred2857234: Node;                                                                             
 var Main._lock2857146: [Main]Tid;                                                                  
 var Node._state2857146: [Node]State;                                                               
 var $result2857143: bool;                                                                          
 var this2857146_bottom: List;                                                                      
 var key2857242: int;                                                                               
 var List._lock2857127: [List]Tid;                                                                  
 var curr2857219: Node;                                                                             
 var $result2857146: bool;                                                                          
 var key: int;                                                                                      
 var Main._lock2857155: [Main]Tid;                                                                  
 var this2857219: List;                                                                             
 var this$222: Node;                                                                                
 var curr2857237: Node;                                                                             
 var item2857127: int;                                                                              
 var $recorded.state2857237: int;                                                                   
 var tmp42857216: int;                                                                              
 var $recorded.state2857234: int;                                                                   
 var Node._state2857242: [Node]State;                                                               
 var mover2857237: Mover;                                                                           
 var path2857143: int;                                                                              
 var mover2857143: Mover;                                                                           
 var key2857219: int;                                                                               
 var curr2857115: Node;                                                                             
 var node2857234: Node;                                                                             
 var this$2222857216: Node;                                                                         
 var tid2857146_bottom: Tid;                                                                        
 var tmp12857143: bool;                                                                             
 var curr2857234: Node;                                                                             
 var Node._lock2857216: [Node]Tid;                                                                  
 var this2857237: List;                                                                             
 var tmp32857219: bool;                                                                             
 var $pc2857219: Phase;                                                                             
 var Node._state2857127: [Node]State;                                                               
 var Node.next2857127: [Node]Node;                                                                  
 var Node._lock2857146: [Node]Tid;                                                                  
 var $pc2857118: Phase;                                                                             
 var Node.item2857127: [Node]int;                                                                   
 var Node._lock2857115: [Node]Tid;                                                                  
 var pred2857118: Node;                                                                             
 var item2857166: int;                                                                              
 var Node.item2857219: [Node]int;                                                                   
 var List._state2857127: [List]State;                                                               
 var $recorded.state2857219: int;                                                                   
 var node2857219: Node;                                                                             
 var List._state2857146: [List]State;                                                               
 var $recorded.state2857242: int;                                                                   
 var Main._lock2857115: [Main]Tid;                                                                  
 var mover2857216: Mover;                                                                           
 var $recorded.state2857127: int;                                                                   
 var Node.next2857252: [Node]Node;                                                                  
 var $recorded.state2857146: int;                                                                   
 var pred2857219: Node;                                                                             
 var path2857118: int;                                                                              
 var path2857216: int;                                                                              
 var mover2857115: Mover;                                                                           
 var this2857115: List;                                                                             
 var this2857242: List;                                                                             
 var tid2857166: Tid;                                                                               
 var owner$2222857216: List;                                                                        
 var node2857242: Node;                                                                             
 var owner$222: List;                                                                               
 var Node._lock2857143: [Node]Tid;                                                                  
 var curr2857166: Node;                                                                             
 var item2857234: int;                                                                              
 var item2857146: int;                                                                              
 var key2857252: int;                                                                               
 var Node._state2857143: [Node]State;                                                               
 var $pc2857166: Phase;                                                                             
 var Main._state2857237: [Main]State;                                                               
 var List.head2857146_bottom: [List]Node;                                                           
 var $result2857146_bottom: bool;                                                                   
 var moverPath2857219: MoverPath;                                                                   
 var List.head2857216: [List]Node;                                                                  
 var List._lock2857234: [List]Tid;                                                                  
 var tmp3: bool;                                                                                    
 var $result2857115: bool;                                                                          
 var pred2857155: Node;                                                                             
 var pred2857252: Node;                                                                             
 var Node._state2857216: [Node]State;                                                               
 var Node.owner2857115: [Node]List;                                                                 
 var Node._lock2857219: [Node]Tid;                                                                  
 var Node.owner2857219: [Node]List;                                                                 
 var path2857234: int;                                                                              
 var Node.owner2857234: [Node]List;                                                                 
 var Node.owner2857146_bottom: [Node]List;                                                          
 var List._lock2857252: [List]Tid;                                                                  
 var Main._state2857216: [Main]State;                                                               
 var path2857237: int;                                                                              
 var Main._lock2857242: [Main]Tid;                                                                  
 var tmp42857242: int;                                                                              
 var Node._lock2857166: [Node]Tid;                                                                  
 var $result2857118: bool;                                                                          
 var Main._state2857219: [Main]State;                                                               
 var Node.item2857242: [Node]int;                                                                   
 var Main._lock2857234: [Main]Tid;                                                                  
 var path2857219: int;                                                                              
 var Node.owner2857242: [Node]List;                                                                 
 var tmp32857166: bool;                                                                             
 var curr2857118: Node;                                                                             
 var path2857155: int;                                                                              
 var curr2857252: Node;                                                                             
 var $pc2857127: Phase;                                                                             
 var List._state2857237: [List]State;                                                               
 var pred: Node;                                                                                    
 var Main._lock2857252: [Main]Tid;                                                                  
 var List._lock2857146: [List]Tid;                                                                  
 var Main._state2857252: [Main]State;                                                               
 var List.head2857252: [List]Node;                                                                  
 var Main._lock2857127: [Main]Tid;                                                                  
 var Node._lock2857252: [Node]Tid;                                                                  
 var Main._lock2857216: [Main]Tid;                                                                  
 var Main._state2857127: [Main]State;                                                               
 var Node._state2857166: [Node]State;                                                               
 var key2857118: int;                                                                               
 var item2857118: int;                                                                              
 var pred2857216: Node;                                                                             
 var curr2857143: Node;                                                                             
 var key2857115: int;                                                                               
 var $result2857219: bool;                                                                          
 var Node.item2857234: [Node]int;                                                                   
 var moverPath2857155: MoverPath;                                                                   
 var Node.next2857115: [Node]Node;                                                                  
 var key2857146: int;                                                                               
 var this2857252: List;                                                                             
 var $pc2857234: Phase;                                                                             
 var tmp2: int;                                                                                     
 var item2857242: int;                                                                              
 var Node._lock2857127: [Node]Tid;                                                                  
 var Node._state2857115: [Node]State;                                                               
 var pred2857143: Node;                                                                             
 var List._state2857115: [List]State;                                                               
 var tmp42857155: int;                                                                              
 var Node.item2857252: [Node]int;                                                                   
 var mover2857234: Mover;                                                                           
 var Node.next2857237: [Node]Node;                                                                  
 var key2857127: int;                                                                               
 var Node.next2857146: [Node]Node;                                                                  
 var tid2857242: Tid;                                                                               
 var key2857216: int;                                                                               
 var Node._state2857234: [Node]State;                                                               
 var Node.item2857143: [Node]int;                                                                   
 var List.head2857242: [List]Node;                                                                  
 var tmp4: int;                                                                                     
 var curr2857146_bottom: Node;                                                                      
 var item2857143: int;                                                                              
 var List._lock2857219: [List]Tid;                                                                  
 var $pc2857143: Phase;                                                                             
 var $pc2857115: Phase;                                                                             
 var $recorded.state2857155: int;                                                                   
 var Node.item2857216: [Node]int;                                                                   
 var List._lock2857143: [List]Tid;                                                                  
 var this2857166: List;                                                                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (39.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 41.9: Node pred;                                                                                
                                                                                                    
                                                                                                    
 // 42.9: Node curr;                                                                                
                                                                                                    
                                                                                                    
 // 43.9: int key;                                                                                  
                                                                                                    
                                                                                                    
 // 43.9: key = item;                                                                               
                                                                                                    
 key := item;                                                                                       
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (44.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (44.22): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 45.13: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857115 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857115 := m#moverPath(moverPath2857115);                                                     
 path2857115 := p#moverPath(moverPath2857115);                                                      
 assume Node._state2857115 == Node._state && Node.item2857115 == Node.item && Node.next2857115 == Node.next && Node.owner2857115 == Node.owner && Node._lock2857115 == Node._lock && List._state2857115 == List._state && List.head2857115 == List.head && List._lock2857115 == List._lock && Main._state2857115 == Main._state && Main._lock2857115 == Main._lock && key2857115 == key && curr2857115 == curr && pred2857115 == pred && $result2857115 == $result && item2857115 == item && this2857115 == this && tid2857115 == tid && $pc2857115 == $pc;
 assume $recorded.state2857115 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (45.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857115);                                                              
 assert $pc != PhaseError;                                                                                 // (45.13): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 46.13: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857118 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857118 := m#moverPath(moverPath2857118);                                                     
 path2857118 := p#moverPath(moverPath2857118);                                                      
 assume Node._state2857118 == Node._state && Node.item2857118 == Node.item && Node.next2857118 == Node.next && Node.owner2857118 == Node.owner && Node._lock2857118 == Node._lock && List._state2857118 == List._state && List.head2857118 == List.head && List._lock2857118 == List._lock && Main._state2857118 == Main._state && Main._lock2857118 == Main._lock && key2857118 == key && curr2857118 == curr && pred2857118 == pred && $result2857118 == $result && item2857118 == item && this2857118 == this && tid2857118 == tid && $pc2857118 == $pc;
 assume $recorded.state2857118 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (46.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857118);                                                              
 assert $pc != PhaseError;                                                                                 // (46.13): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2857146 == Node._state && Node.item2857146 == Node.item && Node.next2857146 == Node.next && Node.owner2857146 == Node.owner && Node._lock2857146 == Node._lock && List._state2857146 == List._state && List.head2857146 == List.head && List._lock2857146 == List._lock && Main._state2857146 == Main._state && Main._lock2857146 == Main._lock && key2857146 == key && curr2857146 == curr && pred2857146 == pred && $result2857146 == $result && item2857146 == item && this2857146 == this && tid2857146 == tid;
 assume $recorded.state2857146 == 1;                                                                
                                                                                                    
 // 48.13: while (true)                                                                             
                                                                                                    
 phase2857146 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (39.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (39.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (48.13): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant isShared(Node._state[pred]);                                                            
  invariant (Node.item[pred]<item);                                                                 
  invariant (Node.owner[pred]==this);                                                               
  invariant (Node.owner[curr]==this);                                                               
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2857146,Node.item2857146,Node.next2857146,Node.owner2857146,Node._lock2857146,List._state2857146,List.head2857146,List._lock2857146,Main._state2857146,Main._lock2857146));       // (48.13): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2857146,Node.item2857146,Node.next2857146,Node.owner2857146,Node._lock2857146,List._state2857146,List.head2857146,List._lock2857146,Main._state2857146,Main._lock2857146));       // (48.13): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2857146,Node.item2857146,Node.next2857146,Node.owner2857146,Node._lock2857146,List._state2857146,List.head2857146,List._lock2857146,Main._state2857146,Main._lock2857146));       // (48.13): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2857146,Node.item2857146,Node.next2857146,Node.owner2857146,Node._lock2857146,List._state2857146,List.head2857146,List._lock2857146,Main._state2857146,Main._lock2857146));       // (48.13): Loop does not preserve yields_as annotation for field head
  invariant phase2857146 == $pc;                                                                           // (48.13): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (48.13): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 48.30: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 48.20: int tmp2;                                                                               
                                                                                                    
                                                                                                    
  // 48.20: tmp2 := curr.item;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857127 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857127 := m#moverPath(moverPath2857127);                                                    
  path2857127 := p#moverPath(moverPath2857127);                                                     
  assume Node._state2857127 == Node._state && Node.item2857127 == Node.item && Node.next2857127 == Node.next && Node.owner2857127 == Node.owner && Node._lock2857127 == Node._lock && List._state2857127 == List._state && List.head2857127 == List.head && List._lock2857127 == List._lock && Main._state2857127 == Main._state && Main._lock2857127 == Main._lock && tmp22857127 == tmp2 && tmp12857127 == tmp1 && key2857127 == key && curr2857127 == curr && pred2857127 == pred && $result2857127 == $result && item2857127 == item && this2857127 == this && tid2857127 == tid && $pc2857127 == $pc;
  assume $recorded.state2857127 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (48.20): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857127);                                                             
  assert $pc != PhaseError;                                                                                // (48.20): Reduction failure
  tmp2 := Node.item[curr];                                                                          
                                                                                                    
  // 48.30: tmp1 = tmp2 < item;                                                                     
                                                                                                    
  tmp1 := (tmp2<item);                                                                              
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 48.13: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 55.17: pred = curr;                                                                            
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 56.17: curr := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857143 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857143 := m#moverPath(moverPath2857143);                                                    
  path2857143 := p#moverPath(moverPath2857143);                                                     
  assume Node._state2857143 == Node._state && Node.item2857143 == Node.item && Node.next2857143 == Node.next && Node.owner2857143 == Node.owner && Node._lock2857143 == Node._lock && List._state2857143 == List._state && List.head2857143 == List.head && List._lock2857143 == List._lock && Main._state2857143 == Main._state && Main._lock2857143 == Main._lock && tmp22857143 == tmp2 && tmp12857143 == tmp1 && key2857143 == key && curr2857143 == curr && pred2857143 == pred && $result2857143 == $result && item2857143 == item && this2857143 == this && tid2857143 == tid && $pc2857143 == $pc;
  assume $recorded.state2857143 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (56.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857143);                                                             
  assert $pc != PhaseError;                                                                                // (56.17): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2857146_bottom == Node._state && Node.item2857146_bottom == Node.item && Node.next2857146_bottom == Node.next && Node.owner2857146_bottom == Node.owner && Node._lock2857146_bottom == Node._lock && List._state2857146_bottom == List._state && List.head2857146_bottom == List.head && List._lock2857146_bottom == List._lock && Main._state2857146_bottom == Main._state && Main._lock2857146_bottom == Main._lock && key2857146_bottom == key && curr2857146_bottom == curr && pred2857146_bottom == pred && $result2857146_bottom == $result && item2857146_bottom == item && this2857146_bottom == this && tid2857146_bottom == tid;
  assume $recorded.state2857146_bottom == 1;                                                        
  assert phase2857146 == $pc;                                                                              // (48.13): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 58.13: boolean tmp3;                                                                            
                                                                                                    
                                                                                                    
 // 58.13: int tmp4;                                                                                
                                                                                                    
                                                                                                    
 // 58.13: tmp4 := curr.item;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857155 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857155 := m#moverPath(moverPath2857155);                                                     
 path2857155 := p#moverPath(moverPath2857155);                                                      
 assume Node._state2857155 == Node._state && Node.item2857155 == Node.item && Node.next2857155 == Node.next && Node.owner2857155 == Node.owner && Node._lock2857155 == Node._lock && List._state2857155 == List._state && List.head2857155 == List.head && List._lock2857155 == List._lock && Main._state2857155 == Main._state && Main._lock2857155 == Main._lock && tmp42857155 == tmp4 && tmp32857155 == tmp3 && key2857155 == key && curr2857155 == curr && pred2857155 == pred && $result2857155 == $result && item2857155 == item && this2857155 == this && tid2857155 == tid && $pc2857155 == $pc;
 assume $recorded.state2857155 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (58.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857155);                                                              
 assert $pc != PhaseError;                                                                                 // (58.13): Reduction failure
 tmp4 := Node.item[curr];                                                                           
                                                                                                    
 // 58.13: tmp3 = item == tmp4;                                                                     
                                                                                                    
 tmp3 := (item==tmp4);                                                                              
 if (tmp3 /* lowered (item==Node.item[curr]) */) {                                                  
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (66.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (66.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (66.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 59.17:  return false;                                                                          
                                                                                                    
  assume Node._state2857166 == Node._state && Node.item2857166 == Node.item && Node.next2857166 == Node.next && Node.owner2857166 == Node.owner && Node._lock2857166 == Node._lock && List._state2857166 == List._state && List.head2857166 == List.head && List._lock2857166 == List._lock && Main._state2857166 == Main._state && Main._lock2857166 == Main._lock && tmp42857166 == tmp4 && tmp32857166 == tmp3 && key2857166 == key && curr2857166 == curr && pred2857166 == pred && $result2857166 == $result && item2857166 == item && this2857166 == this && tid2857166 == tid;
  assume $recorded.state2857166 == 1;                                                               
  $result := false;                                                                                 
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (59.17): Object invariant may not hold.
  return;                                                                                           
 } else {                                                                                           
                                                                                                    
  // 61.17: Node node;                                                                              
                                                                                                    
                                                                                                    
  // 61.17: node = new Node();                                                                      
                                                                                                    
  havoc node;                                                                                       
  assume node != Node.null && isFresh(Node._state[node]);                                           
  Node._state[node] := LOCAL(tid);                                                                  
  assume Node.item[node]  == 0;                                                                     
  assume Node.next[node]  == Node.null;                                                             
  assume Node.owner[node]  == List.null;                                                            
  assume Node._lock[node]  == Tid.null;                                                             
  // inlined: node.init(item,this)}                                                                 
  exit$222_top:                                                                                     
                                                                                                    
  // 61.17: int item$222;                                                                           
                                                                                                    
                                                                                                    
  // 61.17: List owner$222;                                                                         
                                                                                                    
                                                                                                    
  // 61.17: Node this$222;                                                                          
                                                                                                    
                                                                                                    
  // 61.17: item$222 = item;                                                                        
                                                                                                    
  item$222 := item;                                                                                 
                                                                                                    
  // 61.17: owner$222 = this;                                                                       
                                                                                                    
  owner$222 := this;                                                                                
                                                                                                    
  // 61.17: this$222 = node;                                                                        
                                                                                                    
  this$222 := node;                                                                                 
                                                                                                    
  // 19.5: assume this$222.item == 0;                                                               
                                                                                                    
  assume (Node.item[this$222]==0);                                                                  
                                                                                                    
  // 19.5: assume this$222.next == Node.null;                                                       
                                                                                                    
  assume (Node.next[this$222]==Node.null);                                                          
                                                                                                    
  // 19.5: assume this$222.owner == List.null;                                                      
                                                                                                    
  assume (Node.owner[this$222]==List.null);                                                         
                                                                                                    
                                                                                                    
  // 20.7: this$222.item := item$222;                                                               
                                                                                                    
                                                                                                    
  moverPath2857216 := WriteEval.Node.item(tid: Tid,this$222: Node,item$222: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857216 := m#moverPath(moverPath2857216);                                                    
  path2857216 := p#moverPath(moverPath2857216);                                                     
  assume Node._state2857216 == Node._state && Node.item2857216 == Node.item && Node.next2857216 == Node.next && Node.owner2857216 == Node.owner && Node._lock2857216 == Node._lock && List._state2857216 == List._state && List.head2857216 == List.head && List._lock2857216 == List._lock && Main._state2857216 == Main._state && Main._lock2857216 == Main._lock && this$2222857216 == this$222 && owner$2222857216 == owner$222 && item$2222857216 == item$222 && node2857216 == node && tmp42857216 == tmp4 && tmp32857216 == tmp3 && key2857216 == key && curr2857216 == curr && pred2857216 == pred && $result2857216 == $result && item2857216 == item && this2857216 == this && tid2857216 == tid && $pc2857216 == $pc;
  assume $recorded.state2857216 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$222 != Node.null;                                                                    
  } else {                                                                                          
   assert this$222 != Node.null;                                                                           // (20.7): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2857216);                                                             
  assert $pc != PhaseError;                                                                                // (20.7): Reduction failure
  Node.item[this$222] := item$222;                                                                  
                                                                                                    
                                                                                                    
  // 21.7: this$222.owner := owner$222;                                                             
                                                                                                    
                                                                                                    
  moverPath2857219 := WriteEval.Node.owner(tid: Tid,this$222: Node,owner$222: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857219 := m#moverPath(moverPath2857219);                                                    
  path2857219 := p#moverPath(moverPath2857219);                                                     
  assume Node._state2857219 == Node._state && Node.item2857219 == Node.item && Node.next2857219 == Node.next && Node.owner2857219 == Node.owner && Node._lock2857219 == Node._lock && List._state2857219 == List._state && List.head2857219 == List.head && List._lock2857219 == List._lock && Main._state2857219 == Main._state && Main._lock2857219 == Main._lock && this$2222857219 == this$222 && owner$2222857219 == owner$222 && item$2222857219 == item$222 && node2857219 == node && tmp42857219 == tmp4 && tmp32857219 == tmp3 && key2857219 == key && curr2857219 == curr && pred2857219 == pred && $result2857219 == $result && item2857219 == item && this2857219 == this && tid2857219 == tid && $pc2857219 == $pc;
  assume $recorded.state2857219 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$222 != Node.null;                                                                    
  } else {                                                                                          
   assert this$222 != Node.null;                                                                           // (21.7): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2857219);                                                             
  assert $pc != PhaseError;                                                                                // (21.7): Reduction failure
  Node.owner[this$222] := owner$222;                                                                
  if (isLocal(List._state[owner$222], tid)) {                                                       
   List._state[owner$222] := SHARED();                                                              
   assert isSharedAssignable(Node._state[List.head[owner$222]]);                                           // (21.7): owner$222 became shared, but owner$222.head may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 19.32: break exit$222;                                                                         
                                                                                                    
  goto exit$222_bottom;                                                                             
  exit$222_bottom:                                                                                  
                                                                                                    
                                                                                                    
  // 62.17: node.next := curr;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857234 := WriteEval.Node.next(tid: Tid,node: Node,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857234 := m#moverPath(moverPath2857234);                                                    
  path2857234 := p#moverPath(moverPath2857234);                                                     
  assume Node._state2857234 == Node._state && Node.item2857234 == Node.item && Node.next2857234 == Node.next && Node.owner2857234 == Node.owner && Node._lock2857234 == Node._lock && List._state2857234 == List._state && List.head2857234 == List.head && List._lock2857234 == List._lock && Main._state2857234 == Main._state && Main._lock2857234 == Main._lock && node2857234 == node && tmp42857234 == tmp4 && tmp32857234 == tmp3 && key2857234 == key && curr2857234 == curr && pred2857234 == pred && $result2857234 == $result && item2857234 == item && this2857234 == this && tid2857234 == tid && $pc2857234 == $pc;
  assume $recorded.state2857234 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume node != Node.null;                                                                        
  } else {                                                                                          
   assert node != Node.null;                                                                               // (62.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2857234);                                                             
  assert $pc != PhaseError;                                                                                // (62.17): Reduction failure
  Node.next[node] := curr;                                                                          
  if (isLocal(Node._state[curr], tid)) {                                                            
   Node._state[curr] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[curr]]);                                                // (62.17): curr became shared, but curr.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[curr]]);                                               // (62.17): curr became shared, but curr.owner may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
                                                                                                    
  // 63.17: pred.next := node;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857237 := WriteEval.Node.next(tid: Tid,pred: Node,node: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857237 := m#moverPath(moverPath2857237);                                                    
  path2857237 := p#moverPath(moverPath2857237);                                                     
  assume Node._state2857237 == Node._state && Node.item2857237 == Node.item && Node.next2857237 == Node.next && Node.owner2857237 == Node.owner && Node._lock2857237 == Node._lock && List._state2857237 == List._state && List.head2857237 == List.head && List._lock2857237 == List._lock && Main._state2857237 == Main._state && Main._lock2857237 == Main._lock && node2857237 == node && tmp42857237 == tmp4 && tmp32857237 == tmp3 && key2857237 == key && curr2857237 == curr && pred2857237 == pred && $result2857237 == $result && item2857237 == item && this2857237 == this && tid2857237 == tid && $pc2857237 == $pc;
  assume $recorded.state2857237 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (63.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2857237);                                                             
  assert $pc != PhaseError;                                                                                // (63.17): Reduction failure
  Node.next[pred] := node;                                                                          
  if (isLocal(Node._state[node], tid)) {                                                            
   Node._state[node] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[node]]);                                                // (63.17): node became shared, but node.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[node]]);                                               // (63.17): node became shared, but node.owner may not be shared.
  }                                                                                                 
                                                                                                    
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (66.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (66.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (66.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 64.17:  return true;                                                                           
                                                                                                    
  assume Node._state2857242 == Node._state && Node.item2857242 == Node.item && Node.next2857242 == Node.next && Node.owner2857242 == Node.owner && Node._lock2857242 == Node._lock && List._state2857242 == List._state && List.head2857242 == List.head && List._lock2857242 == List._lock && Main._state2857242 == Main._state && Main._lock2857242 == Main._lock && node2857242 == node && tmp42857242 == tmp4 && tmp32857242 == tmp3 && key2857242 == key && curr2857242 == curr && pred2857242 == pred && $result2857242 == $result && item2857242 == item && this2857242 == this && tid2857242 == tid;
  assume $recorded.state2857242 == 1;                                                               
  $result := true;                                                                                  
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (64.17): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (66.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (66.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (66.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 40.34: // return false;                                                                         
                                                                                                    
 assume Node._state2857252 == Node._state && Node.item2857252 == Node.item && Node.next2857252 == Node.next && Node.owner2857252 == Node.owner && Node._lock2857252 == Node._lock && List._state2857252 == List._state && List.head2857252 == List.head && List._lock2857252 == List._lock && Main._state2857252 == Main._state && Main._lock2857252 == Main._lock && key2857252 == key && curr2857252 == curr && pred2857252 == pred && $result2857252 == $result && item2857252 == item && this2857252 == this && tid2857252 == tid;
 assume $recorded.state2857252 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (40.34): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  List.remove(tid:Tid, this : List, item : int)                                            
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (69.5): Bad tid
requires isShared(List._state[this]);                                                                      // (69.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (69.5): Object invariant may not hold.
{                                                                                                   
 var curr2857297: Node;                                                                             
 var List._lock2857306: [List]Tid;                                                                  
 var this2857297_bottom: List;                                                                      
 var Main._lock2857294: [Main]Tid;                                                                  
 var $pc2857266: Phase;                                                                             
 var mover2857306: Mover;                                                                           
 var tmp52857278: bool;                                                                             
 var List._lock2857297_bottom: [List]Tid;                                                           
 var moverPath2857294: MoverPath;                                                                   
 var Node.item2857321: [Node]int;                                                                   
 var pred2857297: Node;                                                                             
 var List._lock2857266: [List]Tid;                                                                  
 var this2857269: List;                                                                             
 var List._lock2857333: [List]Tid;                                                                  
 var tmp52857294: bool;                                                                             
 var Main._state2857343: [Main]State;                                                               
 var Node.owner2857318: [Node]List;                                                                 
 var List.head2857266: [List]Node;                                                                  
 var $recorded.state2857266: int;                                                                   
 var tid2857321: Tid;                                                                               
 var Main._state2857318: [Main]State;                                                               
 var List.head2857333: [List]Node;                                                                  
 var List._state2857297: [List]State;                                                               
 var curr2857297_bottom: Node;                                                                      
 var tmp72857318: bool;                                                                             
 var List._lock2857326: [List]Tid;                                                                  
 var tmp82857326: int;                                                                              
 var tmp92857318: Node;                                                                             
 var Node.item2857297_bottom: [Node]int;                                                            
 var $pc2857333: Phase;                                                                             
 var Main._lock2857326: [Main]Tid;                                                                  
 var List.head2857278: [List]Node;                                                                  
 var tmp82857318: int;                                                                              
 var tmp5: bool;                                                                                    
 var this2857294: List;                                                                             
 var Node._lock2857297_bottom: [Node]Tid;                                                           
 var List._lock2857297: [List]Tid;                                                                  
 var $result2857278: bool;                                                                          
 var pred2857343: Node;                                                                             
 var List.head2857321: [List]Node;                                                                  
 var Node.item2857266: [Node]int;                                                                   
 var $result2857321: bool;                                                                          
 var curr2857321: Node;                                                                             
 var Node.owner2857321: [Node]List;                                                                 
 var Node._state2857278: [Node]State;                                                               
 var pred2857318: Node;                                                                             
 var Node._state2857269: [Node]State;                                                               
 var this2857306: List;                                                                             
 var List._lock2857321: [List]Tid;                                                                  
 var Node.item2857343: [Node]int;                                                                   
 var this2857278: List;                                                                             
 var tmp8: int;                                                                                     
 var tid2857266: Tid;                                                                               
 var Node.next2857269: [Node]Node;                                                                  
 var mover2857294: Mover;                                                                           
 var Main._lock2857297_bottom: [Main]Tid;                                                           
 var Main._lock2857343: [Main]Tid;                                                                  
 var List._state2857297_bottom: [List]State;                                                        
 var Node.owner2857278: [Node]List;                                                                 
 var curr2857269: Node;                                                                             
 var item2857294: int;                                                                              
 var moverPath2857306: MoverPath;                                                                   
 var Node.next2857306: [Node]Node;                                                                  
 var pred2857326: Node;                                                                             
 var moverPath2857266: MoverPath;                                                                   
 var mover2857278: Mover;                                                                           
 var tmp82857306: int;                                                                              
 var Main._state2857297_bottom: [Main]State;                                                        
 var Node.next2857343: [Node]Node;                                                                  
 var List._state2857333: [List]State;                                                               
 var $recorded.state2857278: int;                                                                   
 var List._lock2857318: [List]Tid;                                                                  
 var $recorded.state2857333: int;                                                                   
 var pred2857321: Node;                                                                             
 var Main._state2857297: [Main]State;                                                               
 var this2857266: List;                                                                             
 var List._state2857318: [List]State;                                                               
 var Node._state2857343: [Node]State;                                                               
 var Node._lock2857333: [Node]Tid;                                                                  
 var path2857266: int;                                                                              
 var this2857321: List;                                                                             
 var Node._state2857266: [Node]State;                                                               
 var moverPath2857321: MoverPath;                                                                   
 var tmp72857333: bool;                                                                             
 var $result2857297_bottom: bool;                                                                   
 var item2857321: int;                                                                              
 var $pc2857269: Phase;                                                                             
 var Node.item2857306: [Node]int;                                                                   
 var Node.owner2857297: [Node]List;                                                                 
 var $recorded.state2857297: int;                                                                   
 var Node._lock2857343: [Node]Tid;                                                                  
 var Node.item2857278: [Node]int;                                                                   
 var mover2857269: Mover;                                                                           
 var tid2857294: Tid;                                                                               
 var tid2857306: Tid;                                                                               
 var Node.owner2857333: [Node]List;                                                                 
 var item2857266: int;                                                                              
 var Node.next2857318: [Node]Node;                                                                  
 var tid2857269: Tid;                                                                               
 var Main._lock2857269: [Main]Tid;                                                                  
 var this2857318: List;                                                                             
 var $recorded.state2857306: int;                                                                   
 var curr: Node;                                                                                    
 var mover2857321: Mover;                                                                           
 var this2857297: List;                                                                             
 var this2857333: List;                                                                             
 var List._state2857321: [List]State;                                                               
 var $recorded.state2857294: int;                                                                   
 var List._lock2857294: [List]Tid;                                                                  
 var curr2857278: Node;                                                                             
 var Main._state2857278: [Main]State;                                                               
 var tmp9: Node;                                                                                    
 var Node.owner2857297_bottom: [Node]List;                                                          
 var moverPath2857278: MoverPath;                                                                   
 var $recorded.state2857326: int;                                                                   
 var Main._lock2857278: [Main]Tid;                                                                  
 var item2857326: int;                                                                              
 var tmp72857306: bool;                                                                             
 var path2857294: int;                                                                              
 var item2857297: int;                                                                              
 var item2857343: int;                                                                              
 var tmp62857294: int;                                                                              
 var Node._lock2857297: [Node]Tid;                                                                  
 var List._lock2857269: [List]Tid;                                                                  
 var mover2857266: Mover;                                                                           
 var List._state2857343: [List]State;                                                               
 var $recorded.state2857269: int;                                                                   
 var Main._state2857321: [Main]State;                                                               
 var Main._state2857266: [Main]State;                                                               
 var Node.owner2857343: [Node]List;                                                                 
 var tmp92857326: Node;                                                                             
 var tid2857333: Tid;                                                                               
 var $result2857343: bool;                                                                          
 var Node.owner2857306: [Node]List;                                                                 
 var $recorded.state2857321: int;                                                                   
 var pred2857278: Node;                                                                             
 var Main._state2857269: [Main]State;                                                               
 var Node.owner2857294: [Node]List;                                                                 
 var path2857269: int;                                                                              
 var List._state2857266: [List]State;                                                               
 var $result2857333: bool;                                                                          
 var Node._lock2857266: [Node]Tid;                                                                  
 var tmp72857326: bool;                                                                             
 var curr2857333: Node;                                                                             
 var Node._state2857321: [Node]State;                                                               
 var tid2857297_bottom: Tid;                                                                        
 var $result2857306: bool;                                                                          
 var Node.next2857297: [Node]Node;                                                                  
 var Node.next2857278: [Node]Node;                                                                  
 var Node._lock2857318: [Node]Tid;                                                                  
 var List.head2857294: [List]Node;                                                                  
 var curr2857326: Node;                                                                             
 var List._lock2857278: [List]Tid;                                                                  
 var List._lock2857343: [List]Tid;                                                                  
 var Main._lock2857333: [Main]Tid;                                                                  
 var $recorded.state2857343: int;                                                                   
 var tmp92857321: Node;                                                                             
 var moverPath2857318: MoverPath;                                                                   
 var tmp7: bool;                                                                                    
 var Node._lock2857294: [Node]Tid;                                                                  
 var $pc2857318: Phase;                                                                             
 var $result2857318: bool;                                                                          
 var Node.item2857269: [Node]int;                                                                   
 var Node.item2857333: [Node]int;                                                                   
 var path2857321: int;                                                                              
 var $pc2857306: Phase;                                                                             
 var List._state2857306: [List]State;                                                               
 var Node._state2857297_bottom: [Node]State;                                                        
 var path2857306: int;                                                                              
 var Node.item2857318: [Node]int;                                                                   
 var Main._state2857294: [Main]State;                                                               
 var $pc2857278: Phase;                                                                             
 var Node.item2857297: [Node]int;                                                                   
 var tmp82857321: int;                                                                              
 var Main._state2857333: [Main]State;                                                               
 var List._state2857269: [List]State;                                                               
 var curr2857266: Node;                                                                             
 var List.head2857343: [List]Node;                                                                  
 var path2857318: int;                                                                              
 var $pc2857343: Phase;                                                                             
 var $pc2857297_bottom: Phase;                                                                      
 var $result2857326: bool;                                                                          
 var this2857343: List;                                                                             
 var curr2857306: Node;                                                                             
 var Node._state2857306: [Node]State;                                                               
 var $result2857266: bool;                                                                          
 var $pc2857321: Phase;                                                                             
 var List.head2857269: [List]Node;                                                                  
 var List.head2857318: [List]Node;                                                                  
 var List.head2857326: [List]Node;                                                                  
 var item2857318: int;                                                                              
 var item2857297_bottom: int;                                                                       
 var Node._lock2857306: [Node]Tid;                                                                  
 var Main._lock2857266: [Main]Tid;                                                                  
 var Node.next2857326: [Node]Node;                                                                  
 var Node.owner2857269: [Node]List;                                                                 
 var Main._state2857306: [Main]State;                                                               
 var moverPath2857269: MoverPath;                                                                   
 var pred2857294: Node;                                                                             
 var List.head2857306: [List]Node;                                                                  
 var Node.item2857294: [Node]int;                                                                   
 var Main._state2857326: [Main]State;                                                               
 var tid2857318: Tid;                                                                               
 var pred2857297_bottom: Node;                                                                      
 var $pc2857297: Phase;                                                                             
 var pred2857306: Node;                                                                             
 var phase2857297: Phase;                                                                           
 var $recorded.state2857297_bottom: int;                                                            
 var tid2857297: Tid;                                                                               
 var $recorded.state2857318: int;                                                                   
 var tmp72857321: bool;                                                                             
 var List._state2857326: [List]State;                                                               
 var $pc2857326: Phase;                                                                             
 var Node._state2857318: [Node]State;                                                               
 var List._state2857278: [List]State;                                                               
 var pred: Node;                                                                                    
 var curr2857343: Node;                                                                             
 var pred2857266: Node;                                                                             
 var Node.next2857266: [Node]Node;                                                                  
 var item2857278: int;                                                                              
 var Node.next2857294: [Node]Node;                                                                  
 var Node._lock2857269: [Node]Tid;                                                                  
 var this2857326: List;                                                                             
 var item2857306: int;                                                                              
 var item2857333: int;                                                                              
 var path2857278: int;                                                                              
 var Node._state2857297: [Node]State;                                                               
 var Main._lock2857321: [Main]Tid;                                                                  
 var $pc2857294: Phase;                                                                             
 var Node.owner2857326: [Node]List;                                                                 
 var tid2857278: Tid;                                                                               
 var Node._state2857326: [Node]State;                                                               
 var Node.next2857297_bottom: [Node]Node;                                                           
 var Node._lock2857321: [Node]Tid;                                                                  
 var Node._state2857333: [Node]State;                                                               
 var Node.item2857326: [Node]int;                                                                   
 var pred2857333: Node;                                                                             
 var item2857269: int;                                                                              
 var List.head2857297: [List]Node;                                                                  
 var Main._lock2857306: [Main]Tid;                                                                  
 var Node._lock2857326: [Node]Tid;                                                                  
 var curr2857294: Node;                                                                             
 var Main._lock2857297: [Main]Tid;                                                                  
 var curr2857318: Node;                                                                             
 var Node._lock2857278: [Node]Tid;                                                                  
 var Node.owner2857266: [Node]List;                                                                 
 var Node._state2857294: [Node]State;                                                               
 var $result2857297: bool;                                                                          
 var tid2857326: Tid;                                                                               
 var $result2857269: bool;                                                                          
 var pred2857269: Node;                                                                             
 var Node.next2857333: [Node]Node;                                                                  
 var $result2857294: bool;                                                                          
 var List._state2857294: [List]State;                                                               
 var tmp6: int;                                                                                     
 var tmp82857333: int;                                                                              
 var Main._lock2857318: [Main]Tid;                                                                  
 var tmp62857278: int;                                                                              
 var tid2857343: Tid;                                                                               
 var mover2857318: Mover;                                                                           
 var List.head2857297_bottom: [List]Node;                                                           
 var Node.next2857321: [Node]Node;                                                                  
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (69.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 71.9: Node pred;                                                                                
                                                                                                    
                                                                                                    
 // 72.9: Node curr;                                                                                
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (73.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (73.22): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 74.13: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857266 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857266 := m#moverPath(moverPath2857266);                                                     
 path2857266 := p#moverPath(moverPath2857266);                                                      
 assume Node._state2857266 == Node._state && Node.item2857266 == Node.item && Node.next2857266 == Node.next && Node.owner2857266 == Node.owner && Node._lock2857266 == Node._lock && List._state2857266 == List._state && List.head2857266 == List.head && List._lock2857266 == List._lock && Main._state2857266 == Main._state && Main._lock2857266 == Main._lock && curr2857266 == curr && pred2857266 == pred && $result2857266 == $result && item2857266 == item && this2857266 == this && tid2857266 == tid && $pc2857266 == $pc;
 assume $recorded.state2857266 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (74.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857266);                                                              
 assert $pc != PhaseError;                                                                                 // (74.13): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 75.13: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857269 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857269 := m#moverPath(moverPath2857269);                                                     
 path2857269 := p#moverPath(moverPath2857269);                                                      
 assume Node._state2857269 == Node._state && Node.item2857269 == Node.item && Node.next2857269 == Node.next && Node.owner2857269 == Node.owner && Node._lock2857269 == Node._lock && List._state2857269 == List._state && List.head2857269 == List.head && List._lock2857269 == List._lock && Main._state2857269 == Main._state && Main._lock2857269 == Main._lock && curr2857269 == curr && pred2857269 == pred && $result2857269 == $result && item2857269 == item && this2857269 == this && tid2857269 == tid && $pc2857269 == $pc;
 assume $recorded.state2857269 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (75.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857269);                                                              
 assert $pc != PhaseError;                                                                                 // (75.13): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2857297 == Node._state && Node.item2857297 == Node.item && Node.next2857297 == Node.next && Node.owner2857297 == Node.owner && Node._lock2857297 == Node._lock && List._state2857297 == List._state && List.head2857297 == List.head && List._lock2857297 == List._lock && Main._state2857297 == Main._state && Main._lock2857297 == Main._lock && curr2857297 == curr && pred2857297 == pred && $result2857297 == $result && item2857297 == item && this2857297 == this && tid2857297 == tid;
 assume $recorded.state2857297 == 1;                                                                
                                                                                                    
 // 77.13: while (true)                                                                             
                                                                                                    
 phase2857297 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (69.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (69.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (77.13): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant isShared(Node._state[pred]);                                                            
  invariant (Node.item[pred]<item);                                                                 
  invariant (Node.owner[pred]==this);                                                               
  invariant (Node.owner[curr]==this);                                                               
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2857297,Node.item2857297,Node.next2857297,Node.owner2857297,Node._lock2857297,List._state2857297,List.head2857297,List._lock2857297,Main._state2857297,Main._lock2857297));       // (77.13): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2857297,Node.item2857297,Node.next2857297,Node.owner2857297,Node._lock2857297,List._state2857297,List.head2857297,List._lock2857297,Main._state2857297,Main._lock2857297));       // (77.13): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2857297,Node.item2857297,Node.next2857297,Node.owner2857297,Node._lock2857297,List._state2857297,List.head2857297,List._lock2857297,Main._state2857297,Main._lock2857297));       // (77.13): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2857297,Node.item2857297,Node.next2857297,Node.owner2857297,Node._lock2857297,List._state2857297,List.head2857297,List._lock2857297,Main._state2857297,Main._lock2857297));       // (77.13): Loop does not preserve yields_as annotation for field head
  invariant phase2857297 == $pc;                                                                           // (77.13): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (77.13): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 77.30: boolean tmp5;                                                                           
                                                                                                    
                                                                                                    
  // 77.20: int tmp6;                                                                               
                                                                                                    
                                                                                                    
  // 77.20: tmp6 := curr.item;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857278 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857278 := m#moverPath(moverPath2857278);                                                    
  path2857278 := p#moverPath(moverPath2857278);                                                     
  assume Node._state2857278 == Node._state && Node.item2857278 == Node.item && Node.next2857278 == Node.next && Node.owner2857278 == Node.owner && Node._lock2857278 == Node._lock && List._state2857278 == List._state && List.head2857278 == List.head && List._lock2857278 == List._lock && Main._state2857278 == Main._state && Main._lock2857278 == Main._lock && tmp62857278 == tmp6 && tmp52857278 == tmp5 && curr2857278 == curr && pred2857278 == pred && $result2857278 == $result && item2857278 == item && this2857278 == this && tid2857278 == tid && $pc2857278 == $pc;
  assume $recorded.state2857278 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (77.20): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857278);                                                             
  assert $pc != PhaseError;                                                                                // (77.20): Reduction failure
  tmp6 := Node.item[curr];                                                                          
                                                                                                    
  // 77.30: tmp5 = tmp6 < item;                                                                     
                                                                                                    
  tmp5 := (tmp6<item);                                                                              
  if (!(tmp5)) {                                                                                    
                                                                                                    
   // 77.13: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 84.17: pred = curr;                                                                            
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 85.17: curr := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857294 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857294 := m#moverPath(moverPath2857294);                                                    
  path2857294 := p#moverPath(moverPath2857294);                                                     
  assume Node._state2857294 == Node._state && Node.item2857294 == Node.item && Node.next2857294 == Node.next && Node.owner2857294 == Node.owner && Node._lock2857294 == Node._lock && List._state2857294 == List._state && List.head2857294 == List.head && List._lock2857294 == List._lock && Main._state2857294 == Main._state && Main._lock2857294 == Main._lock && tmp62857294 == tmp6 && tmp52857294 == tmp5 && curr2857294 == curr && pred2857294 == pred && $result2857294 == $result && item2857294 == item && this2857294 == this && tid2857294 == tid && $pc2857294 == $pc;
  assume $recorded.state2857294 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (85.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857294);                                                             
  assert $pc != PhaseError;                                                                                // (85.17): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2857297_bottom == Node._state && Node.item2857297_bottom == Node.item && Node.next2857297_bottom == Node.next && Node.owner2857297_bottom == Node.owner && Node._lock2857297_bottom == Node._lock && List._state2857297_bottom == List._state && List.head2857297_bottom == List.head && List._lock2857297_bottom == List._lock && Main._state2857297_bottom == Main._state && Main._lock2857297_bottom == Main._lock && curr2857297_bottom == curr && pred2857297_bottom == pred && $result2857297_bottom == $result && item2857297_bottom == item && this2857297_bottom == this && tid2857297_bottom == tid;
  assume $recorded.state2857297_bottom == 1;                                                        
  assert phase2857297 == $pc;                                                                              // (77.13): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 87.13: boolean tmp7;                                                                            
                                                                                                    
                                                                                                    
 // 87.13: int tmp8;                                                                                
                                                                                                    
                                                                                                    
 // 87.13: tmp8 := curr.item;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857306 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857306 := m#moverPath(moverPath2857306);                                                     
 path2857306 := p#moverPath(moverPath2857306);                                                      
 assume Node._state2857306 == Node._state && Node.item2857306 == Node.item && Node.next2857306 == Node.next && Node.owner2857306 == Node.owner && Node._lock2857306 == Node._lock && List._state2857306 == List._state && List.head2857306 == List.head && List._lock2857306 == List._lock && Main._state2857306 == Main._state && Main._lock2857306 == Main._lock && tmp82857306 == tmp8 && tmp72857306 == tmp7 && curr2857306 == curr && pred2857306 == pred && $result2857306 == $result && item2857306 == item && this2857306 == this && tid2857306 == tid && $pc2857306 == $pc;
 assume $recorded.state2857306 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (87.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857306);                                                              
 assert $pc != PhaseError;                                                                                 // (87.13): Reduction failure
 tmp8 := Node.item[curr];                                                                           
                                                                                                    
 // 87.13: tmp7 = item == tmp8;                                                                     
                                                                                                    
 tmp7 := (item==tmp8);                                                                              
 if (tmp7 /* lowered (item==Node.item[curr]) */) {                                                  
                                                                                                    
  // 88.15: Node tmp9;                                                                              
                                                                                                    
                                                                                                    
  // 88.15: tmp9 := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857318 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857318 := m#moverPath(moverPath2857318);                                                    
  path2857318 := p#moverPath(moverPath2857318);                                                     
  assume Node._state2857318 == Node._state && Node.item2857318 == Node.item && Node.next2857318 == Node.next && Node.owner2857318 == Node.owner && Node._lock2857318 == Node._lock && List._state2857318 == List._state && List.head2857318 == List.head && List._lock2857318 == List._lock && Main._state2857318 == Main._state && Main._lock2857318 == Main._lock && tmp92857318 == tmp9 && tmp82857318 == tmp8 && tmp72857318 == tmp7 && curr2857318 == curr && pred2857318 == pred && $result2857318 == $result && item2857318 == item && this2857318 == this && tid2857318 == tid && $pc2857318 == $pc;
  assume $recorded.state2857318 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (88.15): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857318);                                                             
  assert $pc != PhaseError;                                                                                // (88.15): Reduction failure
  tmp9 := Node.next[curr];                                                                          
                                                                                                    
                                                                                                    
  // 88.15: pred.next := tmp9;                                                                      
                                                                                                    
                                                                                                    
  moverPath2857321 := WriteEval.Node.next(tid: Tid,pred: Node,tmp9: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857321 := m#moverPath(moverPath2857321);                                                    
  path2857321 := p#moverPath(moverPath2857321);                                                     
  assume Node._state2857321 == Node._state && Node.item2857321 == Node.item && Node.next2857321 == Node.next && Node.owner2857321 == Node.owner && Node._lock2857321 == Node._lock && List._state2857321 == List._state && List.head2857321 == List.head && List._lock2857321 == List._lock && Main._state2857321 == Main._state && Main._lock2857321 == Main._lock && tmp92857321 == tmp9 && tmp82857321 == tmp8 && tmp72857321 == tmp7 && curr2857321 == curr && pred2857321 == pred && $result2857321 == $result && item2857321 == item && this2857321 == this && tid2857321 == tid && $pc2857321 == $pc;
  assume $recorded.state2857321 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (88.15): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2857321);                                                             
  assert $pc != PhaseError;                                                                                // (88.15): Reduction failure
  Node.next[pred] := tmp9;                                                                          
  if (isLocal(Node._state[tmp9], tid)) {                                                            
   Node._state[tmp9] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[tmp9]]);                                                // (88.15): tmp9 became shared, but tmp9.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[tmp9]]);                                               // (88.15): tmp9 became shared, but tmp9.owner may not be shared.
  }                                                                                                 
                                                                                                    
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (93.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (93.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (93.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 89.15:  return true;                                                                           
                                                                                                    
  assume Node._state2857326 == Node._state && Node.item2857326 == Node.item && Node.next2857326 == Node.next && Node.owner2857326 == Node.owner && Node._lock2857326 == Node._lock && List._state2857326 == List._state && List.head2857326 == List.head && List._lock2857326 == List._lock && Main._state2857326 == Main._state && Main._lock2857326 == Main._lock && tmp92857326 == tmp9 && tmp82857326 == tmp8 && tmp72857326 == tmp7 && curr2857326 == curr && pred2857326 == pred && $result2857326 == $result && item2857326 == item && this2857326 == this && tid2857326 == tid;
  assume $recorded.state2857326 == 1;                                                               
  $result := true;                                                                                  
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (89.15): Object invariant may not hold.
  return;                                                                                           
 } else {                                                                                           
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (93.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (93.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (93.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 91.15:  return false;                                                                          
                                                                                                    
  assume Node._state2857333 == Node._state && Node.item2857333 == Node.item && Node.next2857333 == Node.next && Node.owner2857333 == Node.owner && Node._lock2857333 == Node._lock && List._state2857333 == List._state && List.head2857333 == List.head && List._lock2857333 == List._lock && Main._state2857333 == Main._state && Main._lock2857333 == Main._lock && tmp82857333 == tmp8 && tmp72857333 == tmp7 && curr2857333 == curr && pred2857333 == pred && $result2857333 == $result && item2857333 == item && this2857333 == this && tid2857333 == tid;
  assume $recorded.state2857333 == 1;                                                               
  $result := false;                                                                                 
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (91.15): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (93.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (93.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (93.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 70.37: // return false;                                                                         
                                                                                                    
 assume Node._state2857343 == Node._state && Node.item2857343 == Node.item && Node.next2857343 == Node.next && Node.owner2857343 == Node.owner && Node._lock2857343 == Node._lock && List._state2857343 == List._state && List.head2857343 == List.head && List._lock2857343 == List._lock && Main._state2857343 == Main._state && Main._lock2857343 == Main._lock && curr2857343 == curr && pred2857343 == pred && $result2857343 == $result && item2857343 == item && this2857343 == this && tid2857343 == tid;
 assume $recorded.state2857343 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (70.37): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  List.contains(tid:Tid, this : List, item : int)                                          
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (97.5): Bad tid
requires isShared(List._state[this]);                                                                      // (97.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (97.5): Object invariant may not hold.
{                                                                                                   
 var $recorded.state2857360: int;                                                                   
 var tid2857369: Tid;                                                                               
 var $pc2857407: Phase;                                                                             
 var Node.item2857407: [Node]int;                                                                   
 var moverPath2857354: MoverPath;                                                                   
 var $result2857354: bool;                                                                          
 var Main._lock2857369: [Main]Tid;                                                                  
 var Node._state2857360: [Node]State;                                                               
 var item2857385: int;                                                                              
 var List._lock2857388_bottom: [List]Tid;                                                           
 var Node.next2857407: [Node]Node;                                                                  
 var pred2857388_bottom: Node;                                                                      
 var Node._state2857369: [Node]State;                                                               
 var $pc2857354: Phase;                                                                             
 var List._lock2857397: [List]Tid;                                                                  
 var Main._state2857388_bottom: [Main]State;                                                        
 var moverPath2857369: MoverPath;                                                                   
 var $pc2857360: Phase;                                                                             
 var moverPath2857385: MoverPath;                                                                   
 var List._lock2857388: [List]Tid;                                                                  
 var Node.next2857388: [Node]Node;                                                                  
 var curr2857369: Node;                                                                             
 var List._lock2857385: [List]Tid;                                                                  
 var $pc2857397: Phase;                                                                             
 var mover2857397: Mover;                                                                           
 var Node._lock2857397: [Node]Tid;                                                                  
 var Node.item2857388_bottom: [Node]int;                                                            
 var tid2857388_bottom: Tid;                                                                        
 var path2857354: int;                                                                              
 var $result2857369: bool;                                                                          
 var pred2857385: Node;                                                                             
 var Node.item2857360: [Node]int;                                                                   
 var Node._lock2857369: [Node]Tid;                                                                  
 var Node.item2857354: [Node]int;                                                                   
 var item2857397: int;                                                                              
 var Node._lock2857385: [Node]Tid;                                                                  
 var curr2857360: Node;                                                                             
 var Node._lock2857354: [Node]Tid;                                                                  
 var $pc2857388_bottom: Phase;                                                                      
 var $recorded.state2857407: int;                                                                   
 var tmp122857397: bool;                                                                            
 var path2857360: int;                                                                              
 var curr2857397: Node;                                                                             
 var List._state2857397: [List]State;                                                               
 var tid2857354: Tid;                                                                               
 var List._state2857385: [List]State;                                                               
 var this2857415: List;                                                                             
 var Node._state2857415: [Node]State;                                                               
 var List._state2857415: [List]State;                                                               
 var Node._state2857397: [Node]State;                                                               
 var List.head2857397: [List]Node;                                                                  
 var curr2857388_bottom: Node;                                                                      
 var tid2857407: Tid;                                                                               
 var Node.owner2857369: [Node]List;                                                                 
 var Node._state2857388_bottom: [Node]State;                                                        
 var List.head2857415: [List]Node;                                                                  
 var Node.owner2857354: [Node]List;                                                                 
 var $result2857407: bool;                                                                          
 var Main._lock2857397: [Main]Tid;                                                                  
 var $result2857385: bool;                                                                          
 var mover2857385: Mover;                                                                           
 var Node.item2857385: [Node]int;                                                                   
 var List._state2857388: [List]State;                                                               
 var Node._lock2857407: [Node]Tid;                                                                  
 var this2857397: List;                                                                             
 var $recorded.state2857397: int;                                                                   
 var phase2857388: Phase;                                                                           
 var Node._lock2857360: [Node]Tid;                                                                  
 var path2857369: int;                                                                              
 var Node.owner2857388: [Node]List;                                                                 
 var curr: Node;                                                                                    
 var Main._lock2857415: [Main]Tid;                                                                  
 var mover2857360: Mover;                                                                           
 var this2857388_bottom: List;                                                                      
 var Main._state2857385: [Main]State;                                                               
 var Node.owner2857360: [Node]List;                                                                 
 var $recorded.state2857415: int;                                                                   
 var Main._lock2857354: [Main]Tid;                                                                  
 var tmp11: int;                                                                                    
 var $recorded.state2857388_bottom: int;                                                            
 var $result2857415: bool;                                                                          
 var tid2857397: Tid;                                                                               
 var Node.next2857369: [Node]Node;                                                                  
 var tmp112857385: int;                                                                             
 var item2857388_bottom: int;                                                                       
 var tmp122857407: bool;                                                                            
 var this2857385: List;                                                                             
 var Main._state2857415: [Main]State;                                                               
 var curr2857407: Node;                                                                             
 var Node.next2857415: [Node]Node;                                                                  
 var $pc2857369: Phase;                                                                             
 var Main._state2857388: [Main]State;                                                               
 var $recorded.state2857388: int;                                                                   
 var path2857397: int;                                                                              
 var item2857415: int;                                                                              
 var tmp132857407: int;                                                                             
 var tmp10: bool;                                                                                   
 var Node.item2857397: [Node]int;                                                                   
 var tmp12: bool;                                                                                   
 var item2857360: int;                                                                              
 var $recorded.state2857369: int;                                                                   
 var Node.item2857415: [Node]int;                                                                   
 var List._state2857388_bottom: [List]State;                                                        
 var this2857360: List;                                                                             
 var tid2857388: Tid;                                                                               
 var tmp13: int;                                                                                    
 var Node._lock2857388_bottom: [Node]Tid;                                                           
 var tmp102857385: bool;                                                                            
 var List._lock2857369: [List]Tid;                                                                  
 var Node._state2857388: [Node]State;                                                               
 var Node.next2857354: [Node]Node;                                                                  
 var Node._state2857385: [Node]State;                                                               
 var List.head2857360: [List]Node;                                                                  
 var Node.owner2857388_bottom: [Node]List;                                                          
 var Node.next2857388_bottom: [Node]Node;                                                           
 var List._state2857354: [List]State;                                                               
 var item2857388: int;                                                                              
 var pred2857354: Node;                                                                             
 var Main._lock2857407: [Main]Tid;                                                                  
 var pred2857369: Node;                                                                             
 var $recorded.state2857354: int;                                                                   
 var List.head2857354: [List]Node;                                                                  
 var Main._lock2857385: [Main]Tid;                                                                  
 var List.head2857369: [List]Node;                                                                  
 var tid2857385: Tid;                                                                               
 var List._state2857407: [List]State;                                                               
 var Node._state2857407: [Node]State;                                                               
 var this2857354: List;                                                                             
 var $pc2857388: Phase;                                                                             
 var $result2857397: bool;                                                                          
 var $recorded.state2857385: int;                                                                   
 var List.head2857388_bottom: [List]Node;                                                           
 var mover2857369: Mover;                                                                           
 var pred2857407: Node;                                                                             
 var curr2857388: Node;                                                                             
 var this2857369: List;                                                                             
 var Main._lock2857360: [Main]Tid;                                                                  
 var List._lock2857407: [List]Tid;                                                                  
 var this2857388: List;                                                                             
 var moverPath2857397: MoverPath;                                                                   
 var List._lock2857415: [List]Tid;                                                                  
 var List._lock2857360: [List]Tid;                                                                  
 var pred2857388: Node;                                                                             
 var tmp132857397: int;                                                                             
 var curr2857385: Node;                                                                             
 var List._state2857360: [List]State;                                                               
 var Main._state2857369: [Main]State;                                                               
 var Node.next2857360: [Node]Node;                                                                  
 var Node.owner2857385: [Node]List;                                                                 
 var Main._state2857360: [Main]State;                                                               
 var Main._lock2857388_bottom: [Main]Tid;                                                           
 var Main._state2857354: [Main]State;                                                               
 var item2857369: int;                                                                              
 var Main._state2857407: [Main]State;                                                               
 var pred2857397: Node;                                                                             
 var Node.item2857388: [Node]int;                                                                   
 var Node._lock2857388: [Node]Tid;                                                                  
 var List.head2857407: [List]Node;                                                                  
 var pred: Node;                                                                                    
 var Main._lock2857388: [Main]Tid;                                                                  
 var $pc2857385: Phase;                                                                             
 var pred2857360: Node;                                                                             
 var Node._state2857354: [Node]State;                                                               
 var path2857385: int;                                                                              
 var this2857407: List;                                                                             
 var List._state2857369: [List]State;                                                               
 var $result2857360: bool;                                                                          
 var mover2857354: Mover;                                                                           
 var Node.next2857385: [Node]Node;                                                                  
 var $pc2857415: Phase;                                                                             
 var List.head2857385: [List]Node;                                                                  
 var List.head2857388: [List]Node;                                                                  
 var tmp112857369: int;                                                                             
 var Node.owner2857397: [Node]List;                                                                 
 var item2857354: int;                                                                              
 var moverPath2857360: MoverPath;                                                                   
 var Node.owner2857415: [Node]List;                                                                 
 var tid2857415: Tid;                                                                               
 var item2857407: int;                                                                              
 var Node._lock2857415: [Node]Tid;                                                                  
 var Node.next2857397: [Node]Node;                                                                  
 var $result2857388: bool;                                                                          
 var Node.owner2857407: [Node]List;                                                                 
 var Node.item2857369: [Node]int;                                                                   
 var tid2857360: Tid;                                                                               
 var Main._state2857397: [Main]State;                                                               
 var List._lock2857354: [List]Tid;                                                                  
 var tmp102857369: bool;                                                                            
 var $result2857388_bottom: bool;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (97.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (99.19): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (99.19): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 100.8: Node pred;                                                                               
                                                                                                    
                                                                                                    
 // 100.8: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857354 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857354 := m#moverPath(moverPath2857354);                                                     
 path2857354 := p#moverPath(moverPath2857354);                                                      
 assume Node._state2857354 == Node._state && Node.item2857354 == Node.item && Node.next2857354 == Node.next && Node.owner2857354 == Node.owner && Node._lock2857354 == Node._lock && List._state2857354 == List._state && List.head2857354 == List.head && List._lock2857354 == List._lock && Main._state2857354 == Main._state && Main._lock2857354 == Main._lock && pred2857354 == pred && $result2857354 == $result && item2857354 == item && this2857354 == this && tid2857354 == tid && $pc2857354 == $pc;
 assume $recorded.state2857354 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (100.8): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857354);                                                              
 assert $pc != PhaseError;                                                                                 // (100.8): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 101.8: Node curr;                                                                               
                                                                                                    
                                                                                                    
 // 101.8: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
 moverPath2857360 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857360 := m#moverPath(moverPath2857360);                                                     
 path2857360 := p#moverPath(moverPath2857360);                                                      
 assume Node._state2857360 == Node._state && Node.item2857360 == Node.item && Node.next2857360 == Node.next && Node.owner2857360 == Node.owner && Node._lock2857360 == Node._lock && List._state2857360 == List._state && List.head2857360 == List.head && List._lock2857360 == List._lock && Main._state2857360 == Main._state && Main._lock2857360 == Main._lock && curr2857360 == curr && pred2857360 == pred && $result2857360 == $result && item2857360 == item && this2857360 == this && tid2857360 == tid && $pc2857360 == $pc;
 assume $recorded.state2857360 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (101.8): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857360);                                                              
 assert $pc != PhaseError;                                                                                 // (101.8): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2857388 == Node._state && Node.item2857388 == Node.item && Node.next2857388 == Node.next && Node.owner2857388 == Node.owner && Node._lock2857388 == Node._lock && List._state2857388 == List._state && List.head2857388 == List.head && List._lock2857388 == List._lock && Main._state2857388 == Main._state && Main._lock2857388 == Main._lock && curr2857388 == curr && pred2857388 == pred && $result2857388 == $result && item2857388 == item && this2857388 == this && tid2857388 == tid;
 assume $recorded.state2857388 == 1;                                                                
                                                                                                    
 // 102.8: while (true)                                                                             
                                                                                                    
 phase2857388 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (97.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (97.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (102.8): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant (Node.owner[curr]==this);                                                               
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2857388,Node.item2857388,Node.next2857388,Node.owner2857388,Node._lock2857388,List._state2857388,List.head2857388,List._lock2857388,Main._state2857388,Main._lock2857388));       // (102.8): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2857388,Node.item2857388,Node.next2857388,Node.owner2857388,Node._lock2857388,List._state2857388,List.head2857388,List._lock2857388,Main._state2857388,Main._lock2857388));       // (102.8): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2857388,Node.item2857388,Node.next2857388,Node.owner2857388,Node._lock2857388,List._state2857388,List.head2857388,List._lock2857388,Main._state2857388,Main._lock2857388));       // (102.8): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2857388,Node.item2857388,Node.next2857388,Node.owner2857388,Node._lock2857388,List._state2857388,List.head2857388,List._lock2857388,Main._state2857388,Main._lock2857388));       // (102.8): Loop does not preserve yields_as annotation for field head
  invariant phase2857388 == $pc;                                                                           // (102.8): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (102.8): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 102.25: boolean tmp10;                                                                         
                                                                                                    
                                                                                                    
  // 102.15: int tmp11;                                                                             
                                                                                                    
                                                                                                    
  // 102.15: tmp11 := curr.item;                                                                    
                                                                                                    
                                                                                                    
  moverPath2857369 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857369 := m#moverPath(moverPath2857369);                                                    
  path2857369 := p#moverPath(moverPath2857369);                                                     
  assume Node._state2857369 == Node._state && Node.item2857369 == Node.item && Node.next2857369 == Node.next && Node.owner2857369 == Node.owner && Node._lock2857369 == Node._lock && List._state2857369 == List._state && List.head2857369 == List.head && List._lock2857369 == List._lock && Main._state2857369 == Main._state && Main._lock2857369 == Main._lock && tmp112857369 == tmp11 && tmp102857369 == tmp10 && curr2857369 == curr && pred2857369 == pred && $result2857369 == $result && item2857369 == item && this2857369 == this && tid2857369 == tid && $pc2857369 == $pc;
  assume $recorded.state2857369 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (102.15): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857369);                                                             
  assert $pc != PhaseError;                                                                                // (102.15): Reduction failure
  tmp11 := Node.item[curr];                                                                         
                                                                                                    
  // 102.25: tmp10 = tmp11 < item;                                                                  
                                                                                                    
  tmp10 := (tmp11<item);                                                                            
  if (!(tmp10)) {                                                                                   
                                                                                                    
   // 102.8: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 106.10: pred = curr;                                                                           
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 107.10: curr := curr.next;                                                                     
                                                                                                    
                                                                                                    
  moverPath2857385 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
  mover2857385 := m#moverPath(moverPath2857385);                                                    
  path2857385 := p#moverPath(moverPath2857385);                                                     
  assume Node._state2857385 == Node._state && Node.item2857385 == Node.item && Node.next2857385 == Node.next && Node.owner2857385 == Node.owner && Node._lock2857385 == Node._lock && List._state2857385 == List._state && List.head2857385 == List.head && List._lock2857385 == List._lock && Main._state2857385 == Main._state && Main._lock2857385 == Main._lock && tmp112857385 == tmp11 && tmp102857385 == tmp10 && curr2857385 == curr && pred2857385 == pred && $result2857385 == $result && item2857385 == item && this2857385 == this && tid2857385 == tid && $pc2857385 == $pc;
  assume $recorded.state2857385 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (107.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2857385);                                                             
  assert $pc != PhaseError;                                                                                // (107.10): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2857388_bottom == Node._state && Node.item2857388_bottom == Node.item && Node.next2857388_bottom == Node.next && Node.owner2857388_bottom == Node.owner && Node._lock2857388_bottom == Node._lock && List._state2857388_bottom == List._state && List.head2857388_bottom == List.head && List._lock2857388_bottom == List._lock && Main._state2857388_bottom == Main._state && Main._lock2857388_bottom == Main._lock && curr2857388_bottom == curr && pred2857388_bottom == pred && $result2857388_bottom == $result && item2857388_bottom == item && this2857388_bottom == this && tid2857388_bottom == tid;
  assume $recorded.state2857388_bottom == 1;                                                        
  assert phase2857388 == $pc;                                                                              // (102.8): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 109.8: boolean tmp12;                                                                           
                                                                                                    
                                                                                                    
 // 109.8: int tmp13;                                                                               
                                                                                                    
                                                                                                    
 // 109.8: tmp13 := curr.item;                                                                      
                                                                                                    
                                                                                                    
 moverPath2857397 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857397 := m#moverPath(moverPath2857397);                                                     
 path2857397 := p#moverPath(moverPath2857397);                                                      
 assume Node._state2857397 == Node._state && Node.item2857397 == Node.item && Node.next2857397 == Node.next && Node.owner2857397 == Node.owner && Node._lock2857397 == Node._lock && List._state2857397 == List._state && List.head2857397 == List.head && List._lock2857397 == List._lock && Main._state2857397 == Main._state && Main._lock2857397 == Main._lock && tmp132857397 == tmp13 && tmp122857397 == tmp12 && curr2857397 == curr && pred2857397 == pred && $result2857397 == $result && item2857397 == item && this2857397 == this && tid2857397 == tid && $pc2857397 == $pc;
 assume $recorded.state2857397 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (109.8): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857397);                                                              
 assert $pc != PhaseError;                                                                                 // (109.8): Reduction failure
 tmp13 := Node.item[curr];                                                                          
                                                                                                    
 // 109.8: tmp12 = item == tmp13;                                                                   
                                                                                                    
 tmp12 := (item==tmp13);                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (110.6): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (110.6): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (110.6): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 109.8:  return tmp12;                                                                           
                                                                                                    
 assume Node._state2857407 == Node._state && Node.item2857407 == Node.item && Node.next2857407 == Node.next && Node.owner2857407 == Node.owner && Node._lock2857407 == Node._lock && List._state2857407 == List._state && List.head2857407 == List.head && List._lock2857407 == List._lock && Main._state2857407 == Main._state && Main._lock2857407 == Main._lock && tmp132857407 == tmp13 && tmp122857407 == tmp12 && curr2857407 == curr && pred2857407 == pred && $result2857407 == $result && item2857407 == item && this2857407 == this && tid2857407 == tid;
 assume $recorded.state2857407 == 1;                                                                
 $result := tmp12;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (109.8): Object invariant may not hold.
 return;                                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (110.6): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (110.6): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (110.6): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 98.39: // return false;                                                                         
                                                                                                    
 assume Node._state2857415 == Node._state && Node.item2857415 == Node.item && Node.next2857415 == Node.next && Node.owner2857415 == Node.owner && Node._lock2857415 == Node._lock && List._state2857415 == List._state && List.head2857415 == List.head && List._lock2857415 == List._lock && Main._state2857415 == Main._state && Main._lock2857415 == Main._lock && $result2857415 == $result && item2857415 == item && this2857415 == this && tid2857415 == tid;
 assume $recorded.state2857415 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (98.39): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Main ***/                                                                           
                                                                                                    
type Main;                                                                                          
const unique Main.null: Main;                                                                       
var Main._state: [Main]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Main._lock: [Main]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Main._lock(tid: Tid,this : Main,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Main._lock(tid: Tid,this : Main,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Main.main(tid:Tid, this : Main)                                                          
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (115.3): Bad tid
requires isShared(Main._state[this]);                                                                      // (115.3): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.3): Object invariant may not hold.
{                                                                                                   
 var tid2857573: Tid;                                                                               
 var $pc2857603: Phase;                                                                             
 var path2857600: int;                                                                              
 var Main._lock2857600: [Main]Tid;                                                                  
 var List._state2857594: [List]State;                                                               
 var Node._state2857500: [Node]State;                                                               
 var head$2232857594: Node;                                                                         
 var List.head2857573: [List]Node;                                                                  
 var head$2232857603: Node;                                                                         
 var tid2857600: Tid;                                                                               
 var list2857603: List;                                                                             
 var Node.owner2857576: [Node]List;                                                                 
 var moverPath2857573: MoverPath;                                                                   
 var this$2252857573: Node;                                                                         
 var this2857615: Main;                                                                             
 var Node.item2857600: [Node]int;                                                                   
 var Node._state2857594: [Node]State;                                                               
 var owner$2242857503: List;                                                                        
 var head$2232857600: Node;                                                                         
 var Node._lock2857594: [Node]Tid;                                                                  
 var tid2857615: Tid;                                                                               
 var path2857594: int;                                                                              
 var List.head2857594: [List]Node;                                                                  
 var moverPath2857594: MoverPath;                                                                   
 var List._lock2857576: [List]Tid;                                                                  
 var this2857594: Main;                                                                             
 var Node.owner2857615: [Node]List;                                                                 
 var tail$2232857603: Node;                                                                         
 var Node._state2857576: [Node]State;                                                               
 var Main._lock2857597: [Main]Tid;                                                                  
 var owner$2252857573: List;                                                                        
 var Node._state2857503: [Node]State;                                                               
 var this2857573: Main;                                                                             
 var $pc2857573: Phase;                                                                             
 var Node.item2857615: [Node]int;                                                                   
 var this$2242857503: Node;                                                                         
 var this2857597: Main;                                                                             
 var Main._lock2857573: [Main]Tid;                                                                  
 var List._state2857500: [List]State;                                                               
 var Main._state2857500: [Main]State;                                                               
 var mover2857503: Mover;                                                                           
 var path2857500: int;                                                                              
 var path2857597: int;                                                                              
 var moverPath2857600: MoverPath;                                                                   
 var this$2252857576: Node;                                                                         
 var Node._lock2857573: [Node]Tid;                                                                  
 var $recorded.state2857503: int;                                                                   
 var this2857500: Main;                                                                             
 var path2857603: int;                                                                              
 var Main._lock2857594: [Main]Tid;                                                                  
 var list2857594: List;                                                                             
 var List._lock2857603: [List]Tid;                                                                  
 var Node._lock2857576: [Node]Tid;                                                                  
 var $pc2857597: Phase;                                                                             
 var this$2232857594: List;                                                                         
 var list2857576: List;                                                                             
 var Main._lock2857615: [Main]Tid;                                                                  
 var tail$2232857500: Node;                                                                         
 var List.head2857603: [List]Node;                                                                  
 var tid2857576: Tid;                                                                               
 var Node.next2857594: [Node]Node;                                                                  
 var tail$2232857597: Node;                                                                         
 var Main._lock2857576: [Main]Tid;                                                                  
 var mover2857594: Mover;                                                                           
 var $recorded.state2857603: int;                                                                   
 var tid2857594: Tid;                                                                               
 var Node._state2857615: [Node]State;                                                               
 var Node.item2857576: [Node]int;                                                                   
 var item$2252857573: int;                                                                          
 var $recorded.state2857594: int;                                                                   
 var Node._state2857603: [Node]State;                                                               
 var List._lock2857573: [List]Tid;                                                                  
 var List.head2857597: [List]Node;                                                                  
 var Main._state2857615: [Main]State;                                                               
 var Node._state2857597: [Node]State;                                                               
 var this2857503: Main;                                                                             
 var head$2232857573: Node;                                                                         
 var List._state2857600: [List]State;                                                               
 var tail$2232857600: Node;                                                                         
 var mover2857573: Mover;                                                                           
 var item$224: int;                                                                                 
 var Node.next2857573: [Node]Node;                                                                  
 var item$2252857576: int;                                                                          
 var head$2232857597: Node;                                                                         
 var Node.owner2857503: [Node]List;                                                                 
 var Node._state2857573: [Node]State;                                                               
 var Node.item2857503: [Node]int;                                                                   
 var list2857600: List;                                                                             
 var this2857603: Main;                                                                             
 var Main._lock2857503: [Main]Tid;                                                                  
 var Node._state2857600: [Node]State;                                                               
 var this$2232857573: List;                                                                         
 var $recorded.state2857500: int;                                                                   
 var Main._state2857573: [Main]State;                                                               
 var tid2857500: Tid;                                                                               
 var list2857597: List;                                                                             
 var owner$2242857500: List;                                                                        
 var moverPath2857597: MoverPath;                                                                   
 var tail$2232857503: Node;                                                                         
 var path2857503: int;                                                                              
 var this$223: List;                                                                                
 var item$2242857503: int;                                                                          
 var mover2857600: Mover;                                                                           
 var path2857576: int;                                                                              
 var item$225: int;                                                                                 
 var Node.item2857573: [Node]int;                                                                   
 var $pc2857600: Phase;                                                                             
 var this$2242857500: Node;                                                                         
 var tid2857503: Tid;                                                                               
 var Node.owner2857603: [Node]List;                                                                 
 var path2857573: int;                                                                              
 var Main._lock2857500: [Main]Tid;                                                                  
 var Node._lock2857600: [Node]Tid;                                                                  
 var Node.item2857500: [Node]int;                                                                   
 var this$2232857603: List;                                                                         
 var tid2857603: Tid;                                                                               
 var moverPath2857603: MoverPath;                                                                   
 var Node.next2857600: [Node]Node;                                                                  
 var this$2232857600: List;                                                                         
 var this2857600: Main;                                                                             
 var $recorded.state2857576: int;                                                                   
 var this$225: Node;                                                                                
 var mover2857597: Mover;                                                                           
 var list2857615: List;                                                                             
 var List.head2857600: [List]Node;                                                                  
 var Main._state2857597: [Main]State;                                                               
 var Node._lock2857597: [Node]Tid;                                                                  
 var this$2232857576: List;                                                                         
 var $pc2857615: Phase;                                                                             
 var Node.next2857603: [Node]Node;                                                                  
 var Node._lock2857615: [Node]Tid;                                                                  
 var owner$224: List;                                                                               
 var List._state2857597: [List]State;                                                               
 var List._state2857603: [List]State;                                                               
 var List._state2857615: [List]State;                                                               
 var Node.item2857594: [Node]int;                                                                   
 var tail$2232857573: Node;                                                                         
 var head$2232857576: Node;                                                                         
 var Main._state2857603: [Main]State;                                                               
 var moverPath2857576: MoverPath;                                                                   
 var List.head2857500: [List]Node;                                                                  
 var List._state2857503: [List]State;                                                               
 var List._lock2857503: [List]Tid;                                                                  
 var $recorded.state2857573: int;                                                                   
 var Node.item2857603: [Node]int;                                                                   
 var List._lock2857594: [List]Tid;                                                                  
 var List._lock2857500: [List]Tid;                                                                  
 var Node.owner2857594: [Node]List;                                                                 
 var $pc2857500: Phase;                                                                             
 var Node.next2857576: [Node]Node;                                                                  
 var this$2232857597: List;                                                                         
 var List._state2857573: [List]State;                                                               
 var owner$2252857576: List;                                                                        
 var mover2857603: Mover;                                                                           
 var Node.owner2857600: [Node]List;                                                                 
 var Main._lock2857603: [Main]Tid;                                                                  
 var owner$225: List;                                                                               
 var Node.next2857503: [Node]Node;                                                                  
 var Main._state2857503: [Main]State;                                                               
 var this$2232857503: List;                                                                         
 var tail$2232857594: Node;                                                                         
 var list2857500: List;                                                                             
 var List._lock2857597: [List]Tid;                                                                  
 var Node.owner2857573: [Node]List;                                                                 
 var $recorded.state2857615: int;                                                                   
 var Main._state2857594: [Main]State;                                                               
 var Node.owner2857597: [Node]List;                                                                 
 var item$2242857500: int;                                                                          
 var Node._lock2857500: [Node]Tid;                                                                  
 var list: List;                                                                                    
 var List._lock2857600: [List]Tid;                                                                  
 var $recorded.state2857600: int;                                                                   
 var List._state2857576: [List]State;                                                               
 var List.head2857576: [List]Node;                                                                  
 var $pc2857576: Phase;                                                                             
 var tail$2232857576: Node;                                                                         
 var moverPath2857500: MoverPath;                                                                   
 var Node.item2857597: [Node]int;                                                                   
 var Node.next2857597: [Node]Node;                                                                  
 var this$224: Node;                                                                                
 var head$223: Node;                                                                                
 var Main._state2857576: [Main]State;                                                               
 var Node.next2857500: [Node]Node;                                                                  
 var this2857576: Main;                                                                             
 var Main._state2857600: [Main]State;                                                               
 var $pc2857594: Phase;                                                                             
 var Node.next2857615: [Node]Node;                                                                  
 var list2857503: List;                                                                             
 var $recorded.state2857597: int;                                                                   
 var Node._lock2857503: [Node]Tid;                                                                  
 var list2857573: List;                                                                             
 var mover2857500: Mover;                                                                           
 var Node.owner2857500: [Node]List;                                                                 
 var mover2857576: Mover;                                                                           
 var $pc2857503: Phase;                                                                             
 var tid2857597: Tid;                                                                               
 var Node._lock2857603: [Node]Tid;                                                                  
 var List._lock2857615: [List]Tid;                                                                  
 var this$2232857500: List;                                                                         
 var moverPath2857503: MoverPath;                                                                   
 var List.head2857503: [List]Node;                                                                  
 var List.head2857615: [List]Node;                                                                  
 var tail$223: Node;                                                                                
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 116.5: List list;                                                                               
                                                                                                    
                                                                                                    
 // 116.5: list = new List();                                                                       
                                                                                                    
 havoc list;                                                                                        
 assume list != List.null && isFresh(List._state[list]);                                            
 List._state[list] := LOCAL(tid);                                                                   
 assume List.head[list]  == Node.null;                                                              
 assume List._lock[list]  == Tid.null;                                                              
 // inlined: list.init()}                                                                           
 exit$223_top:                                                                                      
                                                                                                    
 // 116.5: List this$223;                                                                           
                                                                                                    
                                                                                                    
 // 116.5: this$223 = list;                                                                         
                                                                                                    
 this$223 := list;                                                                                  
                                                                                                    
 // 33.5: assume this$223.head == Node.null;                                                        
                                                                                                    
 assume (List.head[this$223]==Node.null);                                                           
                                                                                                    
 // 34.7: Node tail$223;                                                                            
                                                                                                    
                                                                                                    
 // 34.7: tail$223 = new Node();                                                                    
                                                                                                    
 havoc tail$223;                                                                                    
 assume tail$223 != Node.null && isFresh(Node._state[tail$223]);                                    
 Node._state[tail$223] := LOCAL(tid);                                                               
 assume Node.item[tail$223]  == 0;                                                                  
 assume Node.next[tail$223]  == Node.null;                                                          
 assume Node.owner[tail$223]  == List.null;                                                         
 assume Node._lock[tail$223]  == Tid.null;                                                          
 // inlined: tail$223.init(1073741823,List.null)}                                                   
 exit$224_top:                                                                                      
                                                                                                    
 // 34.7: int item$224;                                                                             
                                                                                                    
                                                                                                    
 // 34.7: List owner$224;                                                                           
                                                                                                    
                                                                                                    
 // 34.7: Node this$224;                                                                            
                                                                                                    
                                                                                                    
 // 34.7: item$224 = 1073741823;                                                                    
                                                                                                    
 item$224 := 1073741823;                                                                            
                                                                                                    
 // 34.7: owner$224 = List.null;                                                                    
                                                                                                    
 owner$224 := List.null;                                                                            
                                                                                                    
 // 34.7: this$224 = tail$223;                                                                      
                                                                                                    
 this$224 := tail$223;                                                                              
                                                                                                    
 // 19.5: assume this$224.item == 0;                                                                
                                                                                                    
 assume (Node.item[this$224]==0);                                                                   
                                                                                                    
 // 19.5: assume this$224.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$224]==Node.null);                                                           
                                                                                                    
 // 19.5: assume this$224.owner == List.null;                                                       
                                                                                                    
 assume (Node.owner[this$224]==List.null);                                                          
                                                                                                    
                                                                                                    
 // 20.7: this$224.item := item$224;                                                                
                                                                                                    
                                                                                                    
 moverPath2857500 := WriteEval.Node.item(tid: Tid,this$224: Node,item$224: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857500 := m#moverPath(moverPath2857500);                                                     
 path2857500 := p#moverPath(moverPath2857500);                                                      
 assume Node._state2857500 == Node._state && Node.item2857500 == Node.item && Node.next2857500 == Node.next && Node.owner2857500 == Node.owner && Node._lock2857500 == Node._lock && List._state2857500 == List._state && List.head2857500 == List.head && List._lock2857500 == List._lock && Main._state2857500 == Main._state && Main._lock2857500 == Main._lock && this$2242857500 == this$224 && owner$2242857500 == owner$224 && item$2242857500 == item$224 && tail$2232857500 == tail$223 && this$2232857500 == this$223 && list2857500 == list && this2857500 == this && tid2857500 == tid && $pc2857500 == $pc;
 assume $recorded.state2857500 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$224 != Node.null;                                                                     
 } else {                                                                                           
  assert this$224 != Node.null;                                                                            // (20.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2857500);                                                              
 assert $pc != PhaseError;                                                                                 // (20.7): Reduction failure
 Node.item[this$224] := item$224;                                                                   
                                                                                                    
                                                                                                    
 // 21.7: this$224.owner := owner$224;                                                              
                                                                                                    
                                                                                                    
 moverPath2857503 := WriteEval.Node.owner(tid: Tid,this$224: Node,owner$224: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857503 := m#moverPath(moverPath2857503);                                                     
 path2857503 := p#moverPath(moverPath2857503);                                                      
 assume Node._state2857503 == Node._state && Node.item2857503 == Node.item && Node.next2857503 == Node.next && Node.owner2857503 == Node.owner && Node._lock2857503 == Node._lock && List._state2857503 == List._state && List.head2857503 == List.head && List._lock2857503 == List._lock && Main._state2857503 == Main._state && Main._lock2857503 == Main._lock && this$2242857503 == this$224 && owner$2242857503 == owner$224 && item$2242857503 == item$224 && tail$2232857503 == tail$223 && this$2232857503 == this$223 && list2857503 == list && this2857503 == this && tid2857503 == tid && $pc2857503 == $pc;
 assume $recorded.state2857503 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$224 != Node.null;                                                                     
 } else {                                                                                           
  assert this$224 != Node.null;                                                                            // (21.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2857503);                                                              
 assert $pc != PhaseError;                                                                                 // (21.7): Reduction failure
 Node.owner[this$224] := owner$224;                                                                 
 if (isLocal(List._state[owner$224], tid)) {                                                        
  List._state[owner$224] := SHARED();                                                               
  assert isSharedAssignable(Node._state[List.head[owner$224]]);                                            // (21.7): owner$224 became shared, but owner$224.head may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 19.32: break exit$224;                                                                          
                                                                                                    
 goto exit$224_bottom;                                                                              
 exit$224_bottom:                                                                                   
                                                                                                    
 // 35.7: Node head$223;                                                                            
                                                                                                    
                                                                                                    
 // 35.7: head$223 = new Node();                                                                    
                                                                                                    
 havoc head$223;                                                                                    
 assume head$223 != Node.null && isFresh(Node._state[head$223]);                                    
 Node._state[head$223] := LOCAL(tid);                                                               
 assume Node.item[head$223]  == 0;                                                                  
 assume Node.next[head$223]  == Node.null;                                                          
 assume Node.owner[head$223]  == List.null;                                                         
 assume Node._lock[head$223]  == Tid.null;                                                          
 // inlined: head$223.init(-1073741824,List.null)}                                                  
 exit$225_top:                                                                                      
                                                                                                    
 // 35.7: int item$225;                                                                             
                                                                                                    
                                                                                                    
 // 35.7: List owner$225;                                                                           
                                                                                                    
                                                                                                    
 // 35.7: Node this$225;                                                                            
                                                                                                    
                                                                                                    
 // 35.7: item$225 = -1073741824;                                                                   
                                                                                                    
 item$225 := -1073741824;                                                                           
                                                                                                    
 // 35.7: owner$225 = List.null;                                                                    
                                                                                                    
 owner$225 := List.null;                                                                            
                                                                                                    
 // 35.7: this$225 = head$223;                                                                      
                                                                                                    
 this$225 := head$223;                                                                              
                                                                                                    
 // 19.5: assume this$225.item == 0;                                                                
                                                                                                    
 assume (Node.item[this$225]==0);                                                                   
                                                                                                    
 // 19.5: assume this$225.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$225]==Node.null);                                                           
                                                                                                    
 // 19.5: assume this$225.owner == List.null;                                                       
                                                                                                    
 assume (Node.owner[this$225]==List.null);                                                          
                                                                                                    
                                                                                                    
 // 20.7: this$225.item := item$225;                                                                
                                                                                                    
                                                                                                    
 moverPath2857573 := WriteEval.Node.item(tid: Tid,this$225: Node,item$225: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857573 := m#moverPath(moverPath2857573);                                                     
 path2857573 := p#moverPath(moverPath2857573);                                                      
 assume Node._state2857573 == Node._state && Node.item2857573 == Node.item && Node.next2857573 == Node.next && Node.owner2857573 == Node.owner && Node._lock2857573 == Node._lock && List._state2857573 == List._state && List.head2857573 == List.head && List._lock2857573 == List._lock && Main._state2857573 == Main._state && Main._lock2857573 == Main._lock && this$2252857573 == this$225 && owner$2252857573 == owner$225 && item$2252857573 == item$225 && head$2232857573 == head$223 && tail$2232857573 == tail$223 && this$2232857573 == this$223 && list2857573 == list && this2857573 == this && tid2857573 == tid && $pc2857573 == $pc;
 assume $recorded.state2857573 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$225 != Node.null;                                                                     
 } else {                                                                                           
  assert this$225 != Node.null;                                                                            // (20.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2857573);                                                              
 assert $pc != PhaseError;                                                                                 // (20.7): Reduction failure
 Node.item[this$225] := item$225;                                                                   
                                                                                                    
                                                                                                    
 // 21.7: this$225.owner := owner$225;                                                              
                                                                                                    
                                                                                                    
 moverPath2857576 := WriteEval.Node.owner(tid: Tid,this$225: Node,owner$225: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857576 := m#moverPath(moverPath2857576);                                                     
 path2857576 := p#moverPath(moverPath2857576);                                                      
 assume Node._state2857576 == Node._state && Node.item2857576 == Node.item && Node.next2857576 == Node.next && Node.owner2857576 == Node.owner && Node._lock2857576 == Node._lock && List._state2857576 == List._state && List.head2857576 == List.head && List._lock2857576 == List._lock && Main._state2857576 == Main._state && Main._lock2857576 == Main._lock && this$2252857576 == this$225 && owner$2252857576 == owner$225 && item$2252857576 == item$225 && head$2232857576 == head$223 && tail$2232857576 == tail$223 && this$2232857576 == this$223 && list2857576 == list && this2857576 == this && tid2857576 == tid && $pc2857576 == $pc;
 assume $recorded.state2857576 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$225 != Node.null;                                                                     
 } else {                                                                                           
  assert this$225 != Node.null;                                                                            // (21.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2857576);                                                              
 assert $pc != PhaseError;                                                                                 // (21.7): Reduction failure
 Node.owner[this$225] := owner$225;                                                                 
 if (isLocal(List._state[owner$225], tid)) {                                                        
  List._state[owner$225] := SHARED();                                                               
  assert isSharedAssignable(Node._state[List.head[owner$225]]);                                            // (21.7): owner$225 became shared, but owner$225.head may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 19.32: break exit$225;                                                                          
                                                                                                    
 goto exit$225_bottom;                                                                              
 exit$225_bottom:                                                                                   
                                                                                                    
 // 36.7: tail$223.owner := this$223, this$223.head := head$223, head$223.owner := this$223, head$223.next := tail$223;
                                                                                                    
 assert $pc == PreCommit;                                                                                  // (36.7): Local Write block must appear pre commit.
                                                                                                    
 // 36.7: tail$223.owner := this$223;                                                               
                                                                                                    
                                                                                                    
 moverPath2857594 := WriteEval.Node.owner(tid: Tid,tail$223: Node,this$223: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857594 := m#moverPath(moverPath2857594);                                                     
 path2857594 := p#moverPath(moverPath2857594);                                                      
 assume Node._state2857594 == Node._state && Node.item2857594 == Node.item && Node.next2857594 == Node.next && Node.owner2857594 == Node.owner && Node._lock2857594 == Node._lock && List._state2857594 == List._state && List.head2857594 == List.head && List._lock2857594 == List._lock && Main._state2857594 == Main._state && Main._lock2857594 == Main._lock && head$2232857594 == head$223 && tail$2232857594 == tail$223 && this$2232857594 == this$223 && list2857594 == list && this2857594 == this && tid2857594 == tid && $pc2857594 == $pc;
 assume $recorded.state2857594 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tail$223 != Node.null;                                                                     
 } else {                                                                                           
  assert tail$223 != Node.null;                                                                            // (36.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857594);                                                              
 assert $pc != PhaseError;                                                                                 // (36.7): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.7): Local Write block can only include right-movers.
 Node.owner[tail$223] := this$223;                                                                  
                                                                                                    
 // 36.26: this$223.head := head$223;                                                               
                                                                                                    
                                                                                                    
 moverPath2857597 := WriteEval.List.head(tid: Tid,this$223: List,head$223: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857597 := m#moverPath(moverPath2857597);                                                     
 path2857597 := p#moverPath(moverPath2857597);                                                      
 assume Node._state2857597 == Node._state && Node.item2857597 == Node.item && Node.next2857597 == Node.next && Node.owner2857597 == Node.owner && Node._lock2857597 == Node._lock && List._state2857597 == List._state && List.head2857597 == List.head && List._lock2857597 == List._lock && Main._state2857597 == Main._state && Main._lock2857597 == Main._lock && head$2232857597 == head$223 && tail$2232857597 == tail$223 && this$2232857597 == this$223 && list2857597 == list && this2857597 == this && tid2857597 == tid && $pc2857597 == $pc;
 assume $recorded.state2857597 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$223 != List.null;                                                                     
 } else {                                                                                           
  assert this$223 != List.null;                                                                            // (36.26): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857597);                                                              
 assert $pc != PhaseError;                                                                                 // (36.26): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.26): Local Write block can only include right-movers.
 List.head[this$223] := head$223;                                                                   
                                                                                                    
 // 36.44: head$223.owner := this$223;                                                              
                                                                                                    
                                                                                                    
 moverPath2857600 := WriteEval.Node.owner(tid: Tid,head$223: Node,this$223: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857600 := m#moverPath(moverPath2857600);                                                     
 path2857600 := p#moverPath(moverPath2857600);                                                      
 assume Node._state2857600 == Node._state && Node.item2857600 == Node.item && Node.next2857600 == Node.next && Node.owner2857600 == Node.owner && Node._lock2857600 == Node._lock && List._state2857600 == List._state && List.head2857600 == List.head && List._lock2857600 == List._lock && Main._state2857600 == Main._state && Main._lock2857600 == Main._lock && head$2232857600 == head$223 && tail$2232857600 == tail$223 && this$2232857600 == this$223 && list2857600 == list && this2857600 == this && tid2857600 == tid && $pc2857600 == $pc;
 assume $recorded.state2857600 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume head$223 != Node.null;                                                                     
 } else {                                                                                           
  assert head$223 != Node.null;                                                                            // (36.44): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857600);                                                              
 assert $pc != PhaseError;                                                                                 // (36.44): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.44): Local Write block can only include right-movers.
 Node.owner[head$223] := this$223;                                                                  
                                                                                                    
 // 36.63: head$223.next := tail$223;                                                               
                                                                                                    
                                                                                                    
 moverPath2857603 := WriteEval.Node.next(tid: Tid,head$223: Node,tail$223: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 mover2857603 := m#moverPath(moverPath2857603);                                                     
 path2857603 := p#moverPath(moverPath2857603);                                                      
 assume Node._state2857603 == Node._state && Node.item2857603 == Node.item && Node.next2857603 == Node.next && Node.owner2857603 == Node.owner && Node._lock2857603 == Node._lock && List._state2857603 == List._state && List.head2857603 == List.head && List._lock2857603 == List._lock && Main._state2857603 == Main._state && Main._lock2857603 == Main._lock && head$2232857603 == head$223 && tail$2232857603 == tail$223 && this$2232857603 == this$223 && list2857603 == list && this2857603 == this && tid2857603 == tid && $pc2857603 == $pc;
 assume $recorded.state2857603 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume head$223 != Node.null;                                                                     
 } else {                                                                                           
  assert head$223 != Node.null;                                                                            // (36.63): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2857603);                                                              
 assert $pc != PhaseError;                                                                                 // (36.63): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.63): Local Write block can only include right-movers.
 Node.next[head$223] := tail$223;                                                                   
 assert isLocal(List._state[this$223], tid);                                                               // (36.7): Can only have local designators in Local Write block.
 assert isLocal(Node._state[head$223], tid);                                                               // (36.26): Can only have local designators in Local Write block.
 assert isLocal(List._state[this$223], tid);                                                               // (36.44): Can only have local designators in Local Write block.
 assert isLocal(Node._state[tail$223], tid);                                                               // (36.63): Can only have local designators in Local Write block.
 List._state[this$223] := SHARED();                                                                 
 Node._state[head$223] := SHARED();                                                                 
 List._state[this$223] := SHARED();                                                                 
 Node._state[tail$223] := SHARED();                                                                 
 assert isSharedAssignable(Node._state[List.head[this$223]]);                                              // (36.7): this$223 became shared, but this$223.head may not be shared.
 assert isSharedAssignable(Node._state[Node.next[head$223]]);                                              // (36.26): head$223 became shared, but head$223.next may not be shared.
 assert isSharedAssignable(List._state[Node.owner[head$223]]);                                             // (36.26): head$223 became shared, but head$223.owner may not be shared.
 assert isSharedAssignable(Node._state[List.head[this$223]]);                                              // (36.44): this$223 became shared, but this$223.head may not be shared.
 assert isSharedAssignable(Node._state[Node.next[tail$223]]);                                              // (36.63): tail$223 became shared, but tail$223.next may not be shared.
 assert isSharedAssignable(List._state[Node.owner[tail$223]]);                                             // (36.63): tail$223 became shared, but tail$223.owner may not be shared.
                                                                                                    
 // 33.12: break exit$223;                                                                          
                                                                                                    
 goto exit$223_bottom;                                                                              
 exit$223_bottom:                                                                                   
                                                                                                    
 // 115.22: // return;                                                                              
                                                                                                    
 assume Node._state2857615 == Node._state && Node.item2857615 == Node.item && Node.next2857615 == Node.next && Node.owner2857615 == Node.owner && Node._lock2857615 == Node._lock && List._state2857615 == List._state && List.head2857615 == List.head && List._lock2857615 == List._lock && Main._state2857615 == Main._state && Main._lock2857615 == Main._lock && list2857615 == list && this2857615 == this && tid2857615 == tid;
 assume $recorded.state2857615 == 1;                                                                
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (115.22): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: List  :: _i == List.null <==> isNull(List._state[_i])) &&                             
  (forall _i: Main  :: _i == Main.null <==> isNull(Main._state[_i])) &&                             
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(List._state[Node.owner[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(List._state[Node.owner[_i]], _t)))) &&
  (forall _i: List ::  (isShared(List._state[_i]) ==> isSharedAssignable(Node._state[List.head[_i]]))) &&
  (forall _i: List ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(List._state[_i],_t) ==> isLocalAssignable(Node._state[List.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)        
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.owner(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.5): Node.owner failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.owner[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.owner[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.owner[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.owner(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.5): Node.owner failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)              
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.owner[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.owner[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.List.head(u: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (27.5): List.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 List.head[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.List.head(u: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (27.5): List.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == List.head[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 List.head[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Main._state_mid: [Main]State;                                                                  
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Main._state_pre: [Main]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Main._lock_post: [Main]Tid;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures Y(tid , old(Node._state), old(Node.item), old(Node.next), old(Node.owner), old(Node._lock), old(List._state), old(List.head), old(List._lock), old(Main._state), old(Main._lock) , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (5.23): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var newValue_pre: int;                                                                              
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var newValue_post: int;                                                                             
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_Node.item(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (6.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// Node.owner:                                                                                      
                                                                                                    
function {:inline} Y_Node.owner(tid : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.owner(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (Node.owner[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.owner(tid : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var newValue_yield: List;                                                                           
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.owner(u: Tid,this: Node,newValue: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.owner(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.owner(tid, this, Node.owner[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Transitive(tid : Tid, this: Node, newValue : List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (7.25): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var newValue_pre: List;                                                                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var newValue_post: List;                                                                            
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_Node.owner(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.owner(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// List.head:                                                                                       
                                                                                                    
function {:inline} Y_List.head(tid : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (List.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List.head(tid : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List.head.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List.head(u: Tid,this: List,newValue: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Reflexive(tid : Tid, this: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, List.head[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Transitive(tid : Tid, this: List, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (27.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_List.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List.head(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// List._lock:                                                                                      
                                                                                                    
function {:inline} Y_List._lock(tid : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (List._lock[this] == newValue))
 &&(((List._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List._lock(tid : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List._lock(u: Tid,this: List,newValue: Tid,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Reflexive(tid : Tid, this: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, List._lock[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Transitive(tid : Tid, this: List, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_List._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
// Main._lock:                                                                                      
                                                                                                    
function {:inline} Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Main._state[this], tid) && leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _R)) ==> (Main._lock[this] == newValue))
 &&(((Main._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Subsumes.W(tid : Tid, u : Tid, this: Main, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume isAccessible(Main._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Main._lock(u: Tid,this: Main,newValue: Tid,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Reflexive(tid : Tid, this: Main , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var Main._state_yield: [Main]State;                                                                 
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, Main._lock[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Transitive(tid : Tid, this: Main, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849981(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2849989(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850004(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850021(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2850037(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850637(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2850644(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock,Main._state,Main._lock));       // (114.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var this_pre: Main;                                                                                 
var Main._lock_pre: [Main]Tid;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Main._state_pre: [Main]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var this_post: Main;                                                                                
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Main._lock_post: [Main]Tid;                                                                     
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
 assume Y_Main._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p, Main._state_p, Main._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Main._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid): bool
{                                                                                                   
 (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: Node :: Y_Node.owner(tid : Tid, this, Node.owner_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: List :: Y_List.head(tid : Tid, this, List.head_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: List :: Y_List._lock(tid : Tid, this, List._lock_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall this: Main :: Y_Main._lock(tid : Tid, this, Main._lock_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock, Main._state, Main._lock))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : List :: isShared(List._state[_i]) ==> isShared(List._state_p[_i]))                 
 && (forall _i : List :: isLocal(List._state[_i], tid) <==> isLocal(List._state_p[_i], tid))        
 && (forall _i : Main :: isShared(Main._state[_i]) ==> isShared(Main._state_p[_i]))                 
 && (forall _i : Main :: isLocal(Main._state[_i], tid) <==> isLocal(Main._state_p[_i], tid))        
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1757.1-2528.2: (Method:39.5)
// 1772.1-1772.24: (39.5): Bad tid
// 1773.1-1773.38: (39.5): this is not global
// 1778.1-1778.266: (39.5): Object invariant may not hold.
// 1779.1-1779.266: (39.5): Object invariant may not hold.
// 1780.1-1780.266: (39.5): Object invariant may not hold.
// 1781.1-1781.266: (39.5): Object invariant may not hold.
// 1782.1-1782.266: (39.5): Object invariant may not hold.
// 1783.1-1783.266: (39.5): Object invariant may not hold.
// 1784.1-1784.266: (39.5): Object invariant may not hold.
// 1787.1-1787.265: (39.5): Object invariant may not hold.
// 1788.1-1788.265: (39.5): Object invariant may not hold.
// 1789.1-1789.265: (39.5): Object invariant may not hold.
// 1790.1-1790.265: (39.5): Object invariant may not hold.
// 1791.1-1791.265: (39.5): Object invariant may not hold.
// 1792.1-1792.265: (39.5): Object invariant may not hold.
// 1793.1-1793.265: (39.5): Object invariant may not hold.
// 2133.1-2133.14: (39.29): Can only have right-mover memory accesses in requires clause
// 2135.2-2137.2: (class anchor.sink.VarDeclStmt:41.9)
// 2138.2-2140.2: (class anchor.sink.VarDeclStmt:42.9)
// 2141.2-2143.2: (class anchor.sink.VarDeclStmt:43.9)
// 2144.2-2147.14: (class anchor.sink.Assign:43.9)
// 2151.1-2151.28: (44.22): Cannot have potential null deference in left-mover part.
// 2155.1-2155.27: (44.22): Reduction failure
// 2157.2-2174.26: (class anchor.sink.Read:45.13)
// 2169.1-2169.28: (45.13): Cannot have potential null deference in left-mover part.
// 2173.1-2173.27: (45.13): Reduction failure
// 2175.2-2192.26: (class anchor.sink.Read:46.13)
// 2187.1-2187.28: (46.13): Cannot have potential null deference in left-mover part.
// 2191.1-2191.27: (46.13): Reduction failure
// 2195.2-2199.14: (class anchor.sink.While:48.13)
// 2201.1-2201.27: (39.5): Bad tid
// 2202.1-2202.41: (39.5): this is not global
// 2205.1-2205.269: (48.13): Object invariant may not hold.
// 2206.1-2206.269: (48.13): Object invariant may not hold.
// 2207.1-2207.269: (48.13): Object invariant may not hold.
// 2208.1-2208.269: (48.13): Object invariant may not hold.
// 2209.1-2209.269: (48.13): Object invariant may not hold.
// 2210.1-2210.269: (48.13): Object invariant may not hold.
// 2211.1-2211.269: (48.13): Object invariant may not hold.
// 2211.269-2212.41: (48.13): invariant isShared(curr) may not hold
// 2212.41-2213.41: (48.13): invariant isShared(pred) may not hold
// 2213.41-2214.36: (48.13): invariant pred.item < item may not hold
// 2214.36-2215.38: (48.13): invariant pred.owner == this may not hold
// 2215.38-2216.38: (48.13): invariant curr.owner == this may not hold
// 2216.38-2217.79: (48.13): invariant holds(this, tid) may not hold
// 2218.1-2218.277: (48.13): Loop does not preserve yields_as annotation for field item
// 2219.1-2219.277: (48.13): Loop does not preserve yields_as annotation for field next
// 2220.1-2220.279: (48.13): Loop does not preserve yields_as annotation for field owner
// 2221.1-2221.277: (48.13): Loop does not preserve yields_as annotation for field head
// 2222.1-2222.33: (48.13): Phase must be invariant at loop head
// 2223.1-2223.30: (48.13): Potentially infinite loop cannot be in post-commit phase.
// 2225.3-2227.3: (class anchor.sink.VarDeclStmt:48.30)
// 2228.3-2230.3: (class anchor.sink.VarDeclStmt:48.20)
// 2231.3-2248.27: (class anchor.sink.Read:48.20)
// 2243.1-2243.29: (48.20): Cannot have potential null deference in left-mover part.
// 2247.1-2247.28: (48.20): Reduction failure
// 2249.3-2252.23: (class anchor.sink.Assign:48.30)
// 2254.4-2257.10: (class anchor.sink.Break:48.13)
// 2260.3-2263.16: (class anchor.sink.Assign:55.17)
// 2264.3-2281.27: (class anchor.sink.Read:56.17)
// 2276.1-2276.29: (56.17): Cannot have potential null deference in left-mover part.
// 2280.1-2280.28: (56.17): Reduction failure
// 2284.1-2284.30: (48.13): Phase must be invariant at loop head
// 2286.2-2288.2: (class anchor.sink.VarDeclStmt:58.13)
// 2289.2-2291.2: (class anchor.sink.VarDeclStmt:58.13)
// 2292.2-2309.26: (class anchor.sink.Read:58.13)
// 2304.1-2304.28: (58.13): Cannot have potential null deference in left-mover part.
// 2308.1-2308.27: (58.13): Reduction failure
// 2310.2-2313.23: (class anchor.sink.Assign:58.13)
// 2318.1-2318.29: (66.9): Cannot have potential null deference in left-mover part.
// 2320.1-2320.34: (66.9): lock not held
// 2322.1-2322.28: (66.9): Reduction failure
// 2324.3-2337.10: (class anchor.sink.Return:59.17)
// 2330.1-2330.266: (59.17): Object invariant may not hold.
// 2331.1-2331.266: (59.17): Object invariant may not hold.
// 2332.1-2332.266: (59.17): Object invariant may not hold.
// 2333.1-2333.266: (59.17): Object invariant may not hold.
// 2334.1-2334.266: (59.17): Object invariant may not hold.
// 2335.1-2335.266: (59.17): Object invariant may not hold.
// 2336.1-2336.266: (59.17): Object invariant may not hold.
// 2339.3-2341.3: (class anchor.sink.VarDeclStmt:61.17)
// 2342.3-2351.40: (class anchor.sink.Alloc:61.17)
// 2354.3-2356.3: (class anchor.sink.VarDeclStmt:61.17)
// 2357.3-2359.3: (class anchor.sink.VarDeclStmt:61.17)
// 2360.3-2362.3: (class anchor.sink.VarDeclStmt:61.17)
// 2363.3-2366.20: (class anchor.sink.Assign:61.17)
// 2367.3-2370.21: (class anchor.sink.Assign:61.17)
// 2371.3-2374.20: (class anchor.sink.Assign:61.17)
// 2375.3-2378.35: (class anchor.sink.Assume:19.5)
// 2379.3-2382.43: (class anchor.sink.Assume:19.5)
// 2383.3-2386.44: (class anchor.sink.Assume:19.5)
// 2388.3-2404.35: (class anchor.sink.Write:20.7)
// 2400.1-2400.33: (20.7): Cannot have potential null deference in left-mover part.
// 2403.1-2403.28: (20.7): Reduction failure
// 2406.3-2427.3: (class anchor.sink.Write:21.7)
// 2418.1-2418.33: (21.7): Cannot have potential null deference in left-mover part.
// 2421.1-2421.28: (21.7): Reduction failure
// 2425.1-2425.65: (21.7): owner$222 became shared, but owner$222.head may not be shared.
// 2428.3-2431.24: (class anchor.sink.Break:19.32)
// 2434.3-2456.3: (class anchor.sink.Write:62.17)
// 2446.1-2446.29: (62.17): Cannot have potential null deference in left-mover part.
// 2449.1-2449.28: (62.17): Reduction failure
// 2453.1-2453.60: (62.17): curr became shared, but curr.next may not be shared.
// 2454.1-2454.61: (62.17): curr became shared, but curr.owner may not be shared.
// 2458.3-2480.3: (class anchor.sink.Write:63.17)
// 2470.1-2470.29: (63.17): Cannot have potential null deference in left-mover part.
// 2473.1-2473.28: (63.17): Reduction failure
// 2477.1-2477.60: (63.17): node became shared, but node.next may not be shared.
// 2478.1-2478.61: (63.17): node became shared, but node.owner may not be shared.
// 2484.1-2484.29: (66.9): Cannot have potential null deference in left-mover part.
// 2486.1-2486.34: (66.9): lock not held
// 2488.1-2488.28: (66.9): Reduction failure
// 2490.3-2503.10: (class anchor.sink.Return:64.17)
// 2496.1-2496.266: (64.17): Object invariant may not hold.
// 2497.1-2497.266: (64.17): Object invariant may not hold.
// 2498.1-2498.266: (64.17): Object invariant may not hold.
// 2499.1-2499.266: (64.17): Object invariant may not hold.
// 2500.1-2500.266: (64.17): Object invariant may not hold.
// 2501.1-2501.266: (64.17): Object invariant may not hold.
// 2502.1-2502.266: (64.17): Object invariant may not hold.
// 2508.1-2508.28: (66.9): Cannot have potential null deference in left-mover part.
// 2510.1-2510.33: (66.9): lock not held
// 2512.1-2512.27: (66.9): Reduction failure
// 2514.2-2527.9: (class anchor.sink.Return:40.34)
// 2520.1-2520.265: (40.34): Object invariant may not hold.
// 2521.1-2521.265: (40.34): Object invariant may not hold.
// 2522.1-2522.265: (40.34): Object invariant may not hold.
// 2523.1-2523.265: (40.34): Object invariant may not hold.
// 2524.1-2524.265: (40.34): Object invariant may not hold.
// 2525.1-2525.265: (40.34): Object invariant may not hold.
// 2526.1-2526.265: (40.34): Object invariant may not hold.
// 2529.1-3124.2: (Method:69.5)
// 2544.1-2544.24: (69.5): Bad tid
// 2545.1-2545.38: (69.5): this is not global
// 2550.1-2550.266: (69.5): Object invariant may not hold.
// 2551.1-2551.266: (69.5): Object invariant may not hold.
// 2552.1-2552.266: (69.5): Object invariant may not hold.
// 2553.1-2553.266: (69.5): Object invariant may not hold.
// 2554.1-2554.266: (69.5): Object invariant may not hold.
// 2555.1-2555.266: (69.5): Object invariant may not hold.
// 2556.1-2556.266: (69.5): Object invariant may not hold.
// 2559.1-2559.265: (69.5): Object invariant may not hold.
// 2560.1-2560.265: (69.5): Object invariant may not hold.
// 2561.1-2561.265: (69.5): Object invariant may not hold.
// 2562.1-2562.265: (69.5): Object invariant may not hold.
// 2563.1-2563.265: (69.5): Object invariant may not hold.
// 2564.1-2564.265: (69.5): Object invariant may not hold.
// 2565.1-2565.265: (69.5): Object invariant may not hold.
// 2833.1-2833.14: (69.29): Can only have right-mover memory accesses in requires clause
// 2835.2-2837.2: (class anchor.sink.VarDeclStmt:71.9)
// 2838.2-2840.2: (class anchor.sink.VarDeclStmt:72.9)
// 2844.1-2844.28: (73.22): Cannot have potential null deference in left-mover part.
// 2848.1-2848.27: (73.22): Reduction failure
// 2850.2-2867.26: (class anchor.sink.Read:74.13)
// 2862.1-2862.28: (74.13): Cannot have potential null deference in left-mover part.
// 2866.1-2866.27: (74.13): Reduction failure
// 2868.2-2885.26: (class anchor.sink.Read:75.13)
// 2880.1-2880.28: (75.13): Cannot have potential null deference in left-mover part.
// 2884.1-2884.27: (75.13): Reduction failure
// 2888.2-2892.14: (class anchor.sink.While:77.13)
// 2894.1-2894.27: (69.5): Bad tid
// 2895.1-2895.41: (69.5): this is not global
// 2898.1-2898.269: (77.13): Object invariant may not hold.
// 2899.1-2899.269: (77.13): Object invariant may not hold.
// 2900.1-2900.269: (77.13): Object invariant may not hold.
// 2901.1-2901.269: (77.13): Object invariant may not hold.
// 2902.1-2902.269: (77.13): Object invariant may not hold.
// 2903.1-2903.269: (77.13): Object invariant may not hold.
// 2904.1-2904.269: (77.13): Object invariant may not hold.
// 2904.269-2905.41: (77.13): invariant isShared(curr) may not hold
// 2905.41-2906.41: (77.13): invariant isShared(pred) may not hold
// 2906.41-2907.36: (77.13): invariant pred.item < item may not hold
// 2907.36-2908.38: (77.13): invariant pred.owner == this may not hold
// 2908.38-2909.38: (77.13): invariant curr.owner == this may not hold
// 2909.38-2910.79: (77.13): invariant holds(this, tid) may not hold
// 2911.1-2911.277: (77.13): Loop does not preserve yields_as annotation for field item
// 2912.1-2912.277: (77.13): Loop does not preserve yields_as annotation for field next
// 2913.1-2913.279: (77.13): Loop does not preserve yields_as annotation for field owner
// 2914.1-2914.277: (77.13): Loop does not preserve yields_as annotation for field head
// 2915.1-2915.33: (77.13): Phase must be invariant at loop head
// 2916.1-2916.30: (77.13): Potentially infinite loop cannot be in post-commit phase.
// 2918.3-2920.3: (class anchor.sink.VarDeclStmt:77.30)
// 2921.3-2923.3: (class anchor.sink.VarDeclStmt:77.20)
// 2924.3-2941.27: (class anchor.sink.Read:77.20)
// 2936.1-2936.29: (77.20): Cannot have potential null deference in left-mover part.
// 2940.1-2940.28: (77.20): Reduction failure
// 2942.3-2945.23: (class anchor.sink.Assign:77.30)
// 2947.4-2950.10: (class anchor.sink.Break:77.13)
// 2953.3-2956.16: (class anchor.sink.Assign:84.17)
// 2957.3-2974.27: (class anchor.sink.Read:85.17)
// 2969.1-2969.29: (85.17): Cannot have potential null deference in left-mover part.
// 2973.1-2973.28: (85.17): Reduction failure
// 2977.1-2977.30: (77.13): Phase must be invariant at loop head
// 2979.2-2981.2: (class anchor.sink.VarDeclStmt:87.13)
// 2982.2-2984.2: (class anchor.sink.VarDeclStmt:87.13)
// 2985.2-3002.26: (class anchor.sink.Read:87.13)
// 2997.1-2997.28: (87.13): Cannot have potential null deference in left-mover part.
// 3001.1-3001.27: (87.13): Reduction failure
// 3003.2-3006.23: (class anchor.sink.Assign:87.13)
// 3008.3-3010.3: (class anchor.sink.VarDeclStmt:88.15)
// 3011.3-3028.27: (class anchor.sink.Read:88.15)
// 3023.1-3023.29: (88.15): Cannot have potential null deference in left-mover part.
// 3027.1-3027.28: (88.15): Reduction failure
// 3030.3-3052.3: (class anchor.sink.Write:88.15)
// 3042.1-3042.29: (88.15): Cannot have potential null deference in left-mover part.
// 3045.1-3045.28: (88.15): Reduction failure
// 3049.1-3049.60: (88.15): tmp9 became shared, but tmp9.next may not be shared.
// 3050.1-3050.61: (88.15): tmp9 became shared, but tmp9.owner may not be shared.
// 3056.1-3056.29: (93.9): Cannot have potential null deference in left-mover part.
// 3058.1-3058.34: (93.9): lock not held
// 3060.1-3060.28: (93.9): Reduction failure
// 3062.3-3075.10: (class anchor.sink.Return:89.15)
// 3068.1-3068.266: (89.15): Object invariant may not hold.
// 3069.1-3069.266: (89.15): Object invariant may not hold.
// 3070.1-3070.266: (89.15): Object invariant may not hold.
// 3071.1-3071.266: (89.15): Object invariant may not hold.
// 3072.1-3072.266: (89.15): Object invariant may not hold.
// 3073.1-3073.266: (89.15): Object invariant may not hold.
// 3074.1-3074.266: (89.15): Object invariant may not hold.
// 3080.1-3080.29: (93.9): Cannot have potential null deference in left-mover part.
// 3082.1-3082.34: (93.9): lock not held
// 3084.1-3084.28: (93.9): Reduction failure
// 3086.3-3099.10: (class anchor.sink.Return:91.15)
// 3092.1-3092.266: (91.15): Object invariant may not hold.
// 3093.1-3093.266: (91.15): Object invariant may not hold.
// 3094.1-3094.266: (91.15): Object invariant may not hold.
// 3095.1-3095.266: (91.15): Object invariant may not hold.
// 3096.1-3096.266: (91.15): Object invariant may not hold.
// 3097.1-3097.266: (91.15): Object invariant may not hold.
// 3098.1-3098.266: (91.15): Object invariant may not hold.
// 3104.1-3104.28: (93.9): Cannot have potential null deference in left-mover part.
// 3106.1-3106.33: (93.9): lock not held
// 3108.1-3108.27: (93.9): Reduction failure
// 3110.2-3123.9: (class anchor.sink.Return:70.37)
// 3116.1-3116.265: (70.37): Object invariant may not hold.
// 3117.1-3117.265: (70.37): Object invariant may not hold.
// 3118.1-3118.265: (70.37): Object invariant may not hold.
// 3119.1-3119.265: (70.37): Object invariant may not hold.
// 3120.1-3120.265: (70.37): Object invariant may not hold.
// 3121.1-3121.265: (70.37): Object invariant may not hold.
// 3122.1-3122.265: (70.37): Object invariant may not hold.
// 3125.1-3573.2: (Method:97.5)
// 3140.1-3140.24: (97.5): Bad tid
// 3141.1-3141.38: (97.5): this is not global
// 3146.1-3146.266: (97.5): Object invariant may not hold.
// 3147.1-3147.266: (97.5): Object invariant may not hold.
// 3148.1-3148.266: (97.5): Object invariant may not hold.
// 3149.1-3149.266: (97.5): Object invariant may not hold.
// 3150.1-3150.266: (97.5): Object invariant may not hold.
// 3151.1-3151.266: (97.5): Object invariant may not hold.
// 3152.1-3152.266: (97.5): Object invariant may not hold.
// 3155.1-3155.265: (97.5): Object invariant may not hold.
// 3156.1-3156.265: (97.5): Object invariant may not hold.
// 3157.1-3157.265: (97.5): Object invariant may not hold.
// 3158.1-3158.265: (97.5): Object invariant may not hold.
// 3159.1-3159.265: (97.5): Object invariant may not hold.
// 3160.1-3160.265: (97.5): Object invariant may not hold.
// 3161.1-3161.265: (97.5): Object invariant may not hold.
// 3356.1-3356.14: (97.29): Can only have right-mover memory accesses in requires clause
// 3361.1-3361.28: (99.19): Cannot have potential null deference in left-mover part.
// 3365.1-3365.27: (99.19): Reduction failure
// 3367.2-3369.2: (class anchor.sink.VarDeclStmt:100.8)
// 3370.2-3387.26: (class anchor.sink.Read:100.8)
// 3382.1-3382.28: (100.8): Cannot have potential null deference in left-mover part.
// 3386.1-3386.27: (100.8): Reduction failure
// 3388.2-3390.2: (class anchor.sink.VarDeclStmt:101.8)
// 3391.2-3408.26: (class anchor.sink.Read:101.8)
// 3403.1-3403.28: (101.8): Cannot have potential null deference in left-mover part.
// 3407.1-3407.27: (101.8): Reduction failure
// 3411.2-3415.14: (class anchor.sink.While:102.8)
// 3417.1-3417.27: (97.5): Bad tid
// 3418.1-3418.41: (97.5): this is not global
// 3421.1-3421.269: (102.8): Object invariant may not hold.
// 3422.1-3422.269: (102.8): Object invariant may not hold.
// 3423.1-3423.269: (102.8): Object invariant may not hold.
// 3424.1-3424.269: (102.8): Object invariant may not hold.
// 3425.1-3425.269: (102.8): Object invariant may not hold.
// 3426.1-3426.269: (102.8): Object invariant may not hold.
// 3427.1-3427.269: (102.8): Object invariant may not hold.
// 3427.269-3428.41: (102.8): invariant isShared(curr) may not hold
// 3428.41-3429.38: (102.8): invariant curr.owner == this may not hold
// 3429.38-3430.79: (102.8): invariant holds(this, tid) may not hold
// 3431.1-3431.277: (102.8): Loop does not preserve yields_as annotation for field item
// 3432.1-3432.277: (102.8): Loop does not preserve yields_as annotation for field next
// 3433.1-3433.279: (102.8): Loop does not preserve yields_as annotation for field owner
// 3434.1-3434.277: (102.8): Loop does not preserve yields_as annotation for field head
// 3435.1-3435.33: (102.8): Phase must be invariant at loop head
// 3436.1-3436.30: (102.8): Potentially infinite loop cannot be in post-commit phase.
// 3438.3-3440.3: (class anchor.sink.VarDeclStmt:102.25)
// 3441.3-3443.3: (class anchor.sink.VarDeclStmt:102.15)
// 3444.3-3461.28: (class anchor.sink.Read:102.15)
// 3456.1-3456.29: (102.15): Cannot have potential null deference in left-mover part.
// 3460.1-3460.28: (102.15): Reduction failure
// 3462.3-3465.25: (class anchor.sink.Assign:102.25)
// 3467.4-3470.10: (class anchor.sink.Break:102.8)
// 3473.3-3476.16: (class anchor.sink.Assign:106.10)
// 3477.3-3494.27: (class anchor.sink.Read:107.10)
// 3489.1-3489.29: (107.10): Cannot have potential null deference in left-mover part.
// 3493.1-3493.28: (107.10): Reduction failure
// 3497.1-3497.30: (102.8): Phase must be invariant at loop head
// 3499.2-3501.2: (class anchor.sink.VarDeclStmt:109.8)
// 3502.2-3504.2: (class anchor.sink.VarDeclStmt:109.8)
// 3505.2-3522.27: (class anchor.sink.Read:109.8)
// 3517.1-3517.28: (109.8): Cannot have potential null deference in left-mover part.
// 3521.1-3521.27: (109.8): Reduction failure
// 3523.2-3526.25: (class anchor.sink.Assign:109.8)
// 3530.1-3530.28: (110.6): Cannot have potential null deference in left-mover part.
// 3532.1-3532.33: (110.6): lock not held
// 3534.1-3534.27: (110.6): Reduction failure
// 3536.2-3549.9: (class anchor.sink.Return:109.8)
// 3542.1-3542.265: (109.8): Object invariant may not hold.
// 3543.1-3543.265: (109.8): Object invariant may not hold.
// 3544.1-3544.265: (109.8): Object invariant may not hold.
// 3545.1-3545.265: (109.8): Object invariant may not hold.
// 3546.1-3546.265: (109.8): Object invariant may not hold.
// 3547.1-3547.265: (109.8): Object invariant may not hold.
// 3548.1-3548.265: (109.8): Object invariant may not hold.
// 3553.1-3553.28: (110.6): Cannot have potential null deference in left-mover part.
// 3555.1-3555.33: (110.6): lock not held
// 3557.1-3557.27: (110.6): Reduction failure
// 3559.2-3572.9: (class anchor.sink.Return:98.39)
// 3565.1-3565.265: (98.39): Object invariant may not hold.
// 3566.1-3566.265: (98.39): Object invariant may not hold.
// 3567.1-3567.265: (98.39): Object invariant may not hold.
// 3568.1-3568.265: (98.39): Object invariant may not hold.
// 3569.1-3569.265: (98.39): Object invariant may not hold.
// 3570.1-3570.265: (98.39): Object invariant may not hold.
// 3571.1-3571.265: (98.39): Object invariant may not hold.
// 3651.1-4218.2: (Method:115.3)
// 3665.1-3665.24: (115.3): Bad tid
// 3666.1-3666.38: (115.3): this is not global
// 3669.1-3669.266: (115.3): Object invariant may not hold.
// 3670.1-3670.266: (115.3): Object invariant may not hold.
// 3671.1-3671.266: (115.3): Object invariant may not hold.
// 3672.1-3672.266: (115.3): Object invariant may not hold.
// 3673.1-3673.266: (115.3): Object invariant may not hold.
// 3674.1-3674.266: (115.3): Object invariant may not hold.
// 3675.1-3675.266: (115.3): Object invariant may not hold.
// 3678.1-3678.265: (115.3): Object invariant may not hold.
// 3679.1-3679.265: (115.3): Object invariant may not hold.
// 3680.1-3680.265: (115.3): Object invariant may not hold.
// 3681.1-3681.265: (115.3): Object invariant may not hold.
// 3682.1-3682.265: (115.3): Object invariant may not hold.
// 3683.1-3683.265: (115.3): Object invariant may not hold.
// 3684.1-3684.265: (115.3): Object invariant may not hold.
// 3894.2-3896.2: (class anchor.sink.VarDeclStmt:116.5)
// 3897.2-3904.39: (class anchor.sink.Alloc:116.5)
// 3907.2-3909.2: (class anchor.sink.VarDeclStmt:116.5)
// 3910.2-3913.19: (class anchor.sink.Assign:116.5)
// 3914.2-3917.42: (class anchor.sink.Assume:33.5)
// 3918.2-3920.2: (class anchor.sink.VarDeclStmt:34.7)
// 3921.2-3930.43: (class anchor.sink.Alloc:34.7)
// 3933.2-3935.2: (class anchor.sink.VarDeclStmt:34.7)
// 3936.2-3938.2: (class anchor.sink.VarDeclStmt:34.7)
// 3939.2-3941.2: (class anchor.sink.VarDeclStmt:34.7)
// 3942.2-3945.25: (class anchor.sink.Assign:34.7)
// 3946.2-3949.25: (class anchor.sink.Assign:34.7)
// 3950.2-3953.23: (class anchor.sink.Assign:34.7)
// 3954.2-3957.34: (class anchor.sink.Assume:19.5)
// 3958.2-3961.42: (class anchor.sink.Assume:19.5)
// 3962.2-3965.43: (class anchor.sink.Assume:19.5)
// 3967.2-3983.34: (class anchor.sink.Write:20.7)
// 3979.1-3979.32: (20.7): Cannot have potential null deference in left-mover part.
// 3982.1-3982.27: (20.7): Reduction failure
// 3985.2-4006.2: (class anchor.sink.Write:21.7)
// 3997.1-3997.32: (21.7): Cannot have potential null deference in left-mover part.
// 4000.1-4000.27: (21.7): Reduction failure
// 4004.1-4004.64: (21.7): owner$224 became shared, but owner$224.head may not be shared.
// 4007.2-4010.23: (class anchor.sink.Break:19.32)
// 4012.2-4014.2: (class anchor.sink.VarDeclStmt:35.7)
// 4015.2-4024.43: (class anchor.sink.Alloc:35.7)
// 4027.2-4029.2: (class anchor.sink.VarDeclStmt:35.7)
// 4030.2-4032.2: (class anchor.sink.VarDeclStmt:35.7)
// 4033.2-4035.2: (class anchor.sink.VarDeclStmt:35.7)
// 4036.2-4039.26: (class anchor.sink.Assign:35.7)
// 4040.2-4043.25: (class anchor.sink.Assign:35.7)
// 4044.2-4047.23: (class anchor.sink.Assign:35.7)
// 4048.2-4051.34: (class anchor.sink.Assume:19.5)
// 4052.2-4055.42: (class anchor.sink.Assume:19.5)
// 4056.2-4059.43: (class anchor.sink.Assume:19.5)
// 4061.2-4077.34: (class anchor.sink.Write:20.7)
// 4073.1-4073.32: (20.7): Cannot have potential null deference in left-mover part.
// 4076.1-4076.27: (20.7): Reduction failure
// 4079.2-4100.2: (class anchor.sink.Write:21.7)
// 4091.1-4091.32: (21.7): Cannot have potential null deference in left-mover part.
// 4094.1-4094.27: (21.7): Reduction failure
// 4098.1-4098.64: (21.7): owner$225 became shared, but owner$225.head may not be shared.
// 4101.2-4104.23: (class anchor.sink.Break:19.32)
// 4106.2-4199.63: (class anchor.sink.LocalWrites:36.7)
// 4109.1-4109.26: (36.7): Local Write block must appear pre commit.
// 4110.2-4128.35: (class anchor.sink.Write:36.7)
// 4122.1-4122.32: (36.7): Cannot have potential null deference in left-mover part.
// 4126.1-4126.27: (36.7): Reduction failure
// 4127.1-4127.26: (36.7): Local Write block can only include right-movers.
// 4129.2-4147.34: (class anchor.sink.Write:36.26)
// 4141.1-4141.32: (36.26): Cannot have potential null deference in left-mover part.
// 4145.1-4145.27: (36.26): Reduction failure
// 4146.1-4146.26: (36.26): Local Write block can only include right-movers.
// 4148.2-4166.35: (class anchor.sink.Write:36.44)
// 4160.1-4160.32: (36.44): Cannot have potential null deference in left-mover part.
// 4164.1-4164.27: (36.44): Reduction failure
// 4165.1-4165.26: (36.44): Local Write block can only include right-movers.
// 4167.2-4185.34: (class anchor.sink.Write:36.63)
// 4179.1-4179.32: (36.63): Cannot have potential null deference in left-mover part.
// 4183.1-4183.27: (36.63): Reduction failure
// 4184.1-4184.26: (36.63): Local Write block can only include right-movers.
// 4186.1-4186.45: (36.7): Can only have local designators in Local Write block.
// 4187.1-4187.45: (36.26): Can only have local designators in Local Write block.
// 4188.1-4188.45: (36.44): Can only have local designators in Local Write block.
// 4189.1-4189.45: (36.63): Can only have local designators in Local Write block.
// 4194.1-4194.62: (36.7): this$223 became shared, but this$223.head may not be shared.
// 4195.1-4195.62: (36.26): head$223 became shared, but head$223.next may not be shared.
// 4196.1-4196.63: (36.26): head$223 became shared, but head$223.owner may not be shared.
// 4197.1-4197.62: (36.44): this$223 became shared, but this$223.head may not be shared.
// 4198.1-4198.62: (36.63): tail$223 became shared, but tail$223.next may not be shared.
// 4199.1-4199.63: (36.63): tail$223 became shared, but tail$223.owner may not be shared.
// 4200.2-4203.23: (class anchor.sink.Break:33.12)
// 4205.2-4217.9: (class anchor.sink.Return:115.22)
// 4210.1-4210.265: (115.22): Object invariant may not hold.
// 4211.1-4211.265: (115.22): Object invariant may not hold.
// 4212.1-4212.265: (115.22): Object invariant may not hold.
// 4213.1-4213.265: (115.22): Object invariant may not hold.
// 4214.1-4214.265: (115.22): Object invariant may not hold.
// 4215.1-4215.265: (115.22): Object invariant may not hold.
// 4216.1-4216.265: (115.22): Object invariant may not hold.
// 4314.1-4314.34: (5.5): Node.item failed Write-Write Right-Mover Check
// 4385.1-4385.30: (5.5): Node.item failed Write-Read Right-Mover Check
// 4460.1-4460.34: (5.5): Node.item failed Write-Write Left-Mover Check
// 4532.1-4532.30: (5.5): Node.item failed Write-Read Left-Mover Check
// 4601.1-4601.34: (5.5): Node.item failed Read-Write Right-Mover Check
// 4673.1-4673.34: (5.5): Node.item failed Read-Write Left-Mover Check
// 4744.1-4744.34: (6.5): Node.next failed Write-Write Right-Mover Check
// 4815.1-4815.30: (6.5): Node.next failed Write-Read Right-Mover Check
// 4890.1-4890.34: (6.5): Node.next failed Write-Write Left-Mover Check
// 4962.1-4962.30: (6.5): Node.next failed Write-Read Left-Mover Check
// 5031.1-5031.34: (6.5): Node.next failed Read-Write Right-Mover Check
// 5103.1-5103.34: (6.5): Node.next failed Read-Write Left-Mover Check
// 5174.1-5174.34: (7.5): Node.owner failed Write-Write Right-Mover Check
// 5245.1-5245.30: (7.5): Node.owner failed Write-Read Right-Mover Check
// 5320.1-5320.34: (7.5): Node.owner failed Write-Write Left-Mover Check
// 5392.1-5392.30: (7.5): Node.owner failed Write-Read Left-Mover Check
// 5461.1-5461.34: (7.5): Node.owner failed Read-Write Right-Mover Check
// 5533.1-5533.34: (7.5): Node.owner failed Read-Write Left-Mover Check
// 5604.1-5604.34: (27.5): List.head failed Write-Write Right-Mover Check
// 5675.1-5675.30: (27.5): List.head failed Write-Read Right-Mover Check
// 5750.1-5750.34: (27.5): List.head failed Write-Write Left-Mover Check
// 5822.1-5822.30: (27.5): List.head failed Write-Read Left-Mover Check
// 5891.1-5891.34: (27.5): List.head failed Read-Write Right-Mover Check
// 5963.1-5963.34: (27.5): List.head failed Read-Write Left-Mover Check
// 6046.1-6046.140: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 6047.1-6047.101: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 6048.1-6048.158: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 6162.1-6162.140: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 6281.1-6281.144: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 6282.1-6282.144: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 6365.1-6365.136: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 6366.1-6366.136: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 6367.1-6367.146: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 6449.1-6449.136: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 6450.1-6450.136: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 6451.1-6451.99: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 6535.1-6535.140: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 6536.1-6536.101: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 6537.1-6537.158: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 6651.1-6651.140: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 6770.1-6770.144: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 6771.1-6771.144: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 6854.1-6854.136: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 6855.1-6855.136: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 6856.1-6856.146: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 6938.1-6938.136: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 6939.1-6939.136: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 6940.1-6940.99: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 7024.1-7024.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.1)
// 7025.1-7025.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.2)
// 7026.1-7026.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.3)
// 7140.1-7140.140: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case C)
// 7259.1-7259.144: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case D)
// 7260.1-7260.144: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case R)
// 7343.1-7343.136: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case F)
// 7344.1-7344.136: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case H)
// 7345.1-7345.146: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case I)
// 7427.1-7427.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case J)
// 7428.1-7428.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case K)
// 7429.1-7429.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case L)
// 7513.1-7513.140: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
// 7514.1-7514.101: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
// 7515.1-7515.156: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
// 7629.1-7629.140: (5.5): Node.item is not Write-Write Stable with respect to List.head (case C)
// 7748.1-7748.144: (5.5): Node.item is not Write-Write Stable with respect to List.head (case D)
// 7749.1-7749.144: (5.5): Node.item is not Write-Write Stable with respect to List.head (case R)
// 7832.1-7832.136: (5.5): Node.item is not Read-Write Stable with respect to List.head (case F)
// 7833.1-7833.136: (5.5): Node.item is not Read-Write Stable with respect to List.head (case H)
// 7834.1-7834.144: (5.5): Node.item is not Read-Write Stable with respect to List.head (case I)
// 7916.1-7916.136: (27.5): List.head is not Write-Read Stable with respect to Node.item (case J)
// 7917.1-7917.136: (27.5): List.head is not Write-Read Stable with respect to Node.item (case K)
// 7918.1-7918.99: (27.5): List.head is not Write-Read Stable with respect to Node.item (case L)
// 8002.1-8002.140: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 8003.1-8003.101: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 8004.1-8004.158: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 8118.1-8118.140: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 8237.1-8237.144: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 8238.1-8238.144: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 8321.1-8321.136: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 8322.1-8322.136: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 8323.1-8323.146: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 8405.1-8405.136: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 8406.1-8406.136: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 8407.1-8407.99: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 8491.1-8491.140: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 8492.1-8492.101: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 8493.1-8493.158: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 8607.1-8607.140: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 8726.1-8726.144: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 8727.1-8727.144: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 8810.1-8810.136: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 8811.1-8811.136: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 8812.1-8812.146: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 8894.1-8894.136: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 8895.1-8895.136: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 8896.1-8896.99: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 8980.1-8980.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.1)
// 8981.1-8981.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.2)
// 8982.1-8982.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.3)
// 9096.1-9096.140: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case C)
// 9215.1-9215.144: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case D)
// 9216.1-9216.144: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case R)
// 9299.1-9299.136: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case F)
// 9300.1-9300.136: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case H)
// 9301.1-9301.146: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case I)
// 9383.1-9383.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case J)
// 9384.1-9384.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case K)
// 9385.1-9385.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case L)
// 9469.1-9469.140: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
// 9470.1-9470.101: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
// 9471.1-9471.156: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
// 9585.1-9585.140: (6.5): Node.next is not Write-Write Stable with respect to List.head (case C)
// 9704.1-9704.144: (6.5): Node.next is not Write-Write Stable with respect to List.head (case D)
// 9705.1-9705.144: (6.5): Node.next is not Write-Write Stable with respect to List.head (case R)
// 9788.1-9788.136: (6.5): Node.next is not Read-Write Stable with respect to List.head (case F)
// 9789.1-9789.136: (6.5): Node.next is not Read-Write Stable with respect to List.head (case H)
// 9790.1-9790.144: (6.5): Node.next is not Read-Write Stable with respect to List.head (case I)
// 9872.1-9872.136: (27.5): List.head is not Write-Read Stable with respect to Node.next (case J)
// 9873.1-9873.136: (27.5): List.head is not Write-Read Stable with respect to Node.next (case K)
// 9874.1-9874.99: (27.5): List.head is not Write-Read Stable with respect to Node.next (case L)
// 9958.1-9958.140: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.1)
// 9959.1-9959.101: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.2)
// 9960.1-9960.158: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.3)
// 10074.1-10074.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case C)
// 10193.1-10193.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case D)
// 10194.1-10194.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case R)
// 10277.1-10277.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case F)
// 10278.1-10278.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case H)
// 10279.1-10279.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case I)
// 10361.1-10361.136: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case J)
// 10362.1-10362.136: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case K)
// 10363.1-10363.99: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case L)
// 10447.1-10447.140: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.1)
// 10448.1-10448.101: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.2)
// 10449.1-10449.158: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.3)
// 10563.1-10563.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case C)
// 10682.1-10682.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case D)
// 10683.1-10683.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case R)
// 10766.1-10766.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case F)
// 10767.1-10767.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case H)
// 10768.1-10768.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case I)
// 10850.1-10850.136: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case J)
// 10851.1-10851.136: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case K)
// 10852.1-10852.99: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case L)
// 10936.1-10936.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.1)
// 10937.1-10937.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.2)
// 10938.1-10938.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.3)
// 11052.1-11052.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case C)
// 11171.1-11171.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case D)
// 11172.1-11172.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case R)
// 11255.1-11255.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case F)
// 11256.1-11256.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case H)
// 11257.1-11257.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case I)
// 11339.1-11339.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case J)
// 11340.1-11340.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case K)
// 11341.1-11341.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case L)
// 11425.1-11425.140: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.1)
// 11426.1-11426.101: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.2)
// 11427.1-11427.156: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.3)
// 11541.1-11541.140: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case C)
// 11660.1-11660.144: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case D)
// 11661.1-11661.144: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case R)
// 11744.1-11744.136: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case F)
// 11745.1-11745.136: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case H)
// 11746.1-11746.144: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case I)
// 11828.1-11828.136: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case J)
// 11829.1-11829.136: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case K)
// 11830.1-11830.99: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case L)
// 11914.1-11914.140: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
// 11915.1-11915.101: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
// 11916.1-11916.156: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
// 12030.1-12030.140: (27.5): List.head is not Write-Write Stable with respect to Node.item (case C)
// 12149.1-12149.144: (27.5): List.head is not Write-Write Stable with respect to Node.item (case D)
// 12150.1-12150.144: (27.5): List.head is not Write-Write Stable with respect to Node.item (case R)
// 12233.1-12233.136: (27.5): List.head is not Read-Write Stable with respect to Node.item (case F)
// 12234.1-12234.136: (27.5): List.head is not Read-Write Stable with respect to Node.item (case H)
// 12235.1-12235.144: (27.5): List.head is not Read-Write Stable with respect to Node.item (case I)
// 12317.1-12317.136: (5.5): Node.item is not Write-Read Stable with respect to List.head (case J)
// 12318.1-12318.136: (5.5): Node.item is not Write-Read Stable with respect to List.head (case K)
// 12319.1-12319.99: (5.5): Node.item is not Write-Read Stable with respect to List.head (case L)
// 12403.1-12403.140: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
// 12404.1-12404.101: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
// 12405.1-12405.156: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
// 12519.1-12519.140: (27.5): List.head is not Write-Write Stable with respect to Node.next (case C)
// 12638.1-12638.144: (27.5): List.head is not Write-Write Stable with respect to Node.next (case D)
// 12639.1-12639.144: (27.5): List.head is not Write-Write Stable with respect to Node.next (case R)
// 12722.1-12722.136: (27.5): List.head is not Read-Write Stable with respect to Node.next (case F)
// 12723.1-12723.136: (27.5): List.head is not Read-Write Stable with respect to Node.next (case H)
// 12724.1-12724.144: (27.5): List.head is not Read-Write Stable with respect to Node.next (case I)
// 12806.1-12806.136: (6.5): Node.next is not Write-Read Stable with respect to List.head (case J)
// 12807.1-12807.136: (6.5): Node.next is not Write-Read Stable with respect to List.head (case K)
// 12808.1-12808.99: (6.5): Node.next is not Write-Read Stable with respect to List.head (case L)
// 12892.1-12892.140: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.1)
// 12893.1-12893.101: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.2)
// 12894.1-12894.156: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.3)
// 13008.1-13008.140: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case C)
// 13127.1-13127.144: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case D)
// 13128.1-13128.144: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case R)
// 13211.1-13211.136: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case F)
// 13212.1-13212.136: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case H)
// 13213.1-13213.144: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case I)
// 13295.1-13295.136: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case J)
// 13296.1-13296.136: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case K)
// 13297.1-13297.99: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case L)
// 13381.1-13381.140: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
// 13382.1-13382.101: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
// 13383.1-13383.158: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
// 13497.1-13497.140: (27.5): List.head is not Write-Write Stable with respect to List.head (case C)
// 13616.1-13616.144: (27.5): List.head is not Write-Write Stable with respect to List.head (case D)
// 13617.1-13617.144: (27.5): List.head is not Write-Write Stable with respect to List.head (case R)
// 13700.1-13700.136: (27.5): List.head is not Read-Write Stable with respect to List.head (case F)
// 13701.1-13701.136: (27.5): List.head is not Read-Write Stable with respect to List.head (case H)
// 13702.1-13702.146: (27.5): List.head is not Read-Write Stable with respect to List.head (case I)
// 13784.1-13784.136: (27.5): List.head is not Write-Read Stable with respect to List.head (case J)
// 13785.1-13785.136: (27.5): List.head is not Write-Read Stable with respect to List.head (case K)
// 13786.1-13786.99: (27.5): List.head is not Write-Read Stable with respect to List.head (case L)
// 13793.1-13793.266: (<undefined position>): Object invariant may not hold.
// 13794.1-13794.266: (<undefined position>): Object invariant may not hold.
// 13795.1-13795.266: (<undefined position>): Object invariant may not hold.
// 13796.1-13796.266: (<undefined position>): Object invariant may not hold.
// 13797.1-13797.266: (<undefined position>): Object invariant may not hold.
// 13798.1-13798.266: (<undefined position>): Object invariant may not hold.
// 13799.1-13799.266: (<undefined position>): Object invariant may not hold.
// 13812.1-13812.265: (<undefined position>): Object invariant may not hold.
// 13813.1-13813.265: (<undefined position>): Object invariant may not hold.
// 13814.1-13814.265: (<undefined position>): Object invariant may not hold.
// 13815.1-13815.265: (<undefined position>): Object invariant may not hold.
// 13816.1-13816.265: (<undefined position>): Object invariant may not hold.
// 13817.1-13817.265: (<undefined position>): Object invariant may not hold.
// 13818.1-13818.265: (<undefined position>): Object invariant may not hold.
// 13838.1-13864.2: (5.5): yields_as clause for Node.item is not valid
// 13869.1-13890.2: (5.5): yields_as clause for Node.item is not reflexive
// 13896.1-13896.266: (5.23): Object invariant may not hold.
// 13897.1-13897.266: (5.23): Object invariant may not hold.
// 13898.1-13898.266: (5.23): Object invariant may not hold.
// 13899.1-13899.266: (5.23): Object invariant may not hold.
// 13900.1-13900.266: (5.23): Object invariant may not hold.
// 13901.1-13901.266: (5.23): Object invariant may not hold.
// 13902.1-13902.266: (5.23): Object invariant may not hold.
// 13903.1-13945.2: (5.5): yields_as clause for Node.item is not transitive
// 13964.1-13990.2: (6.5): yields_as clause for Node.next is not valid
// 13995.1-14016.2: (6.5): yields_as clause for Node.next is not reflexive
// 14022.1-14022.266: (6.24): Object invariant may not hold.
// 14023.1-14023.266: (6.24): Object invariant may not hold.
// 14024.1-14024.266: (6.24): Object invariant may not hold.
// 14025.1-14025.266: (6.24): Object invariant may not hold.
// 14026.1-14026.266: (6.24): Object invariant may not hold.
// 14027.1-14027.266: (6.24): Object invariant may not hold.
// 14028.1-14028.266: (6.24): Object invariant may not hold.
// 14029.1-14071.2: (6.5): yields_as clause for Node.next is not transitive
// 14090.1-14116.2: (7.5): yields_as clause for Node.owner is not valid
// 14121.1-14142.2: (7.5): yields_as clause for Node.owner is not reflexive
// 14148.1-14148.266: (7.25): Object invariant may not hold.
// 14149.1-14149.266: (7.25): Object invariant may not hold.
// 14150.1-14150.266: (7.25): Object invariant may not hold.
// 14151.1-14151.266: (7.25): Object invariant may not hold.
// 14152.1-14152.266: (7.25): Object invariant may not hold.
// 14153.1-14153.266: (7.25): Object invariant may not hold.
// 14154.1-14154.266: (7.25): Object invariant may not hold.
// 14155.1-14197.2: (7.5): yields_as clause for Node.owner is not transitive
// 14217.1-14243.2: (7.32): yields_as clause for Node._lock is not valid
// 14248.1-14269.2: (7.32): yields_as clause for Node._lock is not reflexive
// 14275.1-14275.266: (4.1): Object invariant may not hold.
// 14276.1-14276.266: (4.1): Object invariant may not hold.
// 14277.1-14277.266: (4.1): Object invariant may not hold.
// 14278.1-14278.266: (4.1): Object invariant may not hold.
// 14279.1-14279.266: (4.1): Object invariant may not hold.
// 14280.1-14280.266: (4.1): Object invariant may not hold.
// 14281.1-14281.266: (4.1): Object invariant may not hold.
// 14282.1-14324.2: (7.32): yields_as clause for Node._lock is not transitive
// 14343.1-14369.2: (27.5): yields_as clause for List.head is not valid
// 14374.1-14395.2: (27.5): yields_as clause for List.head is not reflexive
// 14401.1-14401.266: (27.24): Object invariant may not hold.
// 14402.1-14402.266: (27.24): Object invariant may not hold.
// 14403.1-14403.266: (27.24): Object invariant may not hold.
// 14404.1-14404.266: (27.24): Object invariant may not hold.
// 14405.1-14405.266: (27.24): Object invariant may not hold.
// 14406.1-14406.266: (27.24): Object invariant may not hold.
// 14407.1-14407.266: (27.24): Object invariant may not hold.
// 14408.1-14450.2: (27.5): yields_as clause for List.head is not transitive
// 14470.1-14496.2: (7.32): yields_as clause for List._lock is not valid
// 14501.1-14522.2: (7.32): yields_as clause for List._lock is not reflexive
// 14528.1-14528.266: (25.1): Object invariant may not hold.
// 14529.1-14529.266: (25.1): Object invariant may not hold.
// 14530.1-14530.266: (25.1): Object invariant may not hold.
// 14531.1-14531.266: (25.1): Object invariant may not hold.
// 14532.1-14532.266: (25.1): Object invariant may not hold.
// 14533.1-14533.266: (25.1): Object invariant may not hold.
// 14534.1-14534.266: (25.1): Object invariant may not hold.
// 14535.1-14577.2: (7.32): yields_as clause for List._lock is not transitive
// 14597.1-14623.2: (7.32): yields_as clause for Main._lock is not valid
// 14628.1-14649.2: (7.32): yields_as clause for Main._lock is not reflexive
// 14655.1-14655.266: (114.1): Object invariant may not hold.
// 14656.1-14656.266: (114.1): Object invariant may not hold.
// 14657.1-14657.266: (114.1): Object invariant may not hold.
// 14658.1-14658.266: (114.1): Object invariant may not hold.
// 14659.1-14659.266: (114.1): Object invariant may not hold.
// 14660.1-14660.266: (114.1): Object invariant may not hold.
// 14661.1-14661.266: (114.1): Object invariant may not hold.
// 14662.1-14704.2: (7.32): yields_as clause for Main._lock is not transitive
