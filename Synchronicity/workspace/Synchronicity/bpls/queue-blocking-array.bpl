                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/queue-blocking-array.anchor:            
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Buffer {                                                                                  
      array T = int[holds(this, tid) ? B : E]                                                       
                                                                                                    
       [Buffer.T{this}] elementData isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int elementCount isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int start isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int end isLocal(this, tid)                                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.elementData == [Buffer.T{this}].null;                                           
        assume this.elementCount == 0;                                                              
        assume this.start == 0;                                                                     
        assume this.end == 0;                                                                       
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void insert(int t) {                                                                          
        synchronized (this) {                                                                       
          [Buffer.T{this}] elementData;                                                             
          elementData := this.elementData;                                                          
          while (true)   {                                                                          
            boolean tmp1;                                                                           
            int tmp2;                                                                               
            tmp2 := this.elementCount;                                                              
            int tmp3;                                                                               
            tmp3 = elementData.length;                                                              
            tmp1 = tmp2 == tmp3;                                                                    
            if (!tmp1) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              release(this);                                                                        
              yield;                                                                                
              acquire(this);                                                                        
            }                                                                                       
          }                                                                                         
          int tmp4;                                                                                 
          tmp4 := this.end;                                                                         
          elementData[tmp4] := t;                                                                   
          int tmp5;                                                                                 
          int tmp6;                                                                                 
          int tmp7;                                                                                 
          tmp7 := this.end;                                                                         
          tmp6 = tmp7 + 1;                                                                          
          int tmp8;                                                                                 
          tmp8 = elementData.length;                                                                
          tmp5 = tmp6 % tmp8;                                                                       
          this.end := tmp5;                                                                         
          int tmp9;                                                                                 
          int tmp10;                                                                                
          tmp10 := this.elementCount;                                                               
          tmp9 = tmp10 + 1;                                                                         
          this.elementCount := tmp9;                                                                
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      int delete() {                                                                                
        synchronized (this) {                                                                       
          [Buffer.T{this}] elementData;                                                             
          elementData := this.elementData;                                                          
          while (true)   {                                                                          
            boolean tmp11;                                                                          
            int tmp12;                                                                              
            tmp12 := this.elementCount;                                                             
            tmp11 = tmp12 == 0;                                                                     
            if (!tmp11) break; else {                                                               
                                                                                                    
            }                                                                                       
            {                                                                                       
              release(this);                                                                        
              yield;                                                                                
              acquire(this);                                                                        
            }                                                                                       
          }                                                                                         
          int t;                                                                                    
          int tmp13;                                                                                
          tmp13 := this.start;                                                                      
          t := elementData[tmp13];                                                                  
          int tmp14;                                                                                
          int tmp15;                                                                                
          int tmp16;                                                                                
          tmp16 := this.start;                                                                      
          tmp15 = tmp16 + 1;                                                                        
          int tmp17;                                                                                
          tmp17 = elementData.length;                                                               
          tmp14 = tmp15 % tmp17;                                                                    
          this.start := tmp14;                                                                      
          int tmp18;                                                                                
          int tmp19;                                                                                
          tmp19 := this.elementCount;                                                               
          tmp18 = tmp19 - 1;                                                                        
          this.elementCount := tmp18;                                                               
           return t;                                                                                
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Buffer {                                                                                  
      array T = int[holds(this, tid) ? B : E]                                                       
                                                                                                    
       [Buffer.T{this}] elementData isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int elementCount isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int start isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int end isLocal(this, tid)                                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.elementData == [Buffer.T{this}].null;                                           
        assume this.elementCount == 0;                                                              
        assume this.start == 0;                                                                     
        assume this.end == 0;                                                                       
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void insert(int t) {                                                                          
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := this.elementCount;                                                            
              int tmp3;                                                                             
              tmp3 = elementData.length;                                                            
              tmp1 = tmp2 == tmp3;                                                                  
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int tmp4;                                                                               
            tmp4 := this.end;                                                                       
            elementData[tmp4] := t;                                                                 
            int tmp5;                                                                               
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.end;                                                                       
            tmp6 = tmp7 + 1;                                                                        
            int tmp8;                                                                               
            tmp8 = elementData.length;                                                              
            tmp5 = tmp6 % tmp8;                                                                     
            this.end := tmp5;                                                                       
            int tmp9;                                                                               
            int tmp10;                                                                              
            tmp10 := this.elementCount;                                                             
            tmp9 = tmp10 + 1;                                                                       
            this.elementCount := tmp9;                                                              
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      int delete() {                                                                                
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp11;                                                                        
              int tmp12;                                                                            
              tmp12 := this.elementCount;                                                           
              tmp11 = tmp12 == 0;                                                                   
              if (!tmp11) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int t;                                                                                  
            int tmp13;                                                                              
            tmp13 := this.start;                                                                    
            t := elementData[tmp13];                                                                
            int tmp14;                                                                              
            int tmp15;                                                                              
            int tmp16;                                                                              
            tmp16 := this.start;                                                                    
            tmp15 = tmp16 + 1;                                                                      
            int tmp17;                                                                              
            tmp17 = elementData.length;                                                             
            tmp14 = tmp15 % tmp17;                                                                  
            this.start := tmp14;                                                                    
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.elementCount;                                                             
            tmp18 = tmp19 - 1;                                                                      
            this.elementCount := tmp18;                                                             
            {                                                                                       
              release(this);                                                                        
               return t;                                                                            
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Buffer {                                                                                  
      array T = int[holds(this, tid) ? B : E]                                                       
                                                                                                    
       [Buffer.T{this}] elementData isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int elementCount isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int start isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int end isLocal(this, tid)                                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.elementData == [Buffer.T{this}].null;                                           
        assume this.elementCount == 0;                                                              
        assume this.start == 0;                                                                     
        assume this.end == 0;                                                                       
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void insert(int t) {                                                                          
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := this.elementCount;                                                            
              int tmp3;                                                                             
              tmp3 = elementData.length;                                                            
              tmp1 = tmp2 == tmp3;                                                                  
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int tmp4;                                                                               
            tmp4 := this.end;                                                                       
            elementData[tmp4] := t;                                                                 
            int tmp5;                                                                               
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.end;                                                                       
            tmp6 = tmp7 + 1;                                                                        
            int tmp8;                                                                               
            tmp8 = elementData.length;                                                              
            tmp5 = tmp6 % tmp8;                                                                     
            this.end := tmp5;                                                                       
            int tmp9;                                                                               
            int tmp10;                                                                              
            tmp10 := this.elementCount;                                                             
            tmp9 = tmp10 + 1;                                                                       
            this.elementCount := tmp9;                                                              
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      int delete() {                                                                                
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp11;                                                                        
              int tmp12;                                                                            
              tmp12 := this.elementCount;                                                           
              tmp11 = tmp12 == 0;                                                                   
              if (!tmp11) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int t;                                                                                  
            int tmp13;                                                                              
            tmp13 := this.start;                                                                    
            t := elementData[tmp13];                                                                
            int tmp14;                                                                              
            int tmp15;                                                                              
            int tmp16;                                                                              
            tmp16 := this.start;                                                                    
            tmp15 = tmp16 + 1;                                                                      
            int tmp17;                                                                              
            tmp17 = elementData.length;                                                             
            tmp14 = tmp15 % tmp17;                                                                  
            this.start := tmp14;                                                                    
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.elementCount;                                                             
            tmp18 = tmp19 - 1;                                                                      
            this.elementCount := tmp18;                                                             
            {                                                                                       
              release(this);                                                                        
               return t;                                                                            
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Buffer {                                                                                  
      array T = int[holds(this, tid) ? B : E]                                                       
                                                                                                    
       [Buffer.T{this}] elementData isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int elementCount isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int start isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int end isLocal(this, tid)                                                                   
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.elementData == [Buffer.T{this}].null;                                           
        assume this.elementCount == 0;                                                              
        assume this.start == 0;                                                                     
        assume this.end == 0;                                                                       
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void insert(int t) {                                                                          
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := this.elementCount;                                                            
              int tmp3;                                                                             
              tmp3 = elementData.length;                                                            
              tmp1 = tmp2 == tmp3;                                                                  
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int tmp4;                                                                               
            tmp4 := this.end;                                                                       
            elementData[tmp4] := t;                                                                 
            int tmp5;                                                                               
            int tmp6;                                                                               
            int tmp7;                                                                               
            tmp7 := this.end;                                                                       
            tmp6 = tmp7 + 1;                                                                        
            int tmp8;                                                                               
            tmp8 = elementData.length;                                                              
            tmp5 = tmp6 % tmp8;                                                                     
            this.end := tmp5;                                                                       
            int tmp9;                                                                               
            int tmp10;                                                                              
            tmp10 := this.elementCount;                                                             
            tmp9 = tmp10 + 1;                                                                       
            this.elementCount := tmp9;                                                              
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      int delete() {                                                                                
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            [Buffer.T{this}] elementData;                                                           
            elementData := this.elementData;                                                        
            while (true)                                                                            
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp11;                                                                        
              int tmp12;                                                                            
              tmp12 := this.elementCount;                                                           
              tmp11 = tmp12 == 0;                                                                   
              if (!tmp11) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                release(this);                                                                      
                yield;                                                                              
                acquire(this);                                                                      
              }                                                                                     
            }                                                                                       
            int t;                                                                                  
            int tmp13;                                                                              
            tmp13 := this.start;                                                                    
            t := elementData[tmp13];                                                                
            int tmp14;                                                                              
            int tmp15;                                                                              
            int tmp16;                                                                              
            tmp16 := this.start;                                                                    
            tmp15 = tmp16 + 1;                                                                      
            int tmp17;                                                                              
            tmp17 = elementData.length;                                                             
            tmp14 = tmp15 % tmp17;                                                                  
            this.start := tmp14;                                                                    
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.elementCount;                                                             
            tmp18 = tmp19 - 1;                                                                      
            this.elementCount := tmp18;                                                             
            {                                                                                       
              release(this);                                                                        
               return t;                                                                            
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Buffer ***/                                                                         
                                                                                                    
type Buffer;                                                                                        
const unique Buffer.null: Buffer;                                                                   
var Buffer._state: [Buffer]State;                                                                   
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.elementData: [Buffer]Array.Buffer.T;                                                     
                                                                                                    
function {:inline} ReadEval.Buffer.elementData(tid: Tid,this : Buffer,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.Buffer.T.null;                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.elementData(tid: Tid,this : Buffer,newValue: Array.Buffer.T,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.elementCount: [Buffer]int;                                                               
                                                                                                    
function {:inline} ReadEval.Buffer.elementCount(tid: Tid,this : Buffer,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.elementCount(tid: Tid,this : Buffer,newValue: int,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.start: [Buffer]int;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer.start(tid: Tid,this : Buffer,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.start(tid: Tid,this : Buffer,newValue: int,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.end: [Buffer]int;                                                                        
                                                                                                    
function {:inline} ReadEval.Buffer.end(tid: Tid,this : Buffer,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.end(tid: Tid,this : Buffer,newValue: int,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isLocal(Buffer._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer._lock: [Buffer]Tid;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer._lock(tid: Tid,this : Buffer,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer._lock(tid: Tid,this : Buffer,newValue: Tid,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/*** Array Array.Buffer.T ***/                                                                      
                                                                                                    
type Array.Buffer.T;                                                                                
const unique Array.Buffer.T.null: Array.Buffer.T;                                                   
var Array.Buffer.T._state: [Array.Buffer.T]State;                                                   
                                                                                                    
const Array.Buffer.T._this : [Array.Buffer.T]Buffer;                                                
const Array.Buffer.T._length : [Array.Buffer.T]int;                                                 
var Array.Buffer.T._elems  : [Array.Buffer.T]([int]int);                                            
                                                                                                    
axiom (forall $this : Array.Buffer.T :: Array.Buffer.T._length[$this] >= 0);                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.Buffer.T: Spec(Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.Buffer.T(tid: Tid,this : Buffer,athis : Array.Buffer.T,index : int,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                    
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.Buffer.T: Spec(Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.Buffer.T(tid: Tid,this : Buffer,athis : Array.Buffer.T,index : int,newValue: int,Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)) then                    
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Buffer._state: [Buffer]State,Buffer.elementData: [Buffer]Array.Buffer.T,Buffer.elementCount: [Buffer]int,Buffer.start: [Buffer]int,Buffer.end: [Buffer]int,Buffer._lock: [Buffer]Tid,Array.Buffer.T._state: [Array.Buffer.T]State,Array.Buffer.T._elems: [Array.Buffer.T]([int]int),Array.Buffer.T._length: [Array.Buffer.T]int) returns (bool) {
  true &&                                                                                           
  (forall _i: Buffer  :: _i == Buffer.null <==> isNull(Buffer._state[_i])) &&                       
  (forall _i: Array.Buffer.T  :: _i == Array.Buffer.T.null <==> isNull(Array.Buffer.T._state[_i])) &&
  (forall _t: Tid, _i: Array.Buffer.T  :: ValidTid(_t) && isAccessible(Array.Buffer.T._state[_i], _t) ==> isAccessible(Buffer._state[Array.Buffer.T._this[_i]], _t)) &&
  (forall _i: Buffer ::  (isShared(Buffer._state[_i]) ==> isSharedAssignable(Array.Buffer.T._state[Buffer.elementData[_i]]))) &&
  (forall _i: Buffer ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Buffer._state[_i],_t) ==> isLocalAssignable(Array.Buffer.T._state[Buffer.elementData[_i]], _t)))) &&
  (forall _i: Buffer :: { Buffer.elementData[_i] } Array.Buffer.T._this[Buffer.elementData[_i]] == _i) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.elementData(u: Tid,x: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.2): Buffer.elementData failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.elementData(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.2): Buffer.elementData failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Buffer.T;                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.elementData[x];                                                                 
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.elementData[x] := havocValue;                                                               
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.elementData(u: Tid,x: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.2): Buffer.elementData failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.Buffer.T;                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.elementData[x];                                                                 
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.elementData(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.2): Buffer.elementData failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,x: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.2): Buffer.elementData failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Buffer.T;                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.elementData[x];                                                                 
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.elementData[x] := havocValue;                                                               
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,x: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.2): Buffer.elementData failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.2): Buffer.elementCount failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.elementCount(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.2): Buffer.elementCount failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.elementCount[x];                                                                
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.elementCount[x] := havocValue;                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.2): Buffer.elementCount failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer) 
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.elementCount[x];                                                                
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.elementCount(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.2): Buffer.elementCount failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer)     
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.2): Buffer.elementCount failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, x: Buffer)      
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.elementCount[x];                                                                
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.elementCount[x] := havocValue;                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.2): Buffer.elementCount failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)      
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.start(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.start failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)       
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.start(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (8.2): Buffer.start failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)       
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.start[x];                                                                       
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.start[x] := havocValue;                                                                     
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.start(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.start failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.start[x];                                                                       
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.start(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (8.2): Buffer.start failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)            
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.start failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.start(t: Tid, u: Tid, v: int, w: int, x: Buffer)             
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.start[x];                                                                       
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.start[x] := havocValue;                                                                     
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.start failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.end(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.2): Buffer.end failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)         
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.end(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (9.2): Buffer.end failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)         
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.end[x];                                                                         
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.end[x] := havocValue;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.end(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.2): Buffer.end failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)          
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.end[x];                                                                         
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.end(u: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (9.2): Buffer.end failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)              
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.2): Buffer.end failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.end(t: Tid, u: Tid, v: int, w: int, x: Buffer)               
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.end[x];                                                                         
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.end[x] := havocValue;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,x: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.2): Buffer.end failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.2): Array Array.Buffer.T failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (4.2): Array Array.Buffer.T failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Buffer.T._elems[x][i];                                                           
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.Buffer.T._elems[x][i] := havocValue;                                                         
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.2): Array Array.Buffer.T failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Buffer.T._elems[x][i];                                                           
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (4.2): Array Array.Buffer.T failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.2): Array Array.Buffer.T failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Buffer, x: Array.Buffer.T, i: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[x], u);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Array.Buffer.T._elems[x][i];                                                           
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.Buffer.T._elems[x][i] := havocValue;                                                         
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.2): Array Array.Buffer.T failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementData.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementData.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementData.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementData.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[y] := w;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementData.Buffer.elementData(t: Tid, u: Tid, v: Array.Buffer.T, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementData.Buffer.elementCount(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementData.Buffer.elementCount(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementData.Buffer.elementCount(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementData.Buffer.elementCount(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[y] := w;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementData.Buffer.elementCount(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementData.Buffer.start(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementData.Buffer.start(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementData.Buffer.start(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementData.Buffer.start(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[y] := w;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementData.Buffer.start(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementData.Buffer.end(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementData.Buffer.end(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementData.Buffer.end(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementData.Buffer.end(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[y] := w;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementData.Buffer.end(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementData;                                                                       
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementData.Array.Buffer.T._elems(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementData;                                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementData.Array.Buffer.T._elems(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementData;                                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var Buffer.end_mid: [Buffer]int;                                                                   
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementData.Array.Buffer.T._elems(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementData;                                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Buffer.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var v_mid: Array.Buffer.T;                                                                         
 var Buffer.end_mid: [Buffer]int;                                                                   
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementData[x];                                                                     
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementData[x] := tmpV;                                                                     
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementData.Array.Buffer.T._elems(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementData;                                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[y][j] := w;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementData(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementData.Array.Buffer.T._elems(t: Tid, u: Tid, v: Array.Buffer.T, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementData;                                                                       
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var v_pre: Array.Buffer.T;                                                                         
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var v_post: Array.Buffer.T;                                                                        
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementData(t: Tid,x: Buffer,v: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[x] := v;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementCount.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementCount.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementCount.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementCount.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[y] := w;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementCount.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementCount.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementCount.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementCount.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementCount.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[y] := w;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementCount.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementCount.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementCount.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementCount.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementCount.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[y] := w;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementCount.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementCount.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementCount.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementCount.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementCount.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[y] := w;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementCount.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.elementCount;                                                                      
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.elementCount.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementCount;                                                                      
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.elementCount.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementCount;                                                                      
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.elementCount.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementCount;                                                                      
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.elementCount[x];                                                                    
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.elementCount[x] := tmpV;                                                                    
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.elementCount.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementCount;                                                                      
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[y][j] := w;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.elementCount(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.elementCount.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.elementCount;                                                                      
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.elementCount(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[x] := v;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.start.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.start.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.start.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.start.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[y] := w;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.start.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.start.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.start.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.start.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.start.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[y] := w;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.start.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.start.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.start.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.start.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.start.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[y] := w;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.start.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.start.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.start.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.start.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.start.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[y] := w;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.start.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.start;                                                                             
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.start.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.start;                                                                             
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.start.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.start;                                                                             
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.start.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.start;                                                                             
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.start[x];                                                                           
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.start[x] := tmpV;                                                                           
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.start.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.start;                                                                             
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[y][j] := w;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.start(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.start.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.start;                                                                             
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.start(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[x] := v;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.end.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.end.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.end.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.end.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[y] := w;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.end.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.end.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.end.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.end.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.end.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[y] := w;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.end.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.end.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.end.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.end.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.end.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[y] := w;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.end.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.end.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.end.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.end.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.end.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[y] := w;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.end.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.end;                                                                               
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.end.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.end;                                                                               
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.end.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.end;                                                                               
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.end.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.end;                                                                               
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.end[x];                                                                             
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.end[x] := tmpV;                                                                             
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.end.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.end;                                                                               
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[y][j] := w;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.end(t: Tid,x: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.end.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Buffer.end;                                                                               
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var w_pre: int;                                                                                    
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var x_pre: Buffer;                                                                                 
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.end(t: Tid,x: Buffer,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[x] := v;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Buffer.T._elems.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Buffer.T._elems.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Buffer.T._elems.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var w_mid: Array.Buffer.T;                                                                         
 var w0_mid: Array.Buffer.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.elementData[y] := w;                                                                        
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Buffer.T._elems.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementData(u: Tid,y: Buffer,w: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementData[y] := w;                                                                        
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Buffer.T._elems.Buffer.elementData(t: Tid, u: Tid, v: int, w: Array.Buffer.T, w0: Array.Buffer.T, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementData;                                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var w0_pre: Array.Buffer.T;                                                                        
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var w_pre: Array.Buffer.T;                                                                         
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w0_post: Array.Buffer.T;                                                                       
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var w_post: Array.Buffer.T;                                                                        
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementData(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Buffer.T._elems.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Buffer.T._elems.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Buffer.T._elems.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.elementCount[y] := w;                                                                       
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Buffer.T._elems.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.elementCount(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.elementCount[y] := w;                                                                       
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Buffer.T._elems.Buffer.elementCount(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.elementCount;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.elementCount(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Buffer.T._elems.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Buffer.T._elems.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Buffer.T._elems.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.start[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Buffer.T._elems.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.start(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.start[y] := w;                                                                              
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Buffer.T._elems.Buffer.start(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.start;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.start(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Buffer.T._elems.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Buffer.T._elems.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Buffer.T._elems.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Buffer.end[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Buffer.T._elems.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.end(u: Tid,y: Buffer,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.end[y] := w;                                                                                
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Buffer.T._elems.Buffer.end(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y: Buffer)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Array.Buffer.T._elems;                                                                    
 modifies Buffer.end;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var y_pre: Buffer;                                                                                 
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var y_post: Buffer;                                                                                
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.end(u: Tid,y: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Buffer.T._elems.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Buffer.T._elems.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Buffer.T._elems.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_owner_mid: Buffer;                                                                           
 var t_mid: Tid;                                                                                    
 var y_mid: Array.Buffer.T;                                                                         
 var Array.Buffer.T._elems_mid: [Array.Buffer.T]([int]int);                                         
 var Array.Buffer.T._length_mid: [Array.Buffer.T]int;                                               
 var x_owner_mid: Buffer;                                                                           
 var Buffer.start_mid: [Buffer]int;                                                                 
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Array.Buffer.T._state_mid: [Array.Buffer.T]State;                                              
 var x_mid: Array.Buffer.T;                                                                         
 var Buffer.elementCount_mid: [Buffer]int;                                                          
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var Buffer.elementData_mid: [Buffer]Array.Buffer.T;                                                
 var Buffer._state_mid: [Buffer]State;                                                              
 var Buffer.end_mid: [Buffer]int;                                                                   
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Buffer.T._elems[x][i];                                                               
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_mid == Buffer._state && Buffer.elementData_mid == Buffer.elementData && Buffer.elementCount_mid == Buffer.elementCount && Buffer.start_mid == Buffer.start && Buffer.end_mid == Buffer.end && Buffer._lock_mid == Buffer._lock && Array.Buffer.T._state_mid == Array.Buffer.T._state && Array.Buffer.T._elems_mid == Array.Buffer.T._elems && Array.Buffer.T._length_mid == Array.Buffer.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Buffer.T._elems[x][i] := tmpV;                                                               
 Array.Buffer.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Buffer.T._elems.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,w: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[y][j] := w;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Buffer.T._elems.Array.Buffer.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Buffer, x: Array.Buffer.T, i: int, y_owner: Buffer, y: Array.Buffer.T, j: int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Buffer.T._state[x], t);                                                
 requires Array.Buffer.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Buffer.T._state[y], u);                                                
 requires Array.Buffer.T._this[y] == y_owner;                                                       
 modifies Array.Buffer.T._elems;                                                                    
 modifies Array.Buffer.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_owner_pre: Buffer;                                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                         
 var Buffer.elementCount_pre: [Buffer]int;                                                          
 var Buffer.start_pre: [Buffer]int;                                                                 
 var x_owner_pre: Buffer;                                                                           
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var x_pre: Array.Buffer.T;                                                                         
 var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                               
 var y_pre: Array.Buffer.T;                                                                         
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                              
 var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                
 var Buffer.end_pre: [Buffer]int;                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                             
 var w0_post: int;                                                                                  
 var y_post: Array.Buffer.T;                                                                        
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var $pc_post: Phase;                                                                               
 var Buffer.end_post: [Buffer]int;                                                                  
 var j_post: int;                                                                                   
 var Buffer.elementCount_post: [Buffer]int;                                                         
 var Buffer.start_post: [Buffer]int;                                                                
 var x_owner_post: Buffer;                                                                          
 var w_post: int;                                                                                   
 var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                        
 var v_post: int;                                                                                   
 var y_owner_post: Buffer;                                                                          
 var x_post: Array.Buffer.T;                                                                        
 var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                               
 var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                              
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Buffer.T(t: Tid,x_owner: Buffer,x: Array.Buffer.T,i: int,v: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Buffer.T._elems[x][i] := v;                                                                  
 assume Buffer._state_post == Buffer._state && Buffer.elementData_post == Buffer.elementData && Buffer.elementCount_post == Buffer.elementCount && Buffer.start_post == Buffer.start && Buffer.end_post == Buffer.end && Buffer._lock_post == Buffer._lock && Array.Buffer.T._state_post == Array.Buffer.T._state && Array.Buffer.T._elems_post == Array.Buffer.T._elems && Array.Buffer.T._length_post == Array.Buffer.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Buffer.T(u: Tid,y_owner: Buffer,y: Array.Buffer.T,j: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
requires ValidTid(tid);                                                                             
modifies Buffer._state;                                                                             
modifies Buffer.elementData;                                                                        
modifies Buffer.elementCount;                                                                       
modifies Buffer.start;                                                                              
modifies Buffer.end;                                                                                
modifies Buffer._lock;                                                                              
modifies Array.Buffer.T._state;                                                                     
modifies Array.Buffer.T._elems;                                                                     
ensures StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
ensures Y(tid , old(Buffer._state), old(Buffer.elementData), old(Buffer.elementCount), old(Buffer.start), old(Buffer.end), old(Buffer._lock), old(Array.Buffer.T._state), old(Array.Buffer.T._elems), old(Array.Buffer.T._length) , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
                                                                                                    
// Buffer.elementData:                                                                              
                                                                                                    
function {:inline} Y_Buffer.elementData(tid : Tid, this: Buffer, newValue: Array.Buffer.T , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.elementData(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Buffer.elementData[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.elementData(tid : Tid, this: Buffer, newValue: Array.Buffer.T , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementData.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Array.Buffer.T , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var u_yield: Tid;                                                                                   
var newValue_yield: Array.Buffer.T;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.elementData(u: Tid,this: Buffer,newValue: Array.Buffer.T,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
                                                                                                    
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.elementData(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementData.Reflexive(tid : Tid, this: Buffer , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.elementData(tid, this, Buffer.elementData[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementData.Transitive(tid : Tid, this: Buffer, newValue : Array.Buffer.T , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: Array.Buffer.T;                                                                   
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var newValue_post: Array.Buffer.T;                                                                  
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Buffer.elementData(tid, this, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.elementData(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
// Buffer.elementCount:                                                                             
                                                                                                    
function {:inline} Y_Buffer.elementCount(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.elementCount(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Buffer.elementCount[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.elementCount(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementCount.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var newValue_yield: int;                                                                            
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var u_yield: Tid;                                                                                   
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.elementCount(u: Tid,this: Buffer,newValue: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
                                                                                                    
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.elementCount(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementCount.Reflexive(tid : Tid, this: Buffer , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.elementCount(tid, this, Buffer.elementCount[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.elementCount.Transitive(tid : Tid, this: Buffer, newValue : int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: int;                                                                              
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Buffer.elementCount(tid, this, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.elementCount(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
// Buffer.start:                                                                                    
                                                                                                    
function {:inline} Y_Buffer.start(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.start(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Buffer.start[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.start(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.start.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var newValue_yield: int;                                                                            
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var u_yield: Tid;                                                                                   
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.start(u: Tid,this: Buffer,newValue: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
                                                                                                    
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.start(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.start.Reflexive(tid : Tid, this: Buffer , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.start(tid, this, Buffer.start[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.start.Transitive(tid : Tid, this: Buffer, newValue : int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: int;                                                                              
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Buffer.start(tid, this, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.start(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
// Buffer.end:                                                                                      
                                                                                                    
function {:inline} Y_Buffer.end(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.end(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Buffer.end[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.end(tid : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.end.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var newValue_yield: int;                                                                            
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var u_yield: Tid;                                                                                   
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.end(u: Tid,this: Buffer,newValue: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
                                                                                                    
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.end(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.end.Reflexive(tid : Tid, this: Buffer , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.end(tid, this, Buffer.end[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.end.Transitive(tid : Tid, this: Buffer, newValue : int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: int;                                                                              
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Buffer.end(tid, this, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.end(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
// Buffer._lock:                                                                                    
                                                                                                    
function {:inline} Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Buffer._lock[this] == newValue))
 &&(((Buffer._lock[this]==tid)==(newValue==tid)))                                                   
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Tid , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var newValue_yield: Tid;                                                                            
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var u_yield: Tid;                                                                                   
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer._lock(u: Tid,this: Buffer,newValue: Tid,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
 assume leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _N);
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Reflexive(tid : Tid, this: Buffer , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, Buffer._lock[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Transitive(tid : Tid, this: Buffer, newValue : Tid , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var newValue_pre: Tid;                                                                              
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var newValue_post: Tid;                                                                             
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Buffer._lock(tid, this, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer._lock(tid, this, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
// Array.Buffer.T:                                                                                  
                                                                                                    
function {:inline} Y_Array.Buffer.T(tid : Tid, athis: Array.Buffer.T, index: int, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
(var this := Array.Buffer.T._this[athis];                                                           
 ((isAccessible(Array.Buffer.T._state[athis], tid) && leq(m#moverPath(ReadEval.Array.Buffer.T(tid: Tid,Array.Buffer.T._this[athis]: Buffer,athis: Array.Buffer.T,index: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)), _R)) ==> (Array.Buffer.T._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Array.Buffer.T(tid : Tid, athis: Array.Buffer.T, index: int, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int): bool
{                                                                                                   
(var this := Array.Buffer.T._this[athis];                                                           
true                                                                                                
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.Buffer.T.Subsumes.W(tid : Tid, u : Tid, this: Buffer, athis: Array.Buffer.T, index: int, newValue: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.Buffer.T._this[athis];                                                      
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var athis_yield: Array.Buffer.T;                                                                    
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var index_yield: int;                                                                               
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Array.Buffer.T._state[athis], u);                                              
 assume !isError(m#moverPath(WriteEval.Array.Buffer.T(u: Tid,Array.Buffer.T._this[athis]: Buffer,athis: Array.Buffer.T,index: int,newValue: int,Buffer._state,Buffer.elementData,Buffer.elementCount,Buffer.start,Buffer.end,Buffer._lock,Array.Buffer.T._state,Array.Buffer.T._elems,Array.Buffer.T._length)));
                                                                                                    
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Buffer.T(tid, athis, index, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Buffer.T.Reflexive(tid : Tid, this: Buffer, athis: Array.Buffer.T, index: int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires ValidTid(tid);                                                                            
 requires this == Array.Buffer.T._this[athis];                                                      
{                                                                                                   
var Array.Buffer.T._state_yield: [Array.Buffer.T]State;                                             
var Buffer.start_yield: [Buffer]int;                                                                
var Buffer.end_yield: [Buffer]int;                                                                  
var Array.Buffer.T._elems_yield: [Array.Buffer.T]([int]int);                                        
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var $pc_yield: Phase;                                                                               
var Buffer.elementData_yield: [Buffer]Array.Buffer.T;                                               
var athis_yield: Array.Buffer.T;                                                                    
var Buffer.elementCount_yield: [Buffer]int;                                                         
var Array.Buffer.T._length_yield: [Array.Buffer.T]int;                                              
var index_yield: int;                                                                               
var Buffer._state_yield: [Buffer]State;                                                             
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Array.Buffer.T._state[athis], tid);                                            
assume Buffer._state_yield == Buffer._state && Buffer.elementData_yield == Buffer.elementData && Buffer.elementCount_yield == Buffer.elementCount && Buffer.start_yield == Buffer.start && Buffer.end_yield == Buffer.end && Buffer._lock_yield == Buffer._lock && Array.Buffer.T._state_yield == Array.Buffer.T._state && Array.Buffer.T._elems_yield == Array.Buffer.T._elems && Array.Buffer.T._length_yield == Array.Buffer.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Buffer.T(tid, athis, index, Array.Buffer.T._elems[athis][index] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Buffer.T.Transitive(tid : Tid, this: Buffer, athis: Array.Buffer.T, index: int, newValue : int , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int)
 requires StateInvariant(Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
 requires StateInvariant(Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
                                                                                                    
 requires this == Array.Buffer.T._this[athis];                                                      
 requires ValidTid(tid);                                                                            
{                                                                                                   
var $recorded.state_pre: int;                                                                       
var Buffer._state_pre: [Buffer]State;                                                               
var Array.Buffer.T._elems_pre: [Array.Buffer.T]([int]int);                                          
var index_pre: int;                                                                                 
var Buffer.elementCount_pre: [Buffer]int;                                                           
var Buffer.start_pre: [Buffer]int;                                                                  
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Array.Buffer.T._length_pre: [Array.Buffer.T]int;                                                
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Array.Buffer.T._state_pre: [Array.Buffer.T]State;                                               
var Buffer.elementData_pre: [Buffer]Array.Buffer.T;                                                 
var Buffer.end_pre: [Buffer]int;                                                                    
var athis_pre: Array.Buffer.T;                                                                      
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var $recorded.state_post: int;                                                                      
var athis_post: Array.Buffer.T;                                                                     
var Buffer._state_post: [Buffer]State;                                                              
var Array.Buffer.T._state_post: [Array.Buffer.T]State;                                              
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var Buffer.end_post: [Buffer]int;                                                                   
var Buffer.elementCount_post: [Buffer]int;                                                          
var tid_post: Tid;                                                                                  
var Buffer.start_post: [Buffer]int;                                                                 
var Array.Buffer.T._elems_post: [Array.Buffer.T]([int]int);                                         
var index_post: int;                                                                                
var Buffer.elementData_post: [Buffer]Array.Buffer.T;                                                
var Array.Buffer.T._length_post: [Array.Buffer.T]int;                                               
                                                                                                    
assume Buffer._state_pre == Buffer._state && Buffer.elementData_pre == Buffer.elementData && Buffer.elementCount_pre == Buffer.elementCount && Buffer.start_pre == Buffer.start && Buffer.end_pre == Buffer.end && Buffer._lock_pre == Buffer._lock && Array.Buffer.T._state_pre == Array.Buffer.T._state && Array.Buffer.T._elems_pre == Array.Buffer.T._elems && Array.Buffer.T._length_pre == Array.Buffer.T._length && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Buffer._state_post == Buffer._state_p && Buffer.elementData_post == Buffer.elementData_p && Buffer.elementCount_post == Buffer.elementCount_p && Buffer.start_post == Buffer.start_p && Buffer.end_post == Buffer.end_p && Buffer._lock_post == Buffer._lock_p && Array.Buffer.T._state_post == Array.Buffer.T._state_p && Array.Buffer.T._elems_post == Array.Buffer.T._elems_p && Array.Buffer.T._length_post == Array.Buffer.T._length_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.Buffer.T._state[athis], tid);                                            
 assume Y(tid , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assume Y_Array.Buffer.T(tid, athis, index, newValue , Buffer._state_p, Buffer.elementData_p, Buffer.elementCount_p, Buffer.start_p, Buffer.end_p, Buffer._lock_p, Array.Buffer.T._state_p, Array.Buffer.T._elems_p, Array.Buffer.T._length_p);
 assert Y_Array.Buffer.T(tid, athis, index, newValue , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Buffer._state: [Buffer]State, Buffer.elementData: [Buffer]Array.Buffer.T, Buffer.elementCount: [Buffer]int, Buffer.start: [Buffer]int, Buffer.end: [Buffer]int, Buffer._lock: [Buffer]Tid, Array.Buffer.T._state: [Array.Buffer.T]State, Array.Buffer.T._elems: [Array.Buffer.T]([int]int), Array.Buffer.T._length: [Array.Buffer.T]int , Buffer._state_p: [Buffer]State, Buffer.elementData_p: [Buffer]Array.Buffer.T, Buffer.elementCount_p: [Buffer]int, Buffer.start_p: [Buffer]int, Buffer.end_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid, Array.Buffer.T._state_p: [Array.Buffer.T]State, Array.Buffer.T._elems_p: [Array.Buffer.T]([int]int), Array.Buffer.T._length_p: [Array.Buffer.T]int): bool
{                                                                                                   
 (forall this: Buffer :: Y_Buffer.elementData(tid : Tid, this, Buffer.elementData_p[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall this: Buffer :: Y_Buffer.elementCount(tid : Tid, this, Buffer.elementCount_p[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall this: Buffer :: Y_Buffer.start(tid : Tid, this, Buffer.start_p[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall this: Buffer :: Y_Buffer.end(tid : Tid, this, Buffer.end_p[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall this: Buffer :: Y_Buffer._lock(tid : Tid, this, Buffer._lock_p[this] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall athis: Array.Buffer.T, index: int :: Y_Array.Buffer.T(tid : Tid, athis, index, Array.Buffer.T._elems_p[athis][index] , Buffer._state, Buffer.elementData, Buffer.elementCount, Buffer.start, Buffer.end, Buffer._lock, Array.Buffer.T._state, Array.Buffer.T._elems, Array.Buffer.T._length))
 && (forall _i : Buffer :: isShared(Buffer._state[_i]) ==> isShared(Buffer._state_p[_i]))           
 && (forall _i : Buffer :: isLocal(Buffer._state[_i], tid) <==> isLocal(Buffer._state_p[_i], tid))  
 && (forall _i : Array.Buffer.T :: isShared(Array.Buffer.T._state[_i]) ==> isShared(Array.Buffer.T._state_p[_i]))
 && (forall _i : Array.Buffer.T :: Array.Buffer.T._length[_i] == Array.Buffer.T._length_p[_i])      
 && (forall _i : Array.Buffer.T :: isLocal(Array.Buffer.T._state[_i], tid) <==> isLocal(Array.Buffer.T._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1126.1-1126.34: (6.2): Buffer.elementData failed Write-Write Right-Mover Check
// 1195.1-1195.30: (6.2): Buffer.elementData failed Write-Read Right-Mover Check
// 1268.1-1268.34: (6.2): Buffer.elementData failed Write-Write Left-Mover Check
// 1338.1-1338.30: (6.2): Buffer.elementData failed Write-Read Left-Mover Check
// 1405.1-1405.34: (6.2): Buffer.elementData failed Read-Write Right-Mover Check
// 1475.1-1475.34: (6.2): Buffer.elementData failed Read-Write Left-Mover Check
// 1544.1-1544.34: (7.2): Buffer.elementCount failed Write-Write Right-Mover Check
// 1613.1-1613.30: (7.2): Buffer.elementCount failed Write-Read Right-Mover Check
// 1686.1-1686.34: (7.2): Buffer.elementCount failed Write-Write Left-Mover Check
// 1756.1-1756.30: (7.2): Buffer.elementCount failed Write-Read Left-Mover Check
// 1823.1-1823.34: (7.2): Buffer.elementCount failed Read-Write Right-Mover Check
// 1893.1-1893.34: (7.2): Buffer.elementCount failed Read-Write Left-Mover Check
// 1962.1-1962.34: (8.2): Buffer.start failed Write-Write Right-Mover Check
// 2031.1-2031.30: (8.2): Buffer.start failed Write-Read Right-Mover Check
// 2104.1-2104.34: (8.2): Buffer.start failed Write-Write Left-Mover Check
// 2174.1-2174.30: (8.2): Buffer.start failed Write-Read Left-Mover Check
// 2241.1-2241.34: (8.2): Buffer.start failed Read-Write Right-Mover Check
// 2311.1-2311.34: (8.2): Buffer.start failed Read-Write Left-Mover Check
// 2380.1-2380.34: (9.2): Buffer.end failed Write-Write Right-Mover Check
// 2449.1-2449.30: (9.2): Buffer.end failed Write-Read Right-Mover Check
// 2522.1-2522.34: (9.2): Buffer.end failed Write-Write Left-Mover Check
// 2592.1-2592.30: (9.2): Buffer.end failed Write-Read Left-Mover Check
// 2659.1-2659.34: (9.2): Buffer.end failed Read-Write Right-Mover Check
// 2729.1-2729.34: (9.2): Buffer.end failed Read-Write Left-Mover Check
// 2804.1-2804.34: (4.2): Array Array.Buffer.T failed Write-Write Right-Mover Check
// 2879.1-2879.30: (4.2): Array Array.Buffer.T failed Write-Read Right-Mover Check
// 2958.1-2958.34: (4.2): Array Array.Buffer.T failed Write-Write Left-Mover Check
// 3034.1-3034.30: (4.2): Array Array.Buffer.T failed Write-Read Left-Mover Check
// 3107.1-3107.34: (4.2): Array Array.Buffer.T failed Read-Write Right-Mover Check
// 3183.1-3183.34: (4.2): Array Array.Buffer.T failed Read-Write Left-Mover Check
// 3264.1-3264.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.1)
// 3265.1-3265.101: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.2)
// 3266.1-3266.158: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case A.3)
// 3377.1-3377.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case C)
// 3493.1-3493.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case D)
// 3494.1-3494.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementData (case R)
// 3575.1-3575.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case F)
// 3576.1-3576.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case H)
// 3577.1-3577.146: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementData (case I)
// 3657.1-3657.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case J)
// 3658.1-3658.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case K)
// 3659.1-3659.99: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementData (case L)
// 3741.1-3741.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.1)
// 3742.1-3742.101: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.2)
// 3743.1-3743.158: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case A.3)
// 3854.1-3854.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case C)
// 3970.1-3970.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case D)
// 3971.1-3971.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case R)
// 4052.1-4052.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case F)
// 4053.1-4053.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case H)
// 4054.1-4054.146: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.elementCount (case I)
// 4134.1-4134.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case J)
// 4135.1-4135.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case K)
// 4136.1-4136.99: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementData (case L)
// 4218.1-4218.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.1)
// 4219.1-4219.101: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.2)
// 4220.1-4220.158: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case A.3)
// 4331.1-4331.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case C)
// 4447.1-4447.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case D)
// 4448.1-4448.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case R)
// 4529.1-4529.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case F)
// 4530.1-4530.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case H)
// 4531.1-4531.146: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.start (case I)
// 4611.1-4611.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case J)
// 4612.1-4612.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case K)
// 4613.1-4613.99: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementData (case L)
// 4695.1-4695.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.1)
// 4696.1-4696.101: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.2)
// 4697.1-4697.158: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case A.3)
// 4808.1-4808.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case C)
// 4924.1-4924.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case D)
// 4925.1-4925.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case R)
// 5006.1-5006.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case F)
// 5007.1-5007.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case H)
// 5008.1-5008.146: (6.2): Buffer.elementData is not Read-Write Stable with respect to Buffer.end (case I)
// 5088.1-5088.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case J)
// 5089.1-5089.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case K)
// 5090.1-5090.99: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementData (case L)
// 5177.1-5177.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.1)
// 5178.1-5178.101: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.2)
// 5179.1-5179.156: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case A.3)
// 5297.1-5297.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
// 5420.1-5420.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
// 5421.1-5421.144: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
// 5507.1-5507.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
// 5508.1-5508.136: (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
// 5509.1-5509.144: (6.2): Buffer.elementData is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
// 5594.1-5594.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case J)
// 5595.1-5595.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case K)
// 5596.1-5596.99: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementData (case L)
// 5678.1-5678.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
// 5679.1-5679.101: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
// 5680.1-5680.158: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
// 5791.1-5791.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case C)
// 5907.1-5907.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case D)
// 5908.1-5908.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementData (case R)
// 5989.1-5989.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case F)
// 5990.1-5990.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case H)
// 5991.1-5991.146: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementData (case I)
// 6071.1-6071.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case J)
// 6072.1-6072.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case K)
// 6073.1-6073.99: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.elementCount (case L)
// 6155.1-6155.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
// 6156.1-6156.101: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
// 6157.1-6157.158: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
// 6268.1-6268.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case C)
// 6384.1-6384.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case D)
// 6385.1-6385.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.elementCount (case R)
// 6466.1-6466.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case F)
// 6467.1-6467.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case H)
// 6468.1-6468.146: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.elementCount (case I)
// 6548.1-6548.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case J)
// 6549.1-6549.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case K)
// 6550.1-6550.99: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.elementCount (case L)
// 6632.1-6632.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
// 6633.1-6633.101: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
// 6634.1-6634.158: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
// 6745.1-6745.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case C)
// 6861.1-6861.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case D)
// 6862.1-6862.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case R)
// 6943.1-6943.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case F)
// 6944.1-6944.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case H)
// 6945.1-6945.146: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.start (case I)
// 7025.1-7025.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case J)
// 7026.1-7026.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case K)
// 7027.1-7027.99: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.elementCount (case L)
// 7109.1-7109.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
// 7110.1-7110.101: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
// 7111.1-7111.158: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
// 7222.1-7222.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case C)
// 7338.1-7338.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case D)
// 7339.1-7339.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case R)
// 7420.1-7420.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case F)
// 7421.1-7421.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case H)
// 7422.1-7422.146: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Buffer.end (case I)
// 7502.1-7502.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case J)
// 7503.1-7503.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case K)
// 7504.1-7504.99: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.elementCount (case L)
// 7591.1-7591.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.1)
// 7592.1-7592.101: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.2)
// 7593.1-7593.156: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case A.3)
// 7711.1-7711.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
// 7834.1-7834.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
// 7835.1-7835.144: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
// 7921.1-7921.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
// 7922.1-7922.136: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
// 7923.1-7923.144: (7.2): Buffer.elementCount is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
// 8008.1-8008.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case J)
// 8009.1-8009.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case K)
// 8010.1-8010.99: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.elementCount (case L)
// 8092.1-8092.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.1)
// 8093.1-8093.101: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.2)
// 8094.1-8094.158: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.start (case A.3)
// 8205.1-8205.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case C)
// 8321.1-8321.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case D)
// 8322.1-8322.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementData (case R)
// 8403.1-8403.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case F)
// 8404.1-8404.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case H)
// 8405.1-8405.146: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementData (case I)
// 8485.1-8485.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case J)
// 8486.1-8486.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case K)
// 8487.1-8487.99: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.start (case L)
// 8569.1-8569.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.1)
// 8570.1-8570.101: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.2)
// 8571.1-8571.158: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.start (case A.3)
// 8682.1-8682.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case C)
// 8798.1-8798.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case D)
// 8799.1-8799.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.elementCount (case R)
// 8880.1-8880.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case F)
// 8881.1-8881.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case H)
// 8882.1-8882.146: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.elementCount (case I)
// 8962.1-8962.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case J)
// 8963.1-8963.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case K)
// 8964.1-8964.99: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.start (case L)
// 9046.1-9046.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.1)
// 9047.1-9047.101: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.2)
// 9048.1-9048.158: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case A.3)
// 9159.1-9159.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case C)
// 9275.1-9275.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case D)
// 9276.1-9276.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.start (case R)
// 9357.1-9357.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case F)
// 9358.1-9358.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case H)
// 9359.1-9359.146: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.start (case I)
// 9439.1-9439.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case J)
// 9440.1-9440.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case K)
// 9441.1-9441.99: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.start (case L)
// 9523.1-9523.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.1)
// 9524.1-9524.101: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.2)
// 9525.1-9525.158: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case A.3)
// 9636.1-9636.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case C)
// 9752.1-9752.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case D)
// 9753.1-9753.144: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case R)
// 9834.1-9834.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case F)
// 9835.1-9835.136: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case H)
// 9836.1-9836.146: (8.2): Buffer.start is not Read-Write Stable with respect to Buffer.end (case I)
// 9916.1-9916.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case J)
// 9917.1-9917.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case K)
// 9918.1-9918.99: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.start (case L)
// 10005.1-10005.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.1)
// 10006.1-10006.101: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.2)
// 10007.1-10007.156: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case A.3)
// 10125.1-10125.140: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
// 10248.1-10248.144: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
// 10249.1-10249.144: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
// 10335.1-10335.136: (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
// 10336.1-10336.136: (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
// 10337.1-10337.144: (8.2): Buffer.start is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
// 10422.1-10422.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case J)
// 10423.1-10423.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case K)
// 10424.1-10424.99: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.start (case L)
// 10506.1-10506.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.1)
// 10507.1-10507.101: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.2)
// 10508.1-10508.158: (6.2): Buffer.elementData is not Write-Write Stable with respect to Buffer.end (case A.3)
// 10619.1-10619.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case C)
// 10735.1-10735.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case D)
// 10736.1-10736.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementData (case R)
// 10817.1-10817.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case F)
// 10818.1-10818.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case H)
// 10819.1-10819.146: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementData (case I)
// 10899.1-10899.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case J)
// 10900.1-10900.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case K)
// 10901.1-10901.99: (6.2): Buffer.elementData is not Write-Read Stable with respect to Buffer.end (case L)
// 10983.1-10983.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.1)
// 10984.1-10984.101: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.2)
// 10985.1-10985.158: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Buffer.end (case A.3)
// 11096.1-11096.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case C)
// 11212.1-11212.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case D)
// 11213.1-11213.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.elementCount (case R)
// 11294.1-11294.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case F)
// 11295.1-11295.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case H)
// 11296.1-11296.146: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.elementCount (case I)
// 11376.1-11376.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case J)
// 11377.1-11377.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case K)
// 11378.1-11378.99: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Buffer.end (case L)
// 11460.1-11460.140: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.1)
// 11461.1-11461.101: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.2)
// 11462.1-11462.158: (8.2): Buffer.start is not Write-Write Stable with respect to Buffer.end (case A.3)
// 11573.1-11573.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case C)
// 11689.1-11689.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case D)
// 11690.1-11690.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.start (case R)
// 11771.1-11771.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case F)
// 11772.1-11772.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case H)
// 11773.1-11773.146: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.start (case I)
// 11853.1-11853.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case J)
// 11854.1-11854.136: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case K)
// 11855.1-11855.99: (8.2): Buffer.start is not Write-Read Stable with respect to Buffer.end (case L)
// 11937.1-11937.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.1)
// 11938.1-11938.101: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.2)
// 11939.1-11939.158: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case A.3)
// 12050.1-12050.140: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case C)
// 12166.1-12166.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case D)
// 12167.1-12167.144: (9.2): Buffer.end is not Write-Write Stable with respect to Buffer.end (case R)
// 12248.1-12248.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case F)
// 12249.1-12249.136: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case H)
// 12250.1-12250.146: (9.2): Buffer.end is not Read-Write Stable with respect to Buffer.end (case I)
// 12330.1-12330.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case J)
// 12331.1-12331.136: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case K)
// 12332.1-12332.99: (9.2): Buffer.end is not Write-Read Stable with respect to Buffer.end (case L)
// 12419.1-12419.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.1)
// 12420.1-12420.101: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.2)
// 12421.1-12421.156: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case A.3)
// 12539.1-12539.140: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
// 12662.1-12662.144: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
// 12663.1-12663.144: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
// 12749.1-12749.136: (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
// 12750.1-12750.136: (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
// 12751.1-12751.144: (9.2): Buffer.end is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
// 12836.1-12836.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case J)
// 12837.1-12837.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case K)
// 12838.1-12838.99: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Buffer.end (case L)
// 12925.1-12925.140: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
// 12926.1-12926.101: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
// 12927.1-12927.156: (6.2): Buffer.elementData is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
// 13045.1-13045.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case C)
// 13168.1-13168.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case D)
// 13169.1-13169.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementData (case R)
// 13255.1-13255.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case F)
// 13256.1-13256.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case H)
// 13257.1-13257.144: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementData (case I)
// 13342.1-13342.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
// 13343.1-13343.136: (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
// 13344.1-13344.99: (6.2): Buffer.elementData is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
// 13431.1-13431.140: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
// 13432.1-13432.101: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
// 13433.1-13433.156: (7.2): Buffer.elementCount is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
// 13551.1-13551.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case C)
// 13674.1-13674.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case D)
// 13675.1-13675.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.elementCount (case R)
// 13761.1-13761.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case F)
// 13762.1-13762.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case H)
// 13763.1-13763.144: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.elementCount (case I)
// 13848.1-13848.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
// 13849.1-13849.136: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
// 13850.1-13850.99: (7.2): Buffer.elementCount is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
// 13937.1-13937.140: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
// 13938.1-13938.101: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
// 13939.1-13939.156: (8.2): Buffer.start is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
// 14057.1-14057.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case C)
// 14180.1-14180.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case D)
// 14181.1-14181.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.start (case R)
// 14267.1-14267.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case F)
// 14268.1-14268.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case H)
// 14269.1-14269.144: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.start (case I)
// 14354.1-14354.136: (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
// 14355.1-14355.136: (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
// 14356.1-14356.99: (8.2): Buffer.start is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
// 14443.1-14443.140: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
// 14444.1-14444.101: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
// 14445.1-14445.156: (9.2): Buffer.end is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
// 14563.1-14563.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case C)
// 14686.1-14686.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case D)
// 14687.1-14687.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Buffer.end (case R)
// 14773.1-14773.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case F)
// 14774.1-14774.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case H)
// 14775.1-14775.144: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Buffer.end (case I)
// 14860.1-14860.136: (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
// 14861.1-14861.136: (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
// 14862.1-14862.99: (9.2): Buffer.end is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
// 14954.1-14954.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.1)
// 14955.1-14955.101: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.2)
// 14956.1-14956.156: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case A.3)
// 15081.1-15081.140: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case C)
// 15211.1-15211.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case D)
// 15212.1-15212.144: (4.2): Array Array.Buffer.T is not Write-Write Stable with respect to Array Array.Buffer.T (case R)
// 15303.1-15303.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case F)
// 15304.1-15304.136: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case H)
// 15305.1-15305.144: (4.2): Array Array.Buffer.T is not Read-Write Stable with respect to Array Array.Buffer.T (case I)
// 15395.1-15395.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case J)
// 15396.1-15396.136: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case K)
// 15397.1-15397.99: (4.2): Array Array.Buffer.T is not Write-Read Stable with respect to Array Array.Buffer.T (case L)
// 15433.1-15458.2: (6.2): yields_as clause for Buffer.elementData is not valid
// 15463.1-15483.2: (6.2): yields_as clause for Buffer.elementData is not reflexive
// 15489.1-15529.2: (6.2): yields_as clause for Buffer.elementData is not transitive
// 15548.1-15573.2: (7.2): yields_as clause for Buffer.elementCount is not valid
// 15578.1-15598.2: (7.2): yields_as clause for Buffer.elementCount is not reflexive
// 15604.1-15644.2: (7.2): yields_as clause for Buffer.elementCount is not transitive
// 15663.1-15688.2: (8.2): yields_as clause for Buffer.start is not valid
// 15693.1-15713.2: (8.2): yields_as clause for Buffer.start is not reflexive
// 15719.1-15759.2: (8.2): yields_as clause for Buffer.start is not transitive
// 15778.1-15803.2: (9.2): yields_as clause for Buffer.end is not valid
// 15808.1-15828.2: (9.2): yields_as clause for Buffer.end is not reflexive
// 15834.1-15874.2: (9.2): yields_as clause for Buffer.end is not transitive
// 15894.1-15919.2: (7.32): yields_as clause for Buffer._lock is not valid
// 15924.1-15944.2: (7.32): yields_as clause for Buffer._lock is not reflexive
// 15950.1-15990.2: (7.32): yields_as clause for Buffer._lock is not transitive
// 16008.1-16037.2: (4.2): yields_as clause for Array.Buffer.T is not valid
// 16038.1-16064.2: (4.2): yields_as clause for Array.Buffer.T is not reflexive
// 16069.1-16113.2: (4.2): yields_as clause for Array.Buffer.T is not transitive
