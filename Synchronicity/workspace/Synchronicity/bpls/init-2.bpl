                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/init-2.sink:                            
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Key {                                                                                     
                                                                                                    
    }                                                                                               
    class Value {                                                                                   
       int x isLocal(this, tid)                                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      invariant  this.x == 3;                                                                       
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        this.x := 0;                                                                                
        int i;                                                                                      
        i = 0;                                                                                      
        while (i != 3)                                                                              
          invariant this.x == i;                                                                    
          {                                                                                         
          int t;                                                                                    
          t := this.x;                                                                              
          t = t + 1;                                                                                
          this.x := t;                                                                              
          i = i + 1;                                                                                
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class HashEntry {                                                                               
                                                                                                    
    }                                                                                               
    class Segment {                                                                                 
      array SegmentArray = Value[isLocal(this, tid)                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [Segment.SegmentArray{this}] segments isLocal(this, tid)                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Value.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [Segment.SegmentArray{this}] segments;                                                      
        segments = new [Segment.SegmentArray{this}](16);                                            
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < 16)                                                                              
          invariant isLocal(segments, tid);                                                         
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Value.null && isShared(segments[k]);
          {                                                                                         
          Value seg;                                                                                
          seg = new Value();                                                                        
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class ConcurrentHashMap {                                                                       
      array SegmentArray = Segment[isLocal(this, tid)                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [ConcurrentHashMap.SegmentArray{this}] segments isLocal(this, tid)                           
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Segment.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [ConcurrentHashMap.SegmentArray{this}] segments;                                            
        segments = new [ConcurrentHashMap.SegmentArray{this}](16);                                  
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < segments.length)                                                                 
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Segment.null && isShared(segments[k]);
          invariant isLocal(segments, tid);                                                         
          {                                                                                         
          Segment seg;                                                                              
          seg = new Segment();                                                                      
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void run() {                                                                           
        ConcurrentHashMap c;                                                                        
        c = new ConcurrentHashMap();                                                                
        c.init()                                                                                    
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Key {                                                                                     
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Value {                                                                                   
       int x isLocal(this, tid)                                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.x == 3;                                                                       
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        this.x := 0;                                                                                
        int i;                                                                                      
        i = 0;                                                                                      
        while (i != 3)                                                                              
          invariant this.x == i;                                                                    
          {                                                                                         
          int t;                                                                                    
          t := this.x;                                                                              
          t = t + 1;                                                                                
          this.x := t;                                                                              
          i = i + 1;                                                                                
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class HashEntry {                                                                               
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Segment {                                                                                 
      array SegmentArray = Value[isLocal(this, tid)                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [Segment.SegmentArray{this}] segments isLocal(this, tid)                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Value.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [Segment.SegmentArray{this}] segments;                                                      
        segments = new [Segment.SegmentArray{this}](16);                                            
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < 16)                                                                              
          invariant isLocal(segments, tid);                                                         
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Value.null && isShared(segments[k]);
          {                                                                                         
          Value seg;                                                                                
          seg = new Value();                                                                        
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class ConcurrentHashMap {                                                                       
      array SegmentArray = Segment[isLocal(this, tid)                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [ConcurrentHashMap.SegmentArray{this}] segments isLocal(this, tid)                           
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Segment.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [ConcurrentHashMap.SegmentArray{this}] segments;                                            
        segments = new [ConcurrentHashMap.SegmentArray{this}](16);                                  
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < segments.length)                                                                 
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Segment.null && isShared(segments[k]);
          invariant isLocal(segments, tid);                                                         
          {                                                                                         
          Segment seg;                                                                              
          seg = new Segment();                                                                      
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void run() {                                                                           
        ConcurrentHashMap c;                                                                        
        c = new ConcurrentHashMap();                                                                
        c.init()                                                                                    
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Key {                                                                                     
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Value {                                                                                   
       int x isLocal(this, tid)                                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.x == 3;                                                                       
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        this.x := 0;                                                                                
        int i;                                                                                      
        i = 0;                                                                                      
        while (i != 3)                                                                              
          invariant this.x == i;                                                                    
          {                                                                                         
          int t;                                                                                    
          t := this.x;                                                                              
          t = t + 1;                                                                                
          this.x := t;                                                                              
          i = i + 1;                                                                                
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class HashEntry {                                                                               
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Segment {                                                                                 
      array SegmentArray = Value[isLocal(this, tid)                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [Segment.SegmentArray{this}] segments isLocal(this, tid)                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Value.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [Segment.SegmentArray{this}] segments;                                                      
        segments = new [Segment.SegmentArray{this}](16);                                            
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < 16)                                                                              
          invariant isLocal(segments, tid);                                                         
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Value.null && isShared(segments[k]);
          {                                                                                         
          Value seg;                                                                                
          seg = new Value();                                                                        
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class ConcurrentHashMap {                                                                       
      array SegmentArray = Segment[isLocal(this, tid)                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [ConcurrentHashMap.SegmentArray{this}] segments isLocal(this, tid)                           
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Segment.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [ConcurrentHashMap.SegmentArray{this}] segments;                                            
        segments = new [ConcurrentHashMap.SegmentArray{this}](16);                                  
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < segments.length)                                                                 
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Segment.null && isShared(segments[k]);
          invariant isLocal(segments, tid);                                                         
          {                                                                                         
          Segment seg;                                                                              
          seg = new Segment();                                                                      
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void run() {                                                                           
        ConcurrentHashMap c;                                                                        
        c = new ConcurrentHashMap();                                                                
        {                                                                                           
          inlined c.init();                                                                         
          exit$196: {                                                                               
            ConcurrentHashMap this$196;                                                             
            this$196 = c;                                                                           
            {                                                                                       
              [ConcurrentHashMap.SegmentArray{this$196}] segments$196;                              
              segments$196 = new [ConcurrentHashMap.SegmentArray{this$196}](16);                    
              int i$196;                                                                            
              i$196 = 0;                                                                            
              while (i$196 < segments$196.length)                                                   
                invariant forall int k$196 ::0 <= k$196 && k$196 < i$196 ==> segments$196[k$196] != Segment.null && isShared(segments$196[k$196]);
                invariant isLocal(segments$196, tid);                                               
                {                                                                                   
                Segment seg$196;                                                                    
                seg$196 = new Segment();                                                            
                {                                                                                   
                  inlined seg$196.init();                                                           
                  exit$197: {                                                                       
                    Segment this$197;                                                               
                    this$197 = seg$196;                                                             
                    {                                                                               
                      [Segment.SegmentArray{this$197}] segments$197;                                
                      segments$197 = new [Segment.SegmentArray{this$197}](16);                      
                      int i$197;                                                                    
                      i$197 = 0;                                                                    
                      while (i$197 < 16)                                                            
                        invariant isLocal(segments$197, tid);                                       
                        invariant forall int k$197 ::0 <= k$197 && k$197 < i$197 ==> segments$197[k$197] != Value.null && isShared(segments$197[k$197]);
                        {                                                                           
                        Value seg$197;                                                              
                        seg$197 = new Value();                                                      
                        {                                                                           
                          inlined seg$197.init();                                                   
                          exit$198: {                                                               
                            Value this$198;                                                         
                            this$198 = seg$197;                                                     
                            {                                                                       
                              this$198.x := 0;                                                      
                              int i$198;                                                            
                              i$198 = 0;                                                            
                              while (i$198 != 3)                                                    
                                invariant this$198.x == i$198;                                      
                                {                                                                   
                                int t$198;                                                          
                                t$198 := this$198.x;                                                
                                t$198 = t$198 + 1;                                                  
                                this$198.x := t$198;                                                
                                i$198 = i$198 + 1;                                                  
                              }                                                                     
                              {                                                                     
                                break exit$198;                                                     
                              }                                                                     
                            }                                                                       
                          }                                                                         
                          inlined return;                                                           
                        }                                                                           
                        segments$197[i$197] := seg$197;                                             
                        i$197 = i$197 + 1;                                                          
                      }                                                                             
                      this$197.segments := segments$197;                                            
                      {                                                                             
                        break exit$197;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                segments$196[i$196] := seg$196;                                                     
                i$196 = i$196 + 1;                                                                  
              }                                                                                     
              this$196.segments := segments$196;                                                    
              {                                                                                     
                break exit$196;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Key {                                                                                     
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Value {                                                                                   
       int x isLocal(this, tid)                                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.x == 3;                                                                       
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        this.x := 0;                                                                                
        int i;                                                                                      
        i = 0;                                                                                      
        while (i != 3)                                                                              
          invariant this.x == i;                                                                    
          {                                                                                         
          int t;                                                                                    
          t := this.x;                                                                              
          t = t + 1;                                                                                
          this.x := t;                                                                              
          i = i + 1;                                                                                
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class HashEntry {                                                                               
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
    }                                                                                               
    class Segment {                                                                                 
      array SegmentArray = Value[isLocal(this, tid)                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [Segment.SegmentArray{this}] segments isLocal(this, tid)                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Value.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [Segment.SegmentArray{this}] segments;                                                      
        segments = new [Segment.SegmentArray{this}](16);                                            
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < 16)                                                                              
          invariant isLocal(segments, tid);                                                         
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Value.null && isShared(segments[k]);
          {                                                                                         
          Value seg;                                                                                
          seg = new Value();                                                                        
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class ConcurrentHashMap {                                                                       
      array SegmentArray = Segment[isLocal(this, tid)                                               
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E]                                                                            
                                                                                                    
       [ConcurrentHashMap.SegmentArray{this}] segments isLocal(this, tid)                           
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall int i ::0 <= i && i < this.segments.length ==> this.segments[i] != Segment.null;
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      void init() {                                                                                 
        [ConcurrentHashMap.SegmentArray{this}] segments;                                            
        segments = new [ConcurrentHashMap.SegmentArray{this}](16);                                  
        int i;                                                                                      
        i = 0;                                                                                      
        while (i < segments.length)                                                                 
          invariant forall int k ::0 <= k && k < i ==> segments[k] != Segment.null && isShared(segments[k]);
          invariant isLocal(segments, tid);                                                         
          {                                                                                         
          Segment seg;                                                                              
          seg = new Segment();                                                                      
          seg.init()                                                                                
          segments[i] := seg;                                                                       
          i = i + 1;                                                                                
        }                                                                                           
        this.segments := segments;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
                                                                                                    
      }                                                                                             
      public void run() {                                                                           
        ConcurrentHashMap c;                                                                        
        c = new ConcurrentHashMap();                                                                
        {                                                                                           
          inlined c.init();                                                                         
          exit$196: {                                                                               
            ConcurrentHashMap this$196;                                                             
            this$196 = c;                                                                           
            {                                                                                       
              [ConcurrentHashMap.SegmentArray{this$196}] segments$196;                              
              segments$196 = new [ConcurrentHashMap.SegmentArray{this$196}](16);                    
              int i$196;                                                                            
              i$196 = 0;                                                                            
              while (i$196 < segments$196.length)                                                   
                invariant forall int k$196 ::0 <= k$196 && k$196 < i$196 ==> segments$196[k$196] != Segment.null && isShared(segments$196[k$196]);
                invariant isLocal(segments$196, tid);                                               
                {                                                                                   
                Segment seg$196;                                                                    
                seg$196 = new Segment();                                                            
                {                                                                                   
                  inlined seg$196.init();                                                           
                  exit$197: {                                                                       
                    Segment this$197;                                                               
                    this$197 = seg$196;                                                             
                    {                                                                               
                      [Segment.SegmentArray{this$197}] segments$197;                                
                      segments$197 = new [Segment.SegmentArray{this$197}](16);                      
                      int i$197;                                                                    
                      i$197 = 0;                                                                    
                      while (i$197 < 16)                                                            
                        invariant isLocal(segments$197, tid);                                       
                        invariant forall int k$197 ::0 <= k$197 && k$197 < i$197 ==> segments$197[k$197] != Value.null && isShared(segments$197[k$197]);
                        {                                                                           
                        Value seg$197;                                                              
                        seg$197 = new Value();                                                      
                        {                                                                           
                          inlined seg$197.init();                                                   
                          exit$198: {                                                               
                            Value this$198;                                                         
                            this$198 = seg$197;                                                     
                            {                                                                       
                              this$198.x := 0;                                                      
                              int i$198;                                                            
                              i$198 = 0;                                                            
                              while (i$198 != 3)                                                    
                                invariant this$198.x == i$198;                                      
                                {                                                                   
                                int t$198;                                                          
                                t$198 := this$198.x;                                                
                                t$198 = t$198 + 1;                                                  
                                this$198.x := t$198;                                                
                                i$198 = i$198 + 1;                                                  
                              }                                                                     
                              {                                                                     
                                break exit$198;                                                     
                              }                                                                     
                            }                                                                       
                          }                                                                         
                          inlined return;                                                           
                        }                                                                           
                        segments$197[i$197] := seg$197;                                             
                        i$197 = i$197 + 1;                                                          
                      }                                                                             
                      this$197.segments := segments$197;                                            
                      {                                                                             
                        break exit$197;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                segments$196[i$196] := seg$196;                                                     
                i$196 = i$196 + 1;                                                                  
              }                                                                                     
              this$196.segments := segments$196;                                                    
              {                                                                                     
                break exit$196;                                                                     
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Key ***/                                                                            
                                                                                                    
type Key;                                                                                           
const unique Key.null: Key;                                                                         
var Key._state: [Key]State;                                                                         
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Key._lock: [Key]Tid;                                                                            
                                                                                                    
function {:inline} ReadEval.Key._lock(tid: Tid,this : Key,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Key._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Key._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Key._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Key._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Key._lock(tid: Tid,this : Key,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Key._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Key._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Key._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Key._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Value ***/                                                                          
                                                                                                    
type Value;                                                                                         
const unique Value.null: Value;                                                                     
var Value._state: [Value]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Value.x: [Value]int;                                                                            
                                                                                                    
function {:inline} ReadEval.Value.x(tid: Tid,this : Value,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Value._state[this], tid)) then                                                         
  if (isLocal(Value._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Value.x(tid: Tid,this : Value,newValue: int,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Value._state[this], tid)) then                                                         
  if (isLocal(Value._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Value._lock: [Value]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Value._lock(tid: Tid,this : Value,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Value._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Value._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Value._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Value._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Value._lock(tid: Tid,this : Value,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Value._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Value._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Value._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Value._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Value.2243228(tid: Tid,this : Value,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (Value.x[this]==3)                                                                                 
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl HashEntry ***/                                                                      
                                                                                                    
type HashEntry;                                                                                     
const unique HashEntry.null: HashEntry;                                                             
var HashEntry._state: [HashEntry]State;                                                             
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var HashEntry._lock: [HashEntry]Tid;                                                                
                                                                                                    
function {:inline} ReadEval.HashEntry._lock(tid: Tid,this : HashEntry,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(HashEntry._state[this], tid)) then                                                     
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((HashEntry._lock[this]==tid)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((HashEntry._lock[this]==Tid.null)&&(newValue==tid))) then                                   
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((HashEntry._lock[this]==tid)&&(newValue==Tid.null))) then                                  
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.HashEntry._lock(tid: Tid,this : HashEntry,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(HashEntry._state[this], tid)) then                                                     
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((HashEntry._lock[this]==tid)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((HashEntry._lock[this]==Tid.null)&&(newValue==tid))) then                                   
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((HashEntry._lock[this]==tid)&&(newValue==Tid.null))) then                                  
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Segment ***/                                                                        
                                                                                                    
type Segment;                                                                                       
const unique Segment.null: Segment;                                                                 
var Segment._state: [Segment]State;                                                                 
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Segment.segments: [Segment]Array.Segment.SegmentArray;                                          
                                                                                                    
function {:inline} ReadEval.Segment.segments(tid: Tid,this : Segment,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.Segment.SegmentArray.null;                                                  
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isLocal(Segment._state[this], tid)) then                                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Segment.segments(tid: Tid,this : Segment,newValue: Array.Segment.SegmentArray,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isLocal(Segment._state[this], tid)) then                                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Segment._lock: [Segment]Tid;                                                                    
                                                                                                    
function {:inline} ReadEval.Segment._lock(tid: Tid,this : Segment,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Segment._lock[this]==tid)) then                                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Segment._lock[this]==Tid.null)&&(newValue==tid))) then                                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Segment._lock[this]==tid)&&(newValue==Tid.null))) then                                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Segment._lock(tid: Tid,this : Segment,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Segment._lock[this]==tid)) then                                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Segment._lock[this]==Tid.null)&&(newValue==tid))) then                                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Segment._lock[this]==tid)&&(newValue==Tid.null))) then                                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Segment.2243551(tid: Tid,this : Segment,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (forall i: int ::  ((((0<=i)&&(i<Array.Segment.SegmentArray._length[Segment.segments[this]]))==>(Array.Segment.SegmentArray._elems[Segment.segments[this]][i]!=Value.null))))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/*** Array Array.Segment.SegmentArray ***/                                                          
                                                                                                    
type Array.Segment.SegmentArray;                                                                    
const unique Array.Segment.SegmentArray.null: Array.Segment.SegmentArray;                           
var Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State;                           
                                                                                                    
const Array.Segment.SegmentArray._this : [Array.Segment.SegmentArray]Segment;                       
const Array.Segment.SegmentArray._length : [Array.Segment.SegmentArray]int;                         
var Array.Segment.SegmentArray._elems  : [Array.Segment.SegmentArray]([int]Value);                  
                                                                                                    
axiom (forall $this : Array.Segment.SegmentArray :: Array.Segment.SegmentArray._length[$this] >= 0);
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.Segment.SegmentArray: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.Segment.SegmentArray(tid: Tid,this : Segment,athis : Array.Segment.SegmentArray,index : int,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isLocal(Segment._state[this], tid)) then                                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.Segment.SegmentArray: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.Segment.SegmentArray(tid: Tid,this : Segment,athis : Array.Segment.SegmentArray,index : int,newValue: Value,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Segment._state[this], tid)) then                                                       
  if (isLocal(Segment._state[this], tid)) then                                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl ConcurrentHashMap ***/                                                              
                                                                                                    
type ConcurrentHashMap;                                                                             
const unique ConcurrentHashMap.null: ConcurrentHashMap;                                             
var ConcurrentHashMap._state: [ConcurrentHashMap]State;                                             
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;            
                                                                                                    
function {:inline} ReadEval.ConcurrentHashMap.segments(tid: Tid,this : ConcurrentHashMap,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.ConcurrentHashMap.SegmentArray.null;                                        
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isLocal(ConcurrentHashMap._state[this], tid)) then                                            
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.ConcurrentHashMap.segments(tid: Tid,this : ConcurrentHashMap,newValue: Array.ConcurrentHashMap.SegmentArray,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isLocal(ConcurrentHashMap._state[this], tid)) then                                            
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var ConcurrentHashMap._lock: [ConcurrentHashMap]Tid;                                                
                                                                                                    
function {:inline} ReadEval.ConcurrentHashMap._lock(tid: Tid,this : ConcurrentHashMap,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((ConcurrentHashMap._lock[this]==tid)) then                                                   
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((ConcurrentHashMap._lock[this]==Tid.null)&&(newValue==tid))) then                           
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((ConcurrentHashMap._lock[this]==tid)&&(newValue==Tid.null))) then                          
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.ConcurrentHashMap._lock(tid: Tid,this : ConcurrentHashMap,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((ConcurrentHashMap._lock[this]==tid)) then                                                   
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((ConcurrentHashMap._lock[this]==Tid.null)&&(newValue==tid))) then                           
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((ConcurrentHashMap._lock[this]==tid)&&(newValue==Tid.null))) then                          
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.ConcurrentHashMap.2243791(tid: Tid,this : ConcurrentHashMap,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
 (forall i: int ::  ((((0<=i)&&(i<Array.ConcurrentHashMap.SegmentArray._length[ConcurrentHashMap.segments[this]]))==>(Array.ConcurrentHashMap.SegmentArray._elems[ConcurrentHashMap.segments[this]][i]!=Segment.null))))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/*** Array Array.ConcurrentHashMap.SegmentArray ***/                                                
                                                                                                    
type Array.ConcurrentHashMap.SegmentArray;                                                          
const unique Array.ConcurrentHashMap.SegmentArray.null: Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State;       
                                                                                                    
const Array.ConcurrentHashMap.SegmentArray._this : [Array.ConcurrentHashMap.SegmentArray]ConcurrentHashMap;
const Array.ConcurrentHashMap.SegmentArray._length : [Array.ConcurrentHashMap.SegmentArray]int;     
var Array.ConcurrentHashMap.SegmentArray._elems  : [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
                                                                                                    
axiom (forall $this : Array.ConcurrentHashMap.SegmentArray :: Array.ConcurrentHashMap.SegmentArray._length[$this] >= 0);
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.ConcurrentHashMap.SegmentArray: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.ConcurrentHashMap.SegmentArray(tid: Tid,this : ConcurrentHashMap,athis : Array.ConcurrentHashMap.SegmentArray,index : int,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isLocal(ConcurrentHashMap._state[this], tid)) then                                            
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.ConcurrentHashMap.SegmentArray: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.ConcurrentHashMap.SegmentArray(tid: Tid,this : ConcurrentHashMap,athis : Array.ConcurrentHashMap.SegmentArray,index : int,newValue: Segment,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(ConcurrentHashMap._state[this], tid)) then                                             
  if (isLocal(ConcurrentHashMap._state[this], tid)) then                                            
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Main ***/                                                                           
                                                                                                    
type Main;                                                                                          
const unique Main.null: Main;                                                                       
var Main._state: [Main]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Main._lock: [Main]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Main._lock(tid: Tid,this : Main,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Main._lock(tid: Tid,this : Main,newValue: Tid,Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Main.run(tid:Tid, this : Main)                                                           
modifies Key._state;                                                                                
modifies Key._lock;                                                                                 
modifies Value._state;                                                                              
modifies Value.x;                                                                                   
modifies Value._lock;                                                                               
modifies HashEntry._state;                                                                          
modifies HashEntry._lock;                                                                           
modifies Segment._state;                                                                            
modifies Segment.segments;                                                                          
modifies Segment._lock;                                                                             
modifies Array.Segment.SegmentArray._state;                                                         
modifies Array.Segment.SegmentArray._elems;                                                         
modifies ConcurrentHashMap._state;                                                                  
modifies ConcurrentHashMap.segments;                                                                
modifies ConcurrentHashMap._lock;                                                                   
modifies Array.ConcurrentHashMap.SegmentArray._state;                                               
modifies Array.ConcurrentHashMap.SegmentArray._elems;                                               
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (73.5): Bad tid
requires isShared(Main._state[this]);                                                                      // (73.5): this is not global
                                                                                                    
requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
ensures  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
ensures  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
ensures  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.5): Object invariant may not hold.
{                                                                                                   
 var seg$1972244928_bottom: Value;                                                                  
 var this$1982244886: Value;                                                                        
 var Array.ConcurrentHashMap.SegmentArray._elems2244983: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var ConcurrentHashMap.segments2244928: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var this$1962245044: ConcurrentHashMap;                                                            
 var this2245054: Main;                                                                             
 var i$1982244914: int;                                                                             
 var this2244999: Main;                                                                             
 var Main._state2244986: [Main]State;                                                               
 var ConcurrentHashMap._state2244986: [ConcurrentHashMap]State;                                     
 var HashEntry._lock2244928: [HashEntry]Tid;                                                        
 var Main._lock2245041: [Main]Tid;                                                                  
 var Array.ConcurrentHashMap.SegmentArray._state2244928_bottom: [Array.ConcurrentHashMap.SegmentArray]State;
 var path2244914: int;                                                                              
 var this$1972244904: Segment;                                                                      
 var tid2244983_bottom: Tid;                                                                        
 var $pc2244928_bottom: Phase;                                                                      
 var i$1972244928_bottom: int;                                                                      
 var Segment._state2244983_bottom: [Segment]State;                                                  
 var i$1982244904: int;                                                                             
 var tid2244914: Tid;                                                                               
 var Array.Segment.SegmentArray._length2244886: [Array.Segment.SegmentArray]int;                    
 var Value._lock2245041: [Value]Tid;                                                                
 var Segment._lock2244928: [Segment]Tid;                                                            
 var seg$1962244999: Segment;                                                                       
 var i$1972244986: int;                                                                             
 var moverPath2244904: MoverPath;                                                                   
 var Key._state2245044: [Key]State;                                                                 
 var HashEntry._state2245054: [HashEntry]State;                                                     
 var Array.ConcurrentHashMap.SegmentArray._length2244904: [Array.ConcurrentHashMap.SegmentArray]int;
 var ConcurrentHashMap._state2245054: [ConcurrentHashMap]State;                                     
 var Value._state2245054: [Value]State;                                                             
 var Value._lock2244986: [Value]Tid;                                                                
 var Segment.segments2244928: [Segment]Array.Segment.SegmentArray;                                  
 var c2245041_bottom: ConcurrentHashMap;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state2244983_bottom: [Array.ConcurrentHashMap.SegmentArray]State;
 var Key._lock2244914: [Key]Tid;                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state2244941: [Array.ConcurrentHashMap.SegmentArray]State;
 var moverPath2244886: MoverPath;                                                                   
 var Segment._state2245044: [Segment]State;                                                         
 var this$1972244886: Segment;                                                                      
 var i$198: int;                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._length2244886: [Array.ConcurrentHashMap.SegmentArray]int;
 var Array.Segment.SegmentArray._length2245041_bottom: [Array.Segment.SegmentArray]int;             
 var Main._lock2244983_bottom: [Main]Tid;                                                           
 var segments$1962244928: Array.ConcurrentHashMap.SegmentArray;                                     
 var HashEntry._state2244928_bottom: [HashEntry]State;                                              
 var ConcurrentHashMap._lock2244928_bottom: [ConcurrentHashMap]Tid;                                 
 var $pc2244904: Phase;                                                                             
 var Array.Segment.SegmentArray._length2244983: [Array.Segment.SegmentArray]int;                    
 var i$1962244941: int;                                                                             
 var this$1972244983_bottom: Segment;                                                               
 var moverPath2244914: MoverPath;                                                                   
 var ConcurrentHashMap._state2244983_bottom: [ConcurrentHashMap]State;                              
 var ConcurrentHashMap._state2244928_bottom: [ConcurrentHashMap]State;                              
 var this2244983_bottom: Main;                                                                      
 var HashEntry._lock2244928_bottom: [HashEntry]Tid;                                                 
 var Main._lock2244941: [Main]Tid;                                                                  
 var segments$1962245044: Array.ConcurrentHashMap.SegmentArray;                                     
 var this2244986: Main;                                                                             
 var Array.Segment.SegmentArray._length2245044: [Array.Segment.SegmentArray]int;                    
 var i$1962244928: int;                                                                             
 var c2244914: ConcurrentHashMap;                                                                   
 var ConcurrentHashMap._state2244928: [ConcurrentHashMap]State;                                     
 var mover2244914: Mover;                                                                           
 var Key._lock2244941: [Key]Tid;                                                                    
 var ConcurrentHashMap._lock2245054: [ConcurrentHashMap]Tid;                                        
 var Main._state2245044: [Main]State;                                                               
 var ConcurrentHashMap.segments2244986: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var ConcurrentHashMap.segments2244999: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Array.ConcurrentHashMap.SegmentArray._elems2244928_bottom: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var tid2244941: Tid;                                                                               
 var this$1982244914: Value;                                                                        
 var Array.ConcurrentHashMap.SegmentArray._elems2244914: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Array.ConcurrentHashMap.SegmentArray._elems2244941: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Array.Segment.SegmentArray._length2244999: [Array.Segment.SegmentArray]int;                    
 var Value._lock2244886: [Value]Tid;                                                                
 var Array.Segment.SegmentArray._state2244914: [Array.Segment.SegmentArray]State;                   
 var ConcurrentHashMap._lock2244983_bottom: [ConcurrentHashMap]Tid;                                 
 var Array.Segment.SegmentArray._state2244928: [Array.Segment.SegmentArray]State;                   
 var HashEntry._lock2244983_bottom: [HashEntry]Tid;                                                 
 var Segment._lock2244928_bottom: [Segment]Tid;                                                     
 var this2245041_bottom: Main;                                                                      
 var Segment._state2244904: [Segment]State;                                                         
 var this$1972244941: Segment;                                                                      
 var path2245044: int;                                                                              
 var phase2244928: Phase;                                                                           
 var HashEntry._lock2244914: [HashEntry]Tid;                                                        
 var Main._lock2244928: [Main]Tid;                                                                  
 var HashEntry._state2245041: [HashEntry]State;                                                     
 var segments$1972244941: Array.Segment.SegmentArray;                                               
 var HashEntry._lock2245054: [HashEntry]Tid;                                                        
 var Array.Segment.SegmentArray._length2244983_bottom: [Array.Segment.SegmentArray]int;             
 var ConcurrentHashMap._lock2244983: [ConcurrentHashMap]Tid;                                        
 var $recorded.state2244983_bottom: int;                                                            
 var Key._state2244983: [Key]State;                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state2244904: [Array.ConcurrentHashMap.SegmentArray]State;
 var Array.ConcurrentHashMap.SegmentArray._length2244928: [Array.ConcurrentHashMap.SegmentArray]int;
 var seg$1962244986: Segment;                                                                       
 var this$1972244914: Segment;                                                                      
 var Segment._state2245054: [Segment]State;                                                         
 var Value.x2244928_bottom: [Value]int;                                                             
 var Segment._lock2245044: [Segment]Tid;                                                            
 var Key._lock2244999: [Key]Tid;                                                                    
 var phase2245041: Phase;                                                                           
 var this$1972244983: Segment;                                                                      
 var moverPath2244999: MoverPath;                                                                   
 var segments$1962244986: Array.ConcurrentHashMap.SegmentArray;                                     
 var ConcurrentHashMap.segments2244928_bottom: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;
 var Key._state2244999: [Key]State;                                                                 
 var Array.Segment.SegmentArray._state2245041_bottom: [Array.Segment.SegmentArray]State;            
 var this$1962244983_bottom: ConcurrentHashMap;                                                     
 var $pc2244928: Phase;                                                                             
 var Main._state2244983: [Main]State;                                                               
 var Key._lock2245041_bottom: [Key]Tid;                                                             
 var seg$1972244941: Value;                                                                         
 var this2244886: Main;                                                                             
 var Segment.segments2244886: [Segment]Array.Segment.SegmentArray;                                  
 var Value._lock2245041_bottom: [Value]Tid;                                                         
 var Segment.segments2244941: [Segment]Array.Segment.SegmentArray;                                  
 var $pc2244983: Phase;                                                                             
 var seg$1972244904: Value;                                                                         
 var tid2245041_bottom: Tid;                                                                        
 var Array.Segment.SegmentArray._length2244941: [Array.Segment.SegmentArray]int;                    
 var i$196: int;                                                                                    
 var HashEntry._lock2245044: [HashEntry]Tid;                                                        
 var Array.ConcurrentHashMap.SegmentArray._state2245044: [Array.ConcurrentHashMap.SegmentArray]State;
 var Segment.segments2245044: [Segment]Array.Segment.SegmentArray;                                  
 var $recorded.state2244928: int;                                                                   
 var this$1972244928: Segment;                                                                      
 var Value._lock2244928: [Value]Tid;                                                                
 var Segment.segments2245054: [Segment]Array.Segment.SegmentArray;                                  
 var ConcurrentHashMap.segments2244886: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Segment._state2245041_bottom: [Segment]State;                                                  
 var Value.x2244983_bottom: [Value]int;                                                             
 var $pc2244986: Phase;                                                                             
 var Array.Segment.SegmentArray._state2245054: [Array.Segment.SegmentArray]State;                   
 var i$1962245044: int;                                                                             
 var mover2244941: Mover;                                                                           
 var seg$1962244941: Segment;                                                                       
 var Segment.segments2244928_bottom: [Segment]Array.Segment.SegmentArray;                           
 var Array.ConcurrentHashMap.SegmentArray._elems2244928: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var mover2244904: Mover;                                                                           
 var HashEntry._state2244886: [HashEntry]State;                                                     
 var Value._lock2245054: [Value]Tid;                                                                
 var this$1972244986: Segment;                                                                      
 var this$1982244928: Value;                                                                        
 var Key._lock2244983_bottom: [Key]Tid;                                                             
 var ConcurrentHashMap.segments2244983: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var c2244904: ConcurrentHashMap;                                                                   
 var i$1962244999: int;                                                                             
 var Value.x2244914: [Value]int;                                                                    
 var c2244983: ConcurrentHashMap;                                                                   
 var Main._lock2245041_bottom: [Main]Tid;                                                           
 var Array.ConcurrentHashMap.SegmentArray._state2244886: [Array.ConcurrentHashMap.SegmentArray]State;
 var Array.ConcurrentHashMap.SegmentArray._length2245054: [Array.ConcurrentHashMap.SegmentArray]int;
 var HashEntry._lock2244999: [HashEntry]Tid;                                                        
 var seg$1962244983: Segment;                                                                       
 var $recorded.state2244928_bottom: int;                                                            
 var this2244941: Main;                                                                             
 var Array.ConcurrentHashMap.SegmentArray._length2245041: [Array.ConcurrentHashMap.SegmentArray]int;
 var Value.x2244941: [Value]int;                                                                    
 var Array.ConcurrentHashMap.SegmentArray._elems2245041_bottom: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Key._state2244928: [Key]State;                                                                 
 var c2244928_bottom: ConcurrentHashMap;                                                            
 var $recorded.state2244904: int;                                                                   
 var Segment._state2244986: [Segment]State;                                                         
 var Array.Segment.SegmentArray._length2244928_bottom: [Array.Segment.SegmentArray]int;             
 var HashEntry._lock2244904: [HashEntry]Tid;                                                        
 var HashEntry._lock2244986: [HashEntry]Tid;                                                        
 var HashEntry._state2244928: [HashEntry]State;                                                     
 var HashEntry._state2245041_bottom: [HashEntry]State;                                              
 var Array.ConcurrentHashMap.SegmentArray._length2245044: [Array.ConcurrentHashMap.SegmentArray]int;
 var Key._state2244904: [Key]State;                                                                 
 var $pc2244983_bottom: Phase;                                                                      
 var Value._state2244904: [Value]State;                                                             
 var Main._lock2244986: [Main]Tid;                                                                  
 var Segment._state2244983: [Segment]State;                                                         
 var ConcurrentHashMap._state2244941: [ConcurrentHashMap]State;                                     
 var this$1962244928_bottom: ConcurrentHashMap;                                                     
 var i$1962244983: int;                                                                             
 var Main._lock2244928_bottom: [Main]Tid;                                                           
 var phase2244983: Phase;                                                                           
 var i$1962244983_bottom: int;                                                                      
 var Array.Segment.SegmentArray._length2244914: [Array.Segment.SegmentArray]int;                    
 var Key._lock2244986: [Key]Tid;                                                                    
 var segments$1972244928: Array.Segment.SegmentArray;                                               
 var Value._lock2244983_bottom: [Value]Tid;                                                         
 var ConcurrentHashMap.segments2245041_bottom: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;
 var ConcurrentHashMap._state2244983: [ConcurrentHashMap]State;                                     
 var ConcurrentHashMap._state2245041_bottom: [ConcurrentHashMap]State;                              
 var Array.Segment.SegmentArray._length2244904: [Array.Segment.SegmentArray]int;                    
 var HashEntry._lock2244983: [HashEntry]Tid;                                                        
 var seg$1962244904: Segment;                                                                       
 var Array.Segment.SegmentArray._state2244983: [Array.Segment.SegmentArray]State;                   
 var seg$1962244928: Segment;                                                                       
 var Main._state2244904: [Main]State;                                                               
 var tid2245041: Tid;                                                                               
 var tid2244986: Tid;                                                                               
 var $recorded.state2244999: int;                                                                   
 var ConcurrentHashMap._lock2244986: [ConcurrentHashMap]Tid;                                        
 var Key._state2244941: [Key]State;                                                                 
 var Segment.segments2245041_bottom: [Segment]Array.Segment.SegmentArray;                           
 var Key._state2245054: [Key]State;                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state2244914: [Array.ConcurrentHashMap.SegmentArray]State;
 var Array.Segment.SegmentArray._elems2244904: [Array.Segment.SegmentArray]([int]Value);            
 var c2244999: ConcurrentHashMap;                                                                   
 var $pc2245044: Phase;                                                                             
 var Value._lock2244999: [Value]Tid;                                                                
 var this$1982244928_bottom: Value;                                                                 
 var $pc2245041_bottom: Phase;                                                                      
 var ConcurrentHashMap._state2245041: [ConcurrentHashMap]State;                                     
 var Main._state2244928: [Main]State;                                                               
 var Segment._lock2244886: [Segment]Tid;                                                            
 var Segment._lock2244941: [Segment]Tid;                                                            
 var this$1962244914: ConcurrentHashMap;                                                            
 var Segment.segments2244983_bottom: [Segment]Array.Segment.SegmentArray;                           
 var i$1962245041: int;                                                                             
 var this$1962245041: ConcurrentHashMap;                                                            
 var this2244983: Main;                                                                             
 var path2244904: int;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._state2244999: [Array.ConcurrentHashMap.SegmentArray]State;
 var c2245054: ConcurrentHashMap;                                                                   
 var mover2244986: Mover;                                                                           
 var Array.ConcurrentHashMap.SegmentArray._length2244983_bottom: [Array.ConcurrentHashMap.SegmentArray]int;
 var seg$1962244928_bottom: Segment;                                                                
 var segments$1972244983_bottom: Array.Segment.SegmentArray;                                        
 var this$198: Value;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems2244986: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Array.Segment.SegmentArray._state2245041: [Array.Segment.SegmentArray]State;                   
 var Value.x2245044: [Value]int;                                                                    
 var i$1962244914: int;                                                                             
 var Segment._state2244941: [Segment]State;                                                         
 var seg$196: Segment;                                                                              
 var mover2244999: Mover;                                                                           
 var seg$1962244886: Segment;                                                                       
 var $recorded.state2244983: int;                                                                   
 var Array.Segment.SegmentArray._length2245041: [Array.Segment.SegmentArray]int;                    
 var segments$1962245041: Array.ConcurrentHashMap.SegmentArray;                                     
 var Array.ConcurrentHashMap.SegmentArray._length2244928_bottom: [Array.ConcurrentHashMap.SegmentArray]int;
 var Key._lock2244904: [Key]Tid;                                                                    
 var segments$1962244914: Array.ConcurrentHashMap.SegmentArray;                                     
 var i$197: int;                                                                                    
 var Segment.segments2244904: [Segment]Array.Segment.SegmentArray;                                  
 var this2244914: Main;                                                                             
 var tid2244928: Tid;                                                                               
 var Array.Segment.SegmentArray._elems2244999: [Array.Segment.SegmentArray]([int]Value);            
 var Array.ConcurrentHashMap.SegmentArray._state2244986: [Array.ConcurrentHashMap.SegmentArray]State;
 var ConcurrentHashMap._state2244914: [ConcurrentHashMap]State;                                     
 var Array.Segment.SegmentArray._elems2245044: [Array.Segment.SegmentArray]([int]Value);            
 var tid2244886: Tid;                                                                               
 var mover2244886: Mover;                                                                           
 var $recorded.state2245041: int;                                                                   
 var Segment._lock2245041: [Segment]Tid;                                                            
 var ConcurrentHashMap._lock2245041_bottom: [ConcurrentHashMap]Tid;                                 
 var this$1962244986: ConcurrentHashMap;                                                            
 var ConcurrentHashMap._state2244904: [ConcurrentHashMap]State;                                     
 var this$1962244928: ConcurrentHashMap;                                                            
 var segments$1972244914: Array.Segment.SegmentArray;                                               
 var c2244983_bottom: ConcurrentHashMap;                                                            
 var i$1962245041_bottom: int;                                                                      
 var Main._state2245041: [Main]State;                                                               
 var HashEntry._lock2245041: [HashEntry]Tid;                                                        
 var Segment.segments2244983: [Segment]Array.Segment.SegmentArray;                                  
 var Value._state2244986: [Value]State;                                                             
 var Main._state2244914: [Main]State;                                                               
 var segments$1962244904: Array.ConcurrentHashMap.SegmentArray;                                     
 var Key._lock2245041: [Key]Tid;                                                                    
 var Key._lock2244928: [Key]Tid;                                                                    
 var HashEntry._state2244983: [HashEntry]State;                                                     
 var $recorded.state2244941: int;                                                                   
 var ConcurrentHashMap._lock2245041: [ConcurrentHashMap]Tid;                                        
 var i$1972244886: int;                                                                             
 var moverPath2245044: MoverPath;                                                                   
 var ConcurrentHashMap._lock2244904: [ConcurrentHashMap]Tid;                                        
 var segments$1962245041_bottom: Array.ConcurrentHashMap.SegmentArray;                              
 var Value.x2245041_bottom: [Value]int;                                                             
 var Array.Segment.SegmentArray._elems2244928_bottom: [Array.Segment.SegmentArray]([int]Value);     
 var i$1982244928_bottom: int;                                                                      
 var Array.Segment.SegmentArray._length2244928: [Array.Segment.SegmentArray]int;                    
 var Array.ConcurrentHashMap.SegmentArray._state2245054: [Array.ConcurrentHashMap.SegmentArray]State;
 var i$1962244928_bottom: int;                                                                      
 var $pc2245041: Phase;                                                                             
 var $recorded.state2245041_bottom: int;                                                            
 var ConcurrentHashMap._state2244999: [ConcurrentHashMap]State;                                     
 var Array.Segment.SegmentArray._state2244983_bottom: [Array.Segment.SegmentArray]State;            
 var Array.Segment.SegmentArray._state2244928_bottom: [Array.Segment.SegmentArray]State;            
 var Main._lock2244886: [Main]Tid;                                                                  
 var ConcurrentHashMap.segments2244941: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Value.x2244928: [Value]int;                                                                    
 var Segment._lock2244999: [Segment]Tid;                                                            
 var Main._state2245041_bottom: [Main]State;                                                        
 var Segment._lock2244904: [Segment]Tid;                                                            
 var ConcurrentHashMap.segments2245044: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Key._state2245041: [Key]State;                                                                 
 var Value._lock2245044: [Value]Tid;                                                                
 var this$1962244999: ConcurrentHashMap;                                                            
 var Value._state2244983: [Value]State;                                                             
 var Key._lock2245044: [Key]Tid;                                                                    
 var Main._state2244941: [Main]State;                                                               
 var $pc2245054: Phase;                                                                             
 var this$1972244928_bottom: Segment;                                                               
 var Value._lock2244928_bottom: [Value]Tid;                                                         
 var tid2244904: Tid;                                                                               
 var ConcurrentHashMap.segments2245054: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var HashEntry._state2244999: [HashEntry]State;                                                     
 var Segment._state2244999: [Segment]State;                                                         
 var c: ConcurrentHashMap;                                                                          
 var c2244941: ConcurrentHashMap;                                                                   
 var Main._lock2244983: [Main]Tid;                                                                  
 var HashEntry._state2244986: [HashEntry]State;                                                     
 var ConcurrentHashMap._state2245044: [ConcurrentHashMap]State;                                     
 var Main._state2244999: [Main]State;                                                               
 var HashEntry._state2244983_bottom: [HashEntry]State;                                              
 var HashEntry._lock2244941: [HashEntry]Tid;                                                        
 var Array.ConcurrentHashMap.SegmentArray._elems2244983_bottom: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._lock2244941: [Value]Tid;                                                                
 var Segment._state2244928: [Segment]State;                                                         
 var Value.x2245041: [Value]int;                                                                    
 var Segment._lock2245041_bottom: [Segment]Tid;                                                     
 var Array.ConcurrentHashMap.SegmentArray._state2245041_bottom: [Array.ConcurrentHashMap.SegmentArray]State;
 var HashEntry._lock2245041_bottom: [HashEntry]Tid;                                                 
 var Key._lock2244928_bottom: [Key]Tid;                                                             
 var t$1982244904: int;                                                                             
 var HashEntry._state2244941: [HashEntry]State;                                                     
 var Value._state2244941: [Value]State;                                                             
 var Main._lock2244914: [Main]Tid;                                                                  
 var Main._state2245054: [Main]State;                                                               
 var moverPath2244986: MoverPath;                                                                   
 var Array.Segment.SegmentArray._elems2244986: [Array.Segment.SegmentArray]([int]Value);            
 var $pc2244886: Phase;                                                                             
 var this$1962244983: ConcurrentHashMap;                                                            
 var Value._state2244983_bottom: [Value]State;                                                      
 var mover2245044: Mover;                                                                           
 var seg$197: Value;                                                                                
 var this$196: ConcurrentHashMap;                                                                   
 var segments$1972244928_bottom: Array.Segment.SegmentArray;                                        
 var ConcurrentHashMap._lock2244914: [ConcurrentHashMap]Tid;                                        
 var i$1972244914: int;                                                                             
 var ConcurrentHashMap._lock2244941: [ConcurrentHashMap]Tid;                                        
 var Array.ConcurrentHashMap.SegmentArray._elems2244999: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._lock2244914: [Value]Tid;                                                                
 var i$1962244986: int;                                                                             
 var Main._state2244983_bottom: [Main]State;                                                        
 var Key._state2244914: [Key]State;                                                                 
 var Value._lock2244904: [Value]Tid;                                                                
 var Array.Segment.SegmentArray._length2245054: [Array.Segment.SegmentArray]int;                    
 var ConcurrentHashMap.segments2245041: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Array.Segment.SegmentArray._elems2244983_bottom: [Array.Segment.SegmentArray]([int]Value);     
 var segments$1962244886: Array.ConcurrentHashMap.SegmentArray;                                     
 var Array.Segment.SegmentArray._state2244904: [Array.Segment.SegmentArray]State;                   
 var seg$1972244914: Value;                                                                         
 var Array.Segment.SegmentArray._state2244999: [Array.Segment.SegmentArray]State;                   
 var seg$1962244914: Segment;                                                                       
 var Segment._lock2245054: [Segment]Tid;                                                            
 var Array.Segment.SegmentArray._elems2244983: [Array.Segment.SegmentArray]([int]Value);            
 var t$198: int;                                                                                    
 var segments$1962244999: Array.ConcurrentHashMap.SegmentArray;                                     
 var this2244904: Main;                                                                             
 var this$1982244904: Value;                                                                        
 var Key._state2245041_bottom: [Key]State;                                                          
 var Array.ConcurrentHashMap.SegmentArray._state2245041: [Array.ConcurrentHashMap.SegmentArray]State;
 var Segment._state2244914: [Segment]State;                                                         
 var Array.ConcurrentHashMap.SegmentArray._length2244983: [Array.ConcurrentHashMap.SegmentArray]int;
 var HashEntry._state2244914: [HashEntry]State;                                                     
 var Array.ConcurrentHashMap.SegmentArray._length2244914: [Array.ConcurrentHashMap.SegmentArray]int;
 var this2244928: Main;                                                                             
 var Array.ConcurrentHashMap.SegmentArray._elems2245044: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var segments$196: Array.ConcurrentHashMap.SegmentArray;                                            
 var Array.Segment.SegmentArray._length2244986: [Array.Segment.SegmentArray]int;                    
 var segments$1962244983_bottom: Array.ConcurrentHashMap.SegmentArray;                              
 var Array.Segment.SegmentArray._elems2245054: [Array.Segment.SegmentArray]([int]Value);            
 var Key._lock2244886: [Key]Tid;                                                                    
 var segments$1972244904: Array.Segment.SegmentArray;                                               
 var Value._state2245041_bottom: [Value]State;                                                      
 var Segment._lock2244914: [Segment]Tid;                                                            
 var Value._lock2244983: [Value]Tid;                                                                
 var Value._state2245044: [Value]State;                                                             
 var Value._state2245041: [Value]State;                                                             
 var c2245041: ConcurrentHashMap;                                                                   
 var Key._state2244986: [Key]State;                                                                 
 var Segment._state2245041: [Segment]State;                                                         
 var HashEntry._lock2244886: [HashEntry]Tid;                                                        
 var HashEntry._state2245044: [HashEntry]State;                                                     
 var i$1972244941: int;                                                                             
 var Array.Segment.SegmentArray._elems2244886: [Array.Segment.SegmentArray]([int]Value);            
 var i$1972244904: int;                                                                             
 var Array.ConcurrentHashMap.SegmentArray._length2244999: [Array.ConcurrentHashMap.SegmentArray]int;
 var Main._state2244886: [Main]State;                                                               
 var tid2244999: Tid;                                                                               
 var tid2244928_bottom: Tid;                                                                        
 var Key._state2244886: [Key]State;                                                                 
 var Array.Segment.SegmentArray._elems2244928: [Array.Segment.SegmentArray]([int]Value);            
 var $recorded.state2245054: int;                                                                   
 var ConcurrentHashMap.segments2244914: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var Value._state2244928_bottom: [Value]State;                                                      
 var Array.ConcurrentHashMap.SegmentArray._elems2245054: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var seg$1972244886: Value;                                                                         
 var this$1962244904: ConcurrentHashMap;                                                            
 var Value.x2244999: [Value]int;                                                                    
 var Array.Segment.SegmentArray._state2244986: [Array.Segment.SegmentArray]State;                   
 var Array.Segment.SegmentArray._elems2244914: [Array.Segment.SegmentArray]([int]Value);            
 var Value.x2244886: [Value]int;                                                                    
 var segments$1972244983: Array.Segment.SegmentArray;                                               
 var Array.Segment.SegmentArray._state2244886: [Array.Segment.SegmentArray]State;                   
 var Segment.segments2244986: [Segment]Array.Segment.SegmentArray;                                  
 var Array.ConcurrentHashMap.SegmentArray._state2244983: [Array.ConcurrentHashMap.SegmentArray]State;
 var this$1962244941: ConcurrentHashMap;                                                            
 var ConcurrentHashMap._lock2245044: [ConcurrentHashMap]Tid;                                        
 var Key._lock2245054: [Key]Tid;                                                                    
 var Key._lock2244983: [Key]Tid;                                                                    
 var Segment._lock2244986: [Segment]Tid;                                                            
 var Value.x2244986: [Value]int;                                                                    
 var $pc2244999: Phase;                                                                             
 var segments$1972244986: Array.Segment.SegmentArray;                                               
 var $recorded.state2244914: int;                                                                   
 var Segment._state2244886: [Segment]State;                                                         
 var this$197: Segment;                                                                             
 var c2244928: ConcurrentHashMap;                                                                   
 var $recorded.state2245044: int;                                                                   
 var segments$1972244886: Array.Segment.SegmentArray;                                               
 var ConcurrentHashMap._lock2244999: [ConcurrentHashMap]Tid;                                        
 var Segment.segments2244999: [Segment]Array.Segment.SegmentArray;                                  
 var i$1972244928: int;                                                                             
 var ConcurrentHashMap.segments2244983_bottom: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;
 var Array.Segment.SegmentArray._state2245044: [Array.Segment.SegmentArray]State;                   
 var Segment._state2244928_bottom: [Segment]State;                                                  
 var this$1962244886: ConcurrentHashMap;                                                            
 var Main._lock2245054: [Main]Tid;                                                                  
 var Segment.segments2244914: [Segment]Array.Segment.SegmentArray;                                  
 var segments$1962244983: Array.ConcurrentHashMap.SegmentArray;                                     
 var ConcurrentHashMap._lock2244928: [ConcurrentHashMap]Tid;                                        
 var seg$1972244928: Value;                                                                         
 var Array.ConcurrentHashMap.SegmentArray._length2245041_bottom: [Array.ConcurrentHashMap.SegmentArray]int;
 var segments$1962244928_bottom: Array.ConcurrentHashMap.SegmentArray;                              
 var path2244986: int;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems2245041: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var path2244941: int;                                                                              
 var $pc2244914: Phase;                                                                             
 var Array.ConcurrentHashMap.SegmentArray._length2244941: [Array.ConcurrentHashMap.SegmentArray]int;
 var this2245044: Main;                                                                             
 var moverPath2244941: MoverPath;                                                                   
 var Main._state2244928_bottom: [Main]State;                                                        
 var Array.ConcurrentHashMap.SegmentArray._elems2244904: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var i$1982244928: int;                                                                             
 var this2245041: Main;                                                                             
 var ConcurrentHashMap.segments2244904: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;    
 var path2244999: int;                                                                              
 var ConcurrentHashMap._state2244886: [ConcurrentHashMap]State;                                     
 var this2244928_bottom: Main;                                                                      
 var seg$1962244983_bottom: Segment;                                                                
 var c2244986: ConcurrentHashMap;                                                                   
 var c2245044: ConcurrentHashMap;                                                                   
 var Main._lock2244999: [Main]Tid;                                                                  
 var Segment.segments2245041: [Segment]Array.Segment.SegmentArray;                                  
 var Key._state2244928_bottom: [Key]State;                                                          
 var $pc2244941: Phase;                                                                             
 var path2244886: int;                                                                              
 var Array.Segment.SegmentArray._elems2245041: [Array.Segment.SegmentArray]([int]Value);            
 var HashEntry._state2244904: [HashEntry]State;                                                     
 var Array.ConcurrentHashMap.SegmentArray._state2244928: [Array.ConcurrentHashMap.SegmentArray]State;
 var $recorded.state2244886: int;                                                                   
 var Array.Segment.SegmentArray._state2244941: [Array.Segment.SegmentArray]State;                   
 var Value._state2244999: [Value]State;                                                             
 var Segment._lock2244983_bottom: [Segment]Tid;                                                     
 var i$1972244983: int;                                                                             
 var segments$1962244941: Array.ConcurrentHashMap.SegmentArray;                                     
 var Array.ConcurrentHashMap.SegmentArray._length2244986: [Array.ConcurrentHashMap.SegmentArray]int;
 var tid2245054: Tid;                                                                               
 var Array.Segment.SegmentArray._elems2244941: [Array.Segment.SegmentArray]([int]Value);            
 var t$1982244914: int;                                                                             
 var Array.ConcurrentHashMap.SegmentArray._elems2244886: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var segments$197: Array.Segment.SegmentArray;                                                      
 var tid2245044: Tid;                                                                               
 var ConcurrentHashMap._lock2244886: [ConcurrentHashMap]Tid;                                        
 var Value._state2244914: [Value]State;                                                             
 var Main._lock2245044: [Main]Tid;                                                                  
 var i$1962244886: int;                                                                             
 var i$1972244983_bottom: int;                                                                      
 var Value.x2245054: [Value]int;                                                                    
 var Main._lock2244904: [Main]Tid;                                                                  
 var this$1962245041_bottom: ConcurrentHashMap;                                                     
 var Value._state2244886: [Value]State;                                                             
 var Key._state2244983_bottom: [Key]State;                                                          
 var c2244886: ConcurrentHashMap;                                                                   
 var Value._state2244928: [Value]State;                                                             
 var Value.x2244983: [Value]int;                                                                    
 var Array.Segment.SegmentArray._elems2245041_bottom: [Array.Segment.SegmentArray]([int]Value);     
 var i$1962244904: int;                                                                             
 var $recorded.state2244986: int;                                                                   
 var tid2244983: Tid;                                                                               
 var Value.x2244904: [Value]int;                                                                    
 var Segment._lock2244983: [Segment]Tid;                                                            
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 74.9: ConcurrentHashMap c;                                                                      
                                                                                                    
                                                                                                    
 // 74.9: c = new ConcurrentHashMap();                                                              
                                                                                                    
 havoc c;                                                                                           
 assume c != ConcurrentHashMap.null && isFresh(ConcurrentHashMap._state[c]);                        
 ConcurrentHashMap._state[c] := LOCAL(tid);                                                         
 assume ConcurrentHashMap.segments[c]  == Array.ConcurrentHashMap.SegmentArray.null;                
 assume ConcurrentHashMap._lock[c]  == Tid.null;                                                    
 // inlined: c.init()}                                                                              
 exit$196_top:                                                                                      
                                                                                                    
 // 75.9: ConcurrentHashMap this$196;                                                               
                                                                                                    
                                                                                                    
 // 75.9: this$196 = c;                                                                             
                                                                                                    
 this$196 := c;                                                                                     
                                                                                                    
 // 57.9: [ConcurrentHashMap.SegmentArray{this$196}] segments$196;                                  
                                                                                                    
                                                                                                    
 // 57.9: segments$196 = new [ConcurrentHashMap.SegmentArray{this$196}](16);                        
                                                                                                    
 havoc segments$196;                                                                                
 assume isFresh(Array.ConcurrentHashMap.SegmentArray._state[segments$196]);                         
 assume Array.ConcurrentHashMap.SegmentArray._length[segments$196] == 16;                           
 assume Array.ConcurrentHashMap.SegmentArray._this[segments$196] == this$196;                       
 Array.ConcurrentHashMap.SegmentArray._state[segments$196] := LOCAL(tid);                           
 assume (forall _i : int :: 0 <= _i ==> Array.ConcurrentHashMap.SegmentArray._elems[segments$196][_i] == Segment.null);
                                                                                                    
 // 58.14: int i$196;                                                                               
                                                                                                    
                                                                                                    
 // 58.22: i$196 = 0;                                                                               
                                                                                                    
 i$196 := 0;                                                                                        
 assume Key._state2245041 == Key._state && Key._lock2245041 == Key._lock && Value._state2245041 == Value._state && Value.x2245041 == Value.x && Value._lock2245041 == Value._lock && HashEntry._state2245041 == HashEntry._state && HashEntry._lock2245041 == HashEntry._lock && Segment._state2245041 == Segment._state && Segment.segments2245041 == Segment.segments && Segment._lock2245041 == Segment._lock && Array.Segment.SegmentArray._state2245041 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2245041 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2245041 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2245041 == ConcurrentHashMap._state && ConcurrentHashMap.segments2245041 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2245041 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2245041 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2245041 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2245041 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2245041 == Main._state && Main._lock2245041 == Main._lock && i$1962245041 == i$196 && segments$1962245041 == segments$196 && this$1962245041 == this$196 && c2245041 == c && this2245041 == this && tid2245041 == tid;
 assume $recorded.state2245041 == 1;                                                                
                                                                                                    
 // 58.27: while (i$196 < segments$196.length)                                                      
                                                                                                    
 phase2245041 := $pc;                                                                               
 while ((i$196<Array.ConcurrentHashMap.SegmentArray._length[segments$196]))                         
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (73.5): Bad tid
  invariant isShared(Main._state[this]);                                                                   // (73.5): this is not global
                                                                                                    
  invariant StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
  invariant  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (58.27): Object invariant may not hold.
  invariant  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (58.27): Object invariant may not hold.
  invariant  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && _this != c ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (58.27): Object invariant may not hold.
  invariant (forall k$196: int ::  ((((0<=k$196)&&(k$196<i$196))==>((Array.ConcurrentHashMap.SegmentArray._elems[segments$196][k$196]!=Segment.null)&&isShared(Segment._state[Array.ConcurrentHashMap.SegmentArray._elems[segments$196][k$196]])))));
  invariant isLocal(Array.ConcurrentHashMap.SegmentArray._state[segments$196], tid);                
  invariant (forall _this : Value :: Invariant.Y_Value.x(tid : Tid, _this, Value.x[_this] ,Key._state2245041,Key._lock2245041,Value._state2245041,Value.x2245041,Value._lock2245041,HashEntry._state2245041,HashEntry._lock2245041,Segment._state2245041,Segment.segments2245041,Segment._lock2245041,Array.Segment.SegmentArray._state2245041,Array.Segment.SegmentArray._elems2245041,Array.Segment.SegmentArray._length2245041,ConcurrentHashMap._state2245041,ConcurrentHashMap.segments2245041,ConcurrentHashMap._lock2245041,Array.ConcurrentHashMap.SegmentArray._state2245041,Array.ConcurrentHashMap.SegmentArray._elems2245041,Array.ConcurrentHashMap.SegmentArray._length2245041,Main._state2245041,Main._lock2245041));       // (58.27): Loop does not preserve yields_as annotation for field x
  invariant (forall _this : Segment :: Invariant.Y_Segment.segments(tid : Tid, _this, Segment.segments[_this] ,Key._state2245041,Key._lock2245041,Value._state2245041,Value.x2245041,Value._lock2245041,HashEntry._state2245041,HashEntry._lock2245041,Segment._state2245041,Segment.segments2245041,Segment._lock2245041,Array.Segment.SegmentArray._state2245041,Array.Segment.SegmentArray._elems2245041,Array.Segment.SegmentArray._length2245041,ConcurrentHashMap._state2245041,ConcurrentHashMap.segments2245041,ConcurrentHashMap._lock2245041,Array.ConcurrentHashMap.SegmentArray._state2245041,Array.ConcurrentHashMap.SegmentArray._elems2245041,Array.ConcurrentHashMap.SegmentArray._length2245041,Main._state2245041,Main._lock2245041));       // (58.27): Loop does not preserve yields_as annotation for field segments
  invariant (forall _athis : Array.Segment.SegmentArray, _index : int :: Invariant.Y_Array.Segment.SegmentArray(tid : Tid, _athis, _index, Array.Segment.SegmentArray._elems[_athis][_index] ,Key._state2245041,Key._lock2245041,Value._state2245041,Value.x2245041,Value._lock2245041,HashEntry._state2245041,HashEntry._lock2245041,Segment._state2245041,Segment.segments2245041,Segment._lock2245041,Array.Segment.SegmentArray._state2245041,Array.Segment.SegmentArray._elems2245041,Array.Segment.SegmentArray._length2245041,ConcurrentHashMap._state2245041,ConcurrentHashMap.segments2245041,ConcurrentHashMap._lock2245041,Array.ConcurrentHashMap.SegmentArray._state2245041,Array.ConcurrentHashMap.SegmentArray._elems2245041,Array.ConcurrentHashMap.SegmentArray._length2245041,Main._state2245041,Main._lock2245041));       // (58.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
  invariant (forall _this : ConcurrentHashMap :: Invariant.Y_ConcurrentHashMap.segments(tid : Tid, _this, ConcurrentHashMap.segments[_this] ,Key._state2245041,Key._lock2245041,Value._state2245041,Value.x2245041,Value._lock2245041,HashEntry._state2245041,HashEntry._lock2245041,Segment._state2245041,Segment.segments2245041,Segment._lock2245041,Array.Segment.SegmentArray._state2245041,Array.Segment.SegmentArray._elems2245041,Array.Segment.SegmentArray._length2245041,ConcurrentHashMap._state2245041,ConcurrentHashMap.segments2245041,ConcurrentHashMap._lock2245041,Array.ConcurrentHashMap.SegmentArray._state2245041,Array.ConcurrentHashMap.SegmentArray._elems2245041,Array.ConcurrentHashMap.SegmentArray._length2245041,Main._state2245041,Main._lock2245041));       // (58.27): Loop does not preserve yields_as annotation for field segments
  invariant (forall _athis : Array.ConcurrentHashMap.SegmentArray, _index : int :: Invariant.Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, _athis, _index, Array.ConcurrentHashMap.SegmentArray._elems[_athis][_index] ,Key._state2245041,Key._lock2245041,Value._state2245041,Value.x2245041,Value._lock2245041,HashEntry._state2245041,HashEntry._lock2245041,Segment._state2245041,Segment.segments2245041,Segment._lock2245041,Array.Segment.SegmentArray._state2245041,Array.Segment.SegmentArray._elems2245041,Array.Segment.SegmentArray._length2245041,ConcurrentHashMap._state2245041,ConcurrentHashMap.segments2245041,ConcurrentHashMap._lock2245041,Array.ConcurrentHashMap.SegmentArray._state2245041,Array.ConcurrentHashMap.SegmentArray._elems2245041,Array.ConcurrentHashMap.SegmentArray._length2245041,Main._state2245041,Main._lock2245041));       // (58.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
  invariant phase2245041 == $pc;                                                                           // (58.27): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (58.27): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 62.13: Segment seg$196;                                                                        
                                                                                                    
                                                                                                    
  // 62.13: seg$196 = new Segment();                                                                
                                                                                                    
  havoc seg$196;                                                                                    
  assume seg$196 != Segment.null && isFresh(Segment._state[seg$196]);                               
  Segment._state[seg$196] := LOCAL(tid);                                                            
  assume Segment.segments[seg$196]  == Array.Segment.SegmentArray.null;                             
  assume Segment._lock[seg$196]  == Tid.null;                                                       
  // inlined: seg$196.init()}                                                                       
  exit$197_top:                                                                                     
                                                                                                    
  // 63.13: Segment this$197;                                                                       
                                                                                                    
                                                                                                    
  // 63.13: this$197 = seg$196;                                                                     
                                                                                                    
  this$197 := seg$196;                                                                              
                                                                                                    
  // 33.9: [Segment.SegmentArray{this$197}] segments$197;                                           
                                                                                                    
                                                                                                    
  // 33.9: segments$197 = new [Segment.SegmentArray{this$197}](16);                                 
                                                                                                    
  havoc segments$197;                                                                               
  assume isFresh(Array.Segment.SegmentArray._state[segments$197]);                                  
  assume Array.Segment.SegmentArray._length[segments$197] == 16;                                    
  assume Array.Segment.SegmentArray._this[segments$197] == this$197;                                
  Array.Segment.SegmentArray._state[segments$197] := LOCAL(tid);                                    
  assume (forall _i : int :: 0 <= _i ==> Array.Segment.SegmentArray._elems[segments$197][_i] == Value.null);
                                                                                                    
  // 34.14: int i$197;                                                                              
                                                                                                    
                                                                                                    
  // 34.22: i$197 = 0;                                                                              
                                                                                                    
  i$197 := 0;                                                                                       
  assume Key._state2244983 == Key._state && Key._lock2244983 == Key._lock && Value._state2244983 == Value._state && Value.x2244983 == Value.x && Value._lock2244983 == Value._lock && HashEntry._state2244983 == HashEntry._state && HashEntry._lock2244983 == HashEntry._lock && Segment._state2244983 == Segment._state && Segment.segments2244983 == Segment.segments && Segment._lock2244983 == Segment._lock && Array.Segment.SegmentArray._state2244983 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244983 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244983 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244983 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244983 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244983 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244983 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244983 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244983 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244983 == Main._state && Main._lock2244983 == Main._lock && i$1972244983 == i$197 && segments$1972244983 == segments$197 && this$1972244983 == this$197 && seg$1962244983 == seg$196 && i$1962244983 == i$196 && segments$1962244983 == segments$196 && this$1962244983 == this$196 && c2244983 == c && this2244983 == this && tid2244983 == tid;
  assume $recorded.state2244983 == 1;                                                               
                                                                                                    
  // 34.27: while (i$197 < 16)                                                                      
                                                                                                    
  phase2244983 := $pc;                                                                              
  while ((i$197<16))                                                                                
                                                                                                    
   invariant ValidTid(tid);                                                                                // (73.5): Bad tid
   invariant isShared(Main._state[this]);                                                                  // (73.5): this is not global
                                                                                                    
   invariant StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
   invariant  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (34.27): Object invariant may not hold.
   invariant  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && _this != seg$196 ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (34.27): Object invariant may not hold.
   invariant  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && _this != c ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (34.27): Object invariant may not hold.
   invariant isLocal(Array.Segment.SegmentArray._state[segments$197], tid);                         
   invariant (forall k$197: int ::  ((((0<=k$197)&&(k$197<i$197))==>((Array.Segment.SegmentArray._elems[segments$197][k$197]!=Value.null)&&isShared(Value._state[Array.Segment.SegmentArray._elems[segments$197][k$197]])))));
   invariant (forall _this : Value :: Invariant.Y_Value.x(tid : Tid, _this, Value.x[_this] ,Key._state2244983,Key._lock2244983,Value._state2244983,Value.x2244983,Value._lock2244983,HashEntry._state2244983,HashEntry._lock2244983,Segment._state2244983,Segment.segments2244983,Segment._lock2244983,Array.Segment.SegmentArray._state2244983,Array.Segment.SegmentArray._elems2244983,Array.Segment.SegmentArray._length2244983,ConcurrentHashMap._state2244983,ConcurrentHashMap.segments2244983,ConcurrentHashMap._lock2244983,Array.ConcurrentHashMap.SegmentArray._state2244983,Array.ConcurrentHashMap.SegmentArray._elems2244983,Array.ConcurrentHashMap.SegmentArray._length2244983,Main._state2244983,Main._lock2244983));       // (34.27): Loop does not preserve yields_as annotation for field x
   invariant (forall _this : Segment :: Invariant.Y_Segment.segments(tid : Tid, _this, Segment.segments[_this] ,Key._state2244983,Key._lock2244983,Value._state2244983,Value.x2244983,Value._lock2244983,HashEntry._state2244983,HashEntry._lock2244983,Segment._state2244983,Segment.segments2244983,Segment._lock2244983,Array.Segment.SegmentArray._state2244983,Array.Segment.SegmentArray._elems2244983,Array.Segment.SegmentArray._length2244983,ConcurrentHashMap._state2244983,ConcurrentHashMap.segments2244983,ConcurrentHashMap._lock2244983,Array.ConcurrentHashMap.SegmentArray._state2244983,Array.ConcurrentHashMap.SegmentArray._elems2244983,Array.ConcurrentHashMap.SegmentArray._length2244983,Main._state2244983,Main._lock2244983));       // (34.27): Loop does not preserve yields_as annotation for field segments
   invariant (forall _athis : Array.Segment.SegmentArray, _index : int :: Invariant.Y_Array.Segment.SegmentArray(tid : Tid, _athis, _index, Array.Segment.SegmentArray._elems[_athis][_index] ,Key._state2244983,Key._lock2244983,Value._state2244983,Value.x2244983,Value._lock2244983,HashEntry._state2244983,HashEntry._lock2244983,Segment._state2244983,Segment.segments2244983,Segment._lock2244983,Array.Segment.SegmentArray._state2244983,Array.Segment.SegmentArray._elems2244983,Array.Segment.SegmentArray._length2244983,ConcurrentHashMap._state2244983,ConcurrentHashMap.segments2244983,ConcurrentHashMap._lock2244983,Array.ConcurrentHashMap.SegmentArray._state2244983,Array.ConcurrentHashMap.SegmentArray._elems2244983,Array.ConcurrentHashMap.SegmentArray._length2244983,Main._state2244983,Main._lock2244983));       // (34.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
   invariant (forall _this : ConcurrentHashMap :: Invariant.Y_ConcurrentHashMap.segments(tid : Tid, _this, ConcurrentHashMap.segments[_this] ,Key._state2244983,Key._lock2244983,Value._state2244983,Value.x2244983,Value._lock2244983,HashEntry._state2244983,HashEntry._lock2244983,Segment._state2244983,Segment.segments2244983,Segment._lock2244983,Array.Segment.SegmentArray._state2244983,Array.Segment.SegmentArray._elems2244983,Array.Segment.SegmentArray._length2244983,ConcurrentHashMap._state2244983,ConcurrentHashMap.segments2244983,ConcurrentHashMap._lock2244983,Array.ConcurrentHashMap.SegmentArray._state2244983,Array.ConcurrentHashMap.SegmentArray._elems2244983,Array.ConcurrentHashMap.SegmentArray._length2244983,Main._state2244983,Main._lock2244983));       // (34.27): Loop does not preserve yields_as annotation for field segments
   invariant (forall _athis : Array.ConcurrentHashMap.SegmentArray, _index : int :: Invariant.Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, _athis, _index, Array.ConcurrentHashMap.SegmentArray._elems[_athis][_index] ,Key._state2244983,Key._lock2244983,Value._state2244983,Value.x2244983,Value._lock2244983,HashEntry._state2244983,HashEntry._lock2244983,Segment._state2244983,Segment.segments2244983,Segment._lock2244983,Array.Segment.SegmentArray._state2244983,Array.Segment.SegmentArray._elems2244983,Array.Segment.SegmentArray._length2244983,ConcurrentHashMap._state2244983,ConcurrentHashMap.segments2244983,ConcurrentHashMap._lock2244983,Array.ConcurrentHashMap.SegmentArray._state2244983,Array.ConcurrentHashMap.SegmentArray._elems2244983,Array.ConcurrentHashMap.SegmentArray._length2244983,Main._state2244983,Main._lock2244983));       // (34.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
   invariant phase2244983 == $pc;                                                                          // (34.27): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (34.27): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 38.13: Value seg$197;                                                                         
                                                                                                    
                                                                                                    
   // 38.13: seg$197 = new Value();                                                                 
                                                                                                    
   havoc seg$197;                                                                                   
   assume seg$197 != Value.null && isFresh(Value._state[seg$197]);                                  
   Value._state[seg$197] := LOCAL(tid);                                                             
   assume Value.x[seg$197]  == 0;                                                                   
   assume Value._lock[seg$197]  == Tid.null;                                                        
   // inlined: seg$197.init()}                                                                      
   exit$198_top:                                                                                    
                                                                                                    
   // 39.13: Value this$198;                                                                        
                                                                                                    
                                                                                                    
   // 39.13: this$198 = seg$197;                                                                    
                                                                                                    
   this$198 := seg$197;                                                                             
                                                                                                    
                                                                                                    
   // 11.9: this$198.x := 0;                                                                        
                                                                                                    
                                                                                                    
   moverPath2244886 := WriteEval.Value.x(tid: Tid,this$198: Value,0: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
   mover2244886 := m#moverPath(moverPath2244886);                                                   
   path2244886 := p#moverPath(moverPath2244886);                                                    
   assume Key._state2244886 == Key._state && Key._lock2244886 == Key._lock && Value._state2244886 == Value._state && Value.x2244886 == Value.x && Value._lock2244886 == Value._lock && HashEntry._state2244886 == HashEntry._state && HashEntry._lock2244886 == HashEntry._lock && Segment._state2244886 == Segment._state && Segment.segments2244886 == Segment.segments && Segment._lock2244886 == Segment._lock && Array.Segment.SegmentArray._state2244886 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244886 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244886 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244886 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244886 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244886 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244886 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244886 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244886 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244886 == Main._state && Main._lock2244886 == Main._lock && this$1982244886 == this$198 && seg$1972244886 == seg$197 && i$1972244886 == i$197 && segments$1972244886 == segments$197 && this$1972244886 == this$197 && seg$1962244886 == seg$196 && i$1962244886 == i$196 && segments$1962244886 == segments$196 && this$1962244886 == this$196 && c2244886 == c && this2244886 == this && tid2244886 == tid && $pc2244886 == $pc;
   assume $recorded.state2244886 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this$198 != Value.null;                                                                  
   } else {                                                                                         
    assert this$198 != Value.null;                                                                         // (11.9): Cannot have potential null deference in left-mover part.
   }                                                                                                
   $pc := transition($pc, mover2244886);                                                            
   assert $pc != PhaseError;                                                                               // (11.9): Reduction failure
   Value.x[this$198] := 0;                                                                          
                                                                                                    
   // 12.14: int i$198;                                                                             
                                                                                                    
                                                                                                    
   // 12.22: i$198 = 0;                                                                             
                                                                                                    
   i$198 := 0;                                                                                      
   assume Key._state2244928 == Key._state && Key._lock2244928 == Key._lock && Value._state2244928 == Value._state && Value.x2244928 == Value.x && Value._lock2244928 == Value._lock && HashEntry._state2244928 == HashEntry._state && HashEntry._lock2244928 == HashEntry._lock && Segment._state2244928 == Segment._state && Segment.segments2244928 == Segment.segments && Segment._lock2244928 == Segment._lock && Array.Segment.SegmentArray._state2244928 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244928 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244928 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244928 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244928 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244928 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244928 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244928 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244928 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244928 == Main._state && Main._lock2244928 == Main._lock && i$1982244928 == i$198 && this$1982244928 == this$198 && seg$1972244928 == seg$197 && i$1972244928 == i$197 && segments$1972244928 == segments$197 && this$1972244928 == this$197 && seg$1962244928 == seg$196 && i$1962244928 == i$196 && segments$1962244928 == segments$196 && this$1962244928 == this$196 && c2244928 == c && this2244928 == this && tid2244928 == tid;
   assume $recorded.state2244928 == 1;                                                              
                                                                                                    
   // 12.27: while (i$198 != 3)                                                                     
                                                                                                    
   phase2244928 := $pc;                                                                             
   while ((i$198!=3))                                                                               
                                                                                                    
    invariant ValidTid(tid);                                                                               // (73.5): Bad tid
    invariant isShared(Main._state[this]);                                                                 // (73.5): this is not global
                                                                                                    
    invariant StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
    invariant  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && _this != seg$197 ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (12.27): Object invariant may not hold.
    invariant  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && _this != seg$196 ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (12.27): Object invariant may not hold.
    invariant  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && _this != c ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (12.27): Object invariant may not hold.
    invariant (Value.x[this$198]==i$198);                                                           
    invariant (forall _this : Value :: Invariant.Y_Value.x(tid : Tid, _this, Value.x[_this] ,Key._state2244928,Key._lock2244928,Value._state2244928,Value.x2244928,Value._lock2244928,HashEntry._state2244928,HashEntry._lock2244928,Segment._state2244928,Segment.segments2244928,Segment._lock2244928,Array.Segment.SegmentArray._state2244928,Array.Segment.SegmentArray._elems2244928,Array.Segment.SegmentArray._length2244928,ConcurrentHashMap._state2244928,ConcurrentHashMap.segments2244928,ConcurrentHashMap._lock2244928,Array.ConcurrentHashMap.SegmentArray._state2244928,Array.ConcurrentHashMap.SegmentArray._elems2244928,Array.ConcurrentHashMap.SegmentArray._length2244928,Main._state2244928,Main._lock2244928));       // (12.27): Loop does not preserve yields_as annotation for field x
    invariant (forall _this : Segment :: Invariant.Y_Segment.segments(tid : Tid, _this, Segment.segments[_this] ,Key._state2244928,Key._lock2244928,Value._state2244928,Value.x2244928,Value._lock2244928,HashEntry._state2244928,HashEntry._lock2244928,Segment._state2244928,Segment.segments2244928,Segment._lock2244928,Array.Segment.SegmentArray._state2244928,Array.Segment.SegmentArray._elems2244928,Array.Segment.SegmentArray._length2244928,ConcurrentHashMap._state2244928,ConcurrentHashMap.segments2244928,ConcurrentHashMap._lock2244928,Array.ConcurrentHashMap.SegmentArray._state2244928,Array.ConcurrentHashMap.SegmentArray._elems2244928,Array.ConcurrentHashMap.SegmentArray._length2244928,Main._state2244928,Main._lock2244928));       // (12.27): Loop does not preserve yields_as annotation for field segments
    invariant (forall _athis : Array.Segment.SegmentArray, _index : int :: Invariant.Y_Array.Segment.SegmentArray(tid : Tid, _athis, _index, Array.Segment.SegmentArray._elems[_athis][_index] ,Key._state2244928,Key._lock2244928,Value._state2244928,Value.x2244928,Value._lock2244928,HashEntry._state2244928,HashEntry._lock2244928,Segment._state2244928,Segment.segments2244928,Segment._lock2244928,Array.Segment.SegmentArray._state2244928,Array.Segment.SegmentArray._elems2244928,Array.Segment.SegmentArray._length2244928,ConcurrentHashMap._state2244928,ConcurrentHashMap.segments2244928,ConcurrentHashMap._lock2244928,Array.ConcurrentHashMap.SegmentArray._state2244928,Array.ConcurrentHashMap.SegmentArray._elems2244928,Array.ConcurrentHashMap.SegmentArray._length2244928,Main._state2244928,Main._lock2244928));       // (12.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
    invariant (forall _this : ConcurrentHashMap :: Invariant.Y_ConcurrentHashMap.segments(tid : Tid, _this, ConcurrentHashMap.segments[_this] ,Key._state2244928,Key._lock2244928,Value._state2244928,Value.x2244928,Value._lock2244928,HashEntry._state2244928,HashEntry._lock2244928,Segment._state2244928,Segment.segments2244928,Segment._lock2244928,Array.Segment.SegmentArray._state2244928,Array.Segment.SegmentArray._elems2244928,Array.Segment.SegmentArray._length2244928,ConcurrentHashMap._state2244928,ConcurrentHashMap.segments2244928,ConcurrentHashMap._lock2244928,Array.ConcurrentHashMap.SegmentArray._state2244928,Array.ConcurrentHashMap.SegmentArray._elems2244928,Array.ConcurrentHashMap.SegmentArray._length2244928,Main._state2244928,Main._lock2244928));       // (12.27): Loop does not preserve yields_as annotation for field segments
    invariant (forall _athis : Array.ConcurrentHashMap.SegmentArray, _index : int :: Invariant.Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, _athis, _index, Array.ConcurrentHashMap.SegmentArray._elems[_athis][_index] ,Key._state2244928,Key._lock2244928,Value._state2244928,Value.x2244928,Value._lock2244928,HashEntry._state2244928,HashEntry._lock2244928,Segment._state2244928,Segment.segments2244928,Segment._lock2244928,Array.Segment.SegmentArray._state2244928,Array.Segment.SegmentArray._elems2244928,Array.Segment.SegmentArray._length2244928,ConcurrentHashMap._state2244928,ConcurrentHashMap.segments2244928,ConcurrentHashMap._lock2244928,Array.ConcurrentHashMap.SegmentArray._state2244928,Array.ConcurrentHashMap.SegmentArray._elems2244928,Array.ConcurrentHashMap.SegmentArray._length2244928,Main._state2244928,Main._lock2244928));       // (12.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
    invariant phase2244928 == $pc;                                                                         // (12.27): Phase must be invariant at loop head
    invariant $pc == PreCommit;                                                                            // (12.27): Potentially infinite loop cannot be in post-commit phase.
   {                                                                                                
                                                                                                    
    // 15.13: int t$198;                                                                            
                                                                                                    
                                                                                                    
    // 15.13: t$198 := this$198.x;                                                                  
                                                                                                    
                                                                                                    
    moverPath2244904 := ReadEval.Value.x(tid: Tid,this$198: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
    mover2244904 := m#moverPath(moverPath2244904);                                                  
    path2244904 := p#moverPath(moverPath2244904);                                                   
    assume Key._state2244904 == Key._state && Key._lock2244904 == Key._lock && Value._state2244904 == Value._state && Value.x2244904 == Value.x && Value._lock2244904 == Value._lock && HashEntry._state2244904 == HashEntry._state && HashEntry._lock2244904 == HashEntry._lock && Segment._state2244904 == Segment._state && Segment.segments2244904 == Segment.segments && Segment._lock2244904 == Segment._lock && Array.Segment.SegmentArray._state2244904 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244904 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244904 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244904 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244904 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244904 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244904 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244904 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244904 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244904 == Main._state && Main._lock2244904 == Main._lock && t$1982244904 == t$198 && i$1982244904 == i$198 && this$1982244904 == this$198 && seg$1972244904 == seg$197 && i$1972244904 == i$197 && segments$1972244904 == segments$197 && this$1972244904 == this$197 && seg$1962244904 == seg$196 && i$1962244904 == i$196 && segments$1962244904 == segments$196 && this$1962244904 == this$196 && c2244904 == c && this2244904 == this && tid2244904 == tid && $pc2244904 == $pc;
    assume $recorded.state2244904 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this$198 != Value.null;                                                                 
    } else {                                                                                        
     assert this$198 != Value.null;                                                                        // (15.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, mover2244904);                                                           
    assert $pc != PhaseError;                                                                              // (15.13): Reduction failure
    t$198 := Value.x[this$198];                                                                     
                                                                                                    
    // 16.19: t$198 = t$198 + 1;                                                                    
                                                                                                    
    t$198 := (t$198+1);                                                                             
                                                                                                    
                                                                                                    
    // 17.13: this$198.x := t$198;                                                                  
                                                                                                    
                                                                                                    
    moverPath2244914 := WriteEval.Value.x(tid: Tid,this$198: Value,t$198: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
    mover2244914 := m#moverPath(moverPath2244914);                                                  
    path2244914 := p#moverPath(moverPath2244914);                                                   
    assume Key._state2244914 == Key._state && Key._lock2244914 == Key._lock && Value._state2244914 == Value._state && Value.x2244914 == Value.x && Value._lock2244914 == Value._lock && HashEntry._state2244914 == HashEntry._state && HashEntry._lock2244914 == HashEntry._lock && Segment._state2244914 == Segment._state && Segment.segments2244914 == Segment.segments && Segment._lock2244914 == Segment._lock && Array.Segment.SegmentArray._state2244914 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244914 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244914 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244914 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244914 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244914 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244914 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244914 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244914 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244914 == Main._state && Main._lock2244914 == Main._lock && t$1982244914 == t$198 && i$1982244914 == i$198 && this$1982244914 == this$198 && seg$1972244914 == seg$197 && i$1972244914 == i$197 && segments$1972244914 == segments$197 && this$1972244914 == this$197 && seg$1962244914 == seg$196 && i$1962244914 == i$196 && segments$1962244914 == segments$196 && this$1962244914 == this$196 && c2244914 == c && this2244914 == this && tid2244914 == tid && $pc2244914 == $pc;
    assume $recorded.state2244914 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume this$198 != Value.null;                                                                 
    } else {                                                                                        
     assert this$198 != Value.null;                                                                        // (17.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover2244914);                                                           
    assert $pc != PhaseError;                                                                              // (17.13): Reduction failure
    Value.x[this$198] := t$198;                                                                     
                                                                                                    
    // 12.39: i$198 = i$198 + 1;                                                                    
                                                                                                    
    i$198 := (i$198+1);                                                                             
    assume Key._state2244928_bottom == Key._state && Key._lock2244928_bottom == Key._lock && Value._state2244928_bottom == Value._state && Value.x2244928_bottom == Value.x && Value._lock2244928_bottom == Value._lock && HashEntry._state2244928_bottom == HashEntry._state && HashEntry._lock2244928_bottom == HashEntry._lock && Segment._state2244928_bottom == Segment._state && Segment.segments2244928_bottom == Segment.segments && Segment._lock2244928_bottom == Segment._lock && Array.Segment.SegmentArray._state2244928_bottom == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244928_bottom == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244928_bottom == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244928_bottom == ConcurrentHashMap._state && ConcurrentHashMap.segments2244928_bottom == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244928_bottom == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244928_bottom == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244928_bottom == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244928_bottom == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244928_bottom == Main._state && Main._lock2244928_bottom == Main._lock && i$1982244928_bottom == i$198 && this$1982244928_bottom == this$198 && seg$1972244928_bottom == seg$197 && i$1972244928_bottom == i$197 && segments$1972244928_bottom == segments$197 && this$1972244928_bottom == this$197 && seg$1962244928_bottom == seg$196 && i$1962244928_bottom == i$196 && segments$1962244928_bottom == segments$196 && this$1962244928_bottom == this$196 && c2244928_bottom == c && this2244928_bottom == this && tid2244928_bottom == tid;
    assume $recorded.state2244928_bottom == 1;                                                      
    assert phase2244928 == $pc;                                                                            // (12.27): Phase must be invariant at loop head
   }                                                                                                
                                                                                                    
   // 10.17: break exit$198;                                                                        
                                                                                                    
   goto exit$198_bottom;                                                                            
   exit$198_bottom:                                                                                 
                                                                                                    
   // 40.13: segments$197[i$197] := seg$197;                                                        
                                                                                                    
                                                                                                    
   moverPath2244941 := WriteEval.Array.Segment.SegmentArray(tid: Tid,this$197: Segment,segments$197: Array.Segment.SegmentArray,i$197: int,seg$197: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
   mover2244941 := m#moverPath(moverPath2244941);                                                   
   path2244941 := p#moverPath(moverPath2244941);                                                    
   assume Key._state2244941 == Key._state && Key._lock2244941 == Key._lock && Value._state2244941 == Value._state && Value.x2244941 == Value.x && Value._lock2244941 == Value._lock && HashEntry._state2244941 == HashEntry._state && HashEntry._lock2244941 == HashEntry._lock && Segment._state2244941 == Segment._state && Segment.segments2244941 == Segment.segments && Segment._lock2244941 == Segment._lock && Array.Segment.SegmentArray._state2244941 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244941 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244941 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244941 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244941 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244941 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244941 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244941 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244941 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244941 == Main._state && Main._lock2244941 == Main._lock && seg$1972244941 == seg$197 && i$1972244941 == i$197 && segments$1972244941 == segments$197 && this$1972244941 == this$197 && seg$1962244941 == seg$196 && i$1962244941 == i$196 && segments$1962244941 == segments$196 && this$1962244941 == this$196 && c2244941 == c && this2244941 == this && tid2244941 == tid && $pc2244941 == $pc;
   assume $recorded.state2244941 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume segments$197 != Array.Segment.SegmentArray.null;                                         
   } else {                                                                                         
    assert segments$197 != Array.Segment.SegmentArray.null;                                                // (40.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume 0 <= i$197;                                                                              
   } else {                                                                                         
    assert 0 <= i$197;                                                                                     // (40.13): index < 0.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume i$197 < Array.Segment.SegmentArray._length[segments$197];                                
   } else {                                                                                         
    assert i$197 < Array.Segment.SegmentArray._length[segments$197];                                       // (40.13): index is >= length.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover2244941);                                                            
   assert $pc != PhaseError;                                                                               // (40.13): Reduction failure
   Array.Segment.SegmentArray._elems[segments$197][i$197] := seg$197;                               
   if (isLocal(Value._state[seg$197], tid)) {                                                       
    Value._state[seg$197] := SHARED();                                                              
   }                                                                                                
                                                                                                    
                                                                                                    
   // 34.39: i$197 = i$197 + 1;                                                                     
                                                                                                    
   i$197 := (i$197+1);                                                                              
   assume Key._state2244983_bottom == Key._state && Key._lock2244983_bottom == Key._lock && Value._state2244983_bottom == Value._state && Value.x2244983_bottom == Value.x && Value._lock2244983_bottom == Value._lock && HashEntry._state2244983_bottom == HashEntry._state && HashEntry._lock2244983_bottom == HashEntry._lock && Segment._state2244983_bottom == Segment._state && Segment.segments2244983_bottom == Segment.segments && Segment._lock2244983_bottom == Segment._lock && Array.Segment.SegmentArray._state2244983_bottom == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244983_bottom == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244983_bottom == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244983_bottom == ConcurrentHashMap._state && ConcurrentHashMap.segments2244983_bottom == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244983_bottom == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244983_bottom == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244983_bottom == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244983_bottom == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244983_bottom == Main._state && Main._lock2244983_bottom == Main._lock && i$1972244983_bottom == i$197 && segments$1972244983_bottom == segments$197 && this$1972244983_bottom == this$197 && seg$1962244983_bottom == seg$196 && i$1962244983_bottom == i$196 && segments$1962244983_bottom == segments$196 && this$1962244983_bottom == this$196 && c2244983_bottom == c && this2244983_bottom == this && tid2244983_bottom == tid;
   assume $recorded.state2244983_bottom == 1;                                                       
   assert phase2244983 == $pc;                                                                             // (34.27): Phase must be invariant at loop head
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 42.9: this$197.segments := segments$197;                                                       
                                                                                                    
                                                                                                    
  moverPath2244986 := WriteEval.Segment.segments(tid: Tid,this$197: Segment,segments$197: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
  mover2244986 := m#moverPath(moverPath2244986);                                                    
  path2244986 := p#moverPath(moverPath2244986);                                                     
  assume Key._state2244986 == Key._state && Key._lock2244986 == Key._lock && Value._state2244986 == Value._state && Value.x2244986 == Value.x && Value._lock2244986 == Value._lock && HashEntry._state2244986 == HashEntry._state && HashEntry._lock2244986 == HashEntry._lock && Segment._state2244986 == Segment._state && Segment.segments2244986 == Segment.segments && Segment._lock2244986 == Segment._lock && Array.Segment.SegmentArray._state2244986 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244986 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244986 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244986 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244986 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244986 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244986 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244986 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244986 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244986 == Main._state && Main._lock2244986 == Main._lock && i$1972244986 == i$197 && segments$1972244986 == segments$197 && this$1972244986 == this$197 && seg$1962244986 == seg$196 && i$1962244986 == i$196 && segments$1962244986 == segments$196 && this$1962244986 == this$196 && c2244986 == c && this2244986 == this && tid2244986 == tid && $pc2244986 == $pc;
  assume $recorded.state2244986 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$197 != Segment.null;                                                                 
  } else {                                                                                          
   assert this$197 != Segment.null;                                                                        // (42.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2244986);                                                             
  assert $pc != PhaseError;                                                                                // (42.9): Reduction failure
  Segment.segments[this$197] := segments$197;                                                       
  if (isLocal(Array.Segment.SegmentArray._state[segments$197], tid)) {                              
   Array.Segment.SegmentArray._state[segments$197] := SHARED();                                     
   assert (forall _index : int :: 0 <= _index && _index < Array.Segment.SegmentArray._length[segments$197] ==> isSharedAssignable(Value._state[Array.Segment.SegmentArray._elems[segments$197][_index]]));       // (42.9): segments$197 became shared, but some element may not be shared.
   if (isLocal(Segment._state[Array.Segment.SegmentArray._this[segments$197]], tid)) {              
    Segment._state[Array.Segment.SegmentArray._this[segments$197]] := SHARED();                     
    assert isSharedAssignable(Array.Segment.SegmentArray._state[Segment.segments[Array.Segment.SegmentArray._this[segments$197]]]);       // (42.9): segments$197 became shared, but Array.Segment.SegmentArray._this[segments$197].segments may not be shared.
   }                                                                                                
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 32.17: break exit$197;                                                                         
                                                                                                    
  goto exit$197_bottom;                                                                             
  exit$197_bottom:                                                                                  
                                                                                                    
  // 64.13: segments$196[i$196] := seg$196;                                                         
                                                                                                    
                                                                                                    
  moverPath2244999 := WriteEval.Array.ConcurrentHashMap.SegmentArray(tid: Tid,this$196: ConcurrentHashMap,segments$196: Array.ConcurrentHashMap.SegmentArray,i$196: int,seg$196: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
  mover2244999 := m#moverPath(moverPath2244999);                                                    
  path2244999 := p#moverPath(moverPath2244999);                                                     
  assume Key._state2244999 == Key._state && Key._lock2244999 == Key._lock && Value._state2244999 == Value._state && Value.x2244999 == Value.x && Value._lock2244999 == Value._lock && HashEntry._state2244999 == HashEntry._state && HashEntry._lock2244999 == HashEntry._lock && Segment._state2244999 == Segment._state && Segment.segments2244999 == Segment.segments && Segment._lock2244999 == Segment._lock && Array.Segment.SegmentArray._state2244999 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2244999 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2244999 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2244999 == ConcurrentHashMap._state && ConcurrentHashMap.segments2244999 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2244999 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2244999 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2244999 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2244999 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2244999 == Main._state && Main._lock2244999 == Main._lock && seg$1962244999 == seg$196 && i$1962244999 == i$196 && segments$1962244999 == segments$196 && this$1962244999 == this$196 && c2244999 == c && this2244999 == this && tid2244999 == tid && $pc2244999 == $pc;
  assume $recorded.state2244999 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume segments$196 != Array.ConcurrentHashMap.SegmentArray.null;                                
  } else {                                                                                          
   assert segments$196 != Array.ConcurrentHashMap.SegmentArray.null;                                       // (64.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume 0 <= i$196;                                                                               
  } else {                                                                                          
   assert 0 <= i$196;                                                                                      // (64.13): index < 0.
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume i$196 < Array.ConcurrentHashMap.SegmentArray._length[segments$196];                       
  } else {                                                                                          
   assert i$196 < Array.ConcurrentHashMap.SegmentArray._length[segments$196];                              // (64.13): index is >= length.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2244999);                                                             
  assert $pc != PhaseError;                                                                                // (64.13): Reduction failure
  Array.ConcurrentHashMap.SegmentArray._elems[segments$196][i$196] := seg$196;                      
  if (isLocal(Segment._state[seg$196], tid)) {                                                      
   Segment._state[seg$196] := SHARED();                                                             
   assert isSharedAssignable(Array.Segment.SegmentArray._state[Segment.segments[seg$196]]);                // (64.13): seg$196 became shared, but seg$196.segments may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 58.52: i$196 = i$196 + 1;                                                                      
                                                                                                    
  i$196 := (i$196+1);                                                                               
  assume Key._state2245041_bottom == Key._state && Key._lock2245041_bottom == Key._lock && Value._state2245041_bottom == Value._state && Value.x2245041_bottom == Value.x && Value._lock2245041_bottom == Value._lock && HashEntry._state2245041_bottom == HashEntry._state && HashEntry._lock2245041_bottom == HashEntry._lock && Segment._state2245041_bottom == Segment._state && Segment.segments2245041_bottom == Segment.segments && Segment._lock2245041_bottom == Segment._lock && Array.Segment.SegmentArray._state2245041_bottom == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2245041_bottom == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2245041_bottom == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2245041_bottom == ConcurrentHashMap._state && ConcurrentHashMap.segments2245041_bottom == ConcurrentHashMap.segments && ConcurrentHashMap._lock2245041_bottom == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2245041_bottom == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2245041_bottom == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2245041_bottom == Array.ConcurrentHashMap.SegmentArray._length && Main._state2245041_bottom == Main._state && Main._lock2245041_bottom == Main._lock && i$1962245041_bottom == i$196 && segments$1962245041_bottom == segments$196 && this$1962245041_bottom == this$196 && c2245041_bottom == c && this2245041_bottom == this && tid2245041_bottom == tid;
  assume $recorded.state2245041_bottom == 1;                                                        
  assert phase2245041 == $pc;                                                                              // (58.27): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 67.9: this$196.segments := segments$196;                                                        
                                                                                                    
                                                                                                    
 moverPath2245044 := WriteEval.ConcurrentHashMap.segments(tid: Tid,this$196: ConcurrentHashMap,segments$196: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 mover2245044 := m#moverPath(moverPath2245044);                                                     
 path2245044 := p#moverPath(moverPath2245044);                                                      
 assume Key._state2245044 == Key._state && Key._lock2245044 == Key._lock && Value._state2245044 == Value._state && Value.x2245044 == Value.x && Value._lock2245044 == Value._lock && HashEntry._state2245044 == HashEntry._state && HashEntry._lock2245044 == HashEntry._lock && Segment._state2245044 == Segment._state && Segment.segments2245044 == Segment.segments && Segment._lock2245044 == Segment._lock && Array.Segment.SegmentArray._state2245044 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2245044 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2245044 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2245044 == ConcurrentHashMap._state && ConcurrentHashMap.segments2245044 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2245044 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2245044 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2245044 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2245044 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2245044 == Main._state && Main._lock2245044 == Main._lock && i$1962245044 == i$196 && segments$1962245044 == segments$196 && this$1962245044 == this$196 && c2245044 == c && this2245044 == this && tid2245044 == tid && $pc2245044 == $pc;
 assume $recorded.state2245044 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$196 != ConcurrentHashMap.null;                                                        
 } else {                                                                                           
  assert this$196 != ConcurrentHashMap.null;                                                               // (67.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2245044);                                                              
 assert $pc != PhaseError;                                                                                 // (67.9): Reduction failure
 ConcurrentHashMap.segments[this$196] := segments$196;                                              
 if (isLocal(Array.ConcurrentHashMap.SegmentArray._state[segments$196], tid)) {                     
  Array.ConcurrentHashMap.SegmentArray._state[segments$196] := SHARED();                            
  assert (forall _index : int :: 0 <= _index && _index < Array.ConcurrentHashMap.SegmentArray._length[segments$196] ==> isSharedAssignable(Segment._state[Array.ConcurrentHashMap.SegmentArray._elems[segments$196][_index]]));       // (67.9): segments$196 became shared, but some element may not be shared.
  if (isLocal(ConcurrentHashMap._state[Array.ConcurrentHashMap.SegmentArray._this[segments$196]], tid)) {
   ConcurrentHashMap._state[Array.ConcurrentHashMap.SegmentArray._this[segments$196]] := SHARED();  
   assert isSharedAssignable(Array.ConcurrentHashMap.SegmentArray._state[ConcurrentHashMap.segments[Array.ConcurrentHashMap.SegmentArray._this[segments$196]]]);       // (67.9): segments$196 became shared, but Array.ConcurrentHashMap.SegmentArray._this[segments$196].segments may not be shared.
  }                                                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 56.17: break exit$196;                                                                          
                                                                                                    
 goto exit$196_bottom;                                                                              
 exit$196_bottom:                                                                                   
                                                                                                    
 // 73.23: // return;                                                                               
                                                                                                    
 assume Key._state2245054 == Key._state && Key._lock2245054 == Key._lock && Value._state2245054 == Value._state && Value.x2245054 == Value.x && Value._lock2245054 == Value._lock && HashEntry._state2245054 == HashEntry._state && HashEntry._lock2245054 == HashEntry._lock && Segment._state2245054 == Segment._state && Segment.segments2245054 == Segment.segments && Segment._lock2245054 == Segment._lock && Array.Segment.SegmentArray._state2245054 == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems2245054 == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length2245054 == Array.Segment.SegmentArray._length && ConcurrentHashMap._state2245054 == ConcurrentHashMap._state && ConcurrentHashMap.segments2245054 == ConcurrentHashMap.segments && ConcurrentHashMap._lock2245054 == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state2245054 == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems2245054 == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length2245054 == Array.ConcurrentHashMap.SegmentArray._length && Main._state2245054 == Main._state && Main._lock2245054 == Main._lock && c2245054 == c && this2245054 == this && tid2245054 == tid;
 assume $recorded.state2245054 == 1;                                                                
 assert  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.23): Object invariant may not hold.
 assert  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.23): Object invariant may not hold.
 assert  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (73.23): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Key._state: [Key]State,Key._lock: [Key]Tid,Value._state: [Value]State,Value.x: [Value]int,Value._lock: [Value]Tid,HashEntry._state: [HashEntry]State,HashEntry._lock: [HashEntry]Tid,Segment._state: [Segment]State,Segment.segments: [Segment]Array.Segment.SegmentArray,Segment._lock: [Segment]Tid,Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State,Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value),Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int,ConcurrentHashMap._state: [ConcurrentHashMap]State,ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray,ConcurrentHashMap._lock: [ConcurrentHashMap]Tid,Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State,Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment),Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Key  :: _i == Key.null <==> isNull(Key._state[_i])) &&                                
  (forall _i: Value  :: _i == Value.null <==> isNull(Value._state[_i])) &&                          
  (forall _i: HashEntry  :: _i == HashEntry.null <==> isNull(HashEntry._state[_i])) &&              
  (forall _i: Segment  :: _i == Segment.null <==> isNull(Segment._state[_i])) &&                    
  (forall _i: Array.Segment.SegmentArray  :: _i == Array.Segment.SegmentArray.null <==> isNull(Array.Segment.SegmentArray._state[_i])) &&
  (forall _i: ConcurrentHashMap  :: _i == ConcurrentHashMap.null <==> isNull(ConcurrentHashMap._state[_i])) &&
  (forall _i: Array.ConcurrentHashMap.SegmentArray  :: _i == Array.ConcurrentHashMap.SegmentArray.null <==> isNull(Array.ConcurrentHashMap.SegmentArray._state[_i])) &&
  (forall _i: Main  :: _i == Main.null <==> isNull(Main._state[_i])) &&                             
  (forall _t: Tid, _i: Array.Segment.SegmentArray  :: ValidTid(_t) && isAccessible(Array.Segment.SegmentArray._state[_i], _t) ==> isAccessible(Segment._state[Array.Segment.SegmentArray._this[_i]], _t)) &&
  (forall _t: Tid, _i: Array.ConcurrentHashMap.SegmentArray  :: ValidTid(_t) && isAccessible(Array.ConcurrentHashMap.SegmentArray._state[_i], _t) ==> isAccessible(ConcurrentHashMap._state[Array.ConcurrentHashMap.SegmentArray._this[_i]], _t)) &&
  (forall _i: Segment ::  (isShared(Segment._state[_i]) ==> isSharedAssignable(Array.Segment.SegmentArray._state[Segment.segments[_i]]))) &&
  (forall _i: Segment ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Segment._state[_i],_t) ==> isLocalAssignable(Array.Segment.SegmentArray._state[Segment.segments[_i]], _t)))) &&
  (forall _i: Segment :: { Segment.segments[_i] } Array.Segment.SegmentArray._this[Segment.segments[_i]] == _i) &&
  (forall _i: Array.Segment.SegmentArray, _index: int ::  (isShared(Array.Segment.SegmentArray._state[_i]) && 0 <= _index && _index < Array.Segment.SegmentArray._length[_i]) ==> isSharedAssignable(Value._state[Array.Segment.SegmentArray._elems[_i][_index]])) &&
  (forall _i: Array.Segment.SegmentArray, _index: int ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Array.Segment.SegmentArray._state[_i],_t) && 0 <= _index && _index < Array.Segment.SegmentArray._length[_i]) ==> isLocalAssignable(Value._state[Array.Segment.SegmentArray._elems[_i][_index]], _t))) &&
  (forall _i: ConcurrentHashMap ::  (isShared(ConcurrentHashMap._state[_i]) ==> isSharedAssignable(Array.ConcurrentHashMap.SegmentArray._state[ConcurrentHashMap.segments[_i]]))) &&
  (forall _i: ConcurrentHashMap ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(ConcurrentHashMap._state[_i],_t) ==> isLocalAssignable(Array.ConcurrentHashMap.SegmentArray._state[ConcurrentHashMap.segments[_i]], _t)))) &&
  (forall _i: ConcurrentHashMap :: { ConcurrentHashMap.segments[_i] } Array.ConcurrentHashMap.SegmentArray._this[ConcurrentHashMap.segments[_i]] == _i) &&
  (forall _i: Array.ConcurrentHashMap.SegmentArray, _index: int ::  (isShared(Array.ConcurrentHashMap.SegmentArray._state[_i]) && 0 <= _index && _index < Array.ConcurrentHashMap.SegmentArray._length[_i]) ==> isSharedAssignable(Segment._state[Array.ConcurrentHashMap.SegmentArray._elems[_i][_index]])) &&
  (forall _i: Array.ConcurrentHashMap.SegmentArray, _index: int ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Array.ConcurrentHashMap.SegmentArray._state[_i],_t) && 0 <= _index && _index < Array.ConcurrentHashMap.SegmentArray._length[_i]) ==> isLocalAssignable(Segment._state[Array.ConcurrentHashMap.SegmentArray._elems[_i][_index]], _t))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)            
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Value.x(u: Tid,x: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Value.x failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)             
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Value.x(u: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.5): Value.x failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)             
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Value.x[x];                                                                            
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Value.x[x] := havocValue;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Value.x(u: Tid,x: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Value.x failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)              
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Value.x[x];                                                                            
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Value.x(u: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.5): Value.x failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)                  
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Value.x(u: Tid,x: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Value.x failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Value.x(t: Tid, u: Tid, v: int, w: int, x: Value)                   
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[x], u);                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Value.x[x];                                                                            
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Value.x[x] := havocValue;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Value.x(u: Tid,x: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Value.x failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Segment.segments(u: Tid,x: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (28.5): Segment.segments failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Segment.segments(u: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (28.5): Segment.segments failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Segment.SegmentArray;                                                       
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Segment.segments[x];                                                                   
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Segment.segments[x] := havocValue;                                                                 
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Segment.segments(u: Tid,x: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (28.5): Segment.segments failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.Segment.SegmentArray;                                                       
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Segment.segments[x];                                                                   
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Segment.segments(u: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (28.5): Segment.segments failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,x: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (28.5): Segment.segments failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, x: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[x], u);                                                       
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Segment.SegmentArray;                                                       
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Segment.segments[x];                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Segment.segments[x] := havocValue;                                                                 
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,x: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (28.5): Segment.segments failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (26.5): Array Array.Segment.SegmentArray failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (26.5): Array Array.Segment.SegmentArray failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Value;                                                                            
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Segment.SegmentArray._elems[x][i];                                               
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := havocValue;                                             
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (26.5): Array Array.Segment.SegmentArray failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Value;                                                                            
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Segment.SegmentArray._elems[x][i];                                               
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (26.5): Array Array.Segment.SegmentArray failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (26.5): Array Array.Segment.SegmentArray failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[x], u);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Value;                                                                            
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Array.Segment.SegmentArray._elems[x][i];                                               
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.Segment.SegmentArray._elems[x][i] := havocValue;                                             
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (26.5): Array Array.Segment.SegmentArray failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (52.5): ConcurrentHashMap.segments failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (52.5): ConcurrentHashMap.segments failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.ConcurrentHashMap.SegmentArray;                                             
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == ConcurrentHashMap.segments[x];                                                         
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 ConcurrentHashMap.segments[x] := havocValue;                                                       
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (52.5): ConcurrentHashMap.segments failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.ConcurrentHashMap.SegmentArray;                                             
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == ConcurrentHashMap.segments[x];                                                         
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (52.5): ConcurrentHashMap.segments failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (52.5): ConcurrentHashMap.segments failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[x], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.ConcurrentHashMap.SegmentArray;                                             
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == ConcurrentHashMap.segments[x];                                                         
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 ConcurrentHashMap.segments[x] := havocValue;                                                       
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,x: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (52.5): ConcurrentHashMap.segments failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Segment;                                                                          
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                     
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := havocValue;                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Segment;                                                                          
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                     
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Segment;                                                                          
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                     
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := havocValue;                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Value.x.Value.x(t: Tid, u: Tid, v: int, w: int, w0: int, x: Value, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[y], u);                                                         
 modifies Value.x;                                                                                  
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Value.x.Value.x(t: Tid, u: Tid, v: int, w: int, w0: int, x: Value, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[y], u);                                                         
 modifies Value.x;                                                                                  
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Value.x.Value.x(t: Tid, u: Tid, v: int, w: int, w0: int, x: Value, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[y], u);                                                         
 modifies Value.x;                                                                                  
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Value.x (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Value.x.Value.x(t: Tid, u: Tid, v: int, w: int, w0: int, x: Value, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[y], u);                                                         
 modifies Value.x;                                                                                  
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[y] := w;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Value.x (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Value.x (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Value.x (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Value.x.Value.x(t: Tid, u: Tid, v: int, w: int, w0: int, x: Value, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Value._state[y], u);                                                         
 modifies Value.x;                                                                                  
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Value.x (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Value.x (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Value.x is not Write-Read Stable with respect to Value.x (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Value.x.Segment.segments(t: Tid, u: Tid, v: int, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Value, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Value.x;                                                                                  
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Value.x.Segment.segments(t: Tid, u: Tid, v: int, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Value, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Value.x;                                                                                  
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Value.x.Segment.segments(t: Tid, u: Tid, v: int, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Value, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Value.x;                                                                                  
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Value.x.Segment.segments(t: Tid, u: Tid, v: int, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Value, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Value.x;                                                                                  
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[y] := w;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Value.x.Segment.segments(t: Tid, u: Tid, v: int, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Value, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Value.x;                                                                                  
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Value.x.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Value, w0: Value, x: Value, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Value.x;                                                                                  
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Value.x.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Value, w0: Value, x: Value, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Value.x;                                                                                  
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Value.x.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Value, w0: Value, x: Value, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Value.x;                                                                                  
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Value.x.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Value, w0: Value, x: Value, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Value.x;                                                                                  
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Value.x.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Value, w0: Value, x: Value, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Value.x;                                                                                  
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Value.x.ConcurrentHashMap.segments(t: Tid, u: Tid, v: int, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Value, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Value.x;                                                                                  
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Value.x.ConcurrentHashMap.segments(t: Tid, u: Tid, v: int, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Value, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Value.x;                                                                                  
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Value.x.ConcurrentHashMap.segments(t: Tid, u: Tid, v: int, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Value, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Value.x;                                                                                  
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Value.x.ConcurrentHashMap.segments(t: Tid, u: Tid, v: int, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Value, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Value.x;                                                                                  
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Value.x.ConcurrentHashMap.segments(t: Tid, u: Tid, v: int, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Value, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Value.x;                                                                                  
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Value.x.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Segment, w0: Segment, x: Value, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Value.x;                                                                                  
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Value.x.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Segment, w0: Segment, x: Value, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Value.x;                                                                                  
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Value.x.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Segment, w0: Segment, x: Value, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Value.x;                                                                                  
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_mid: Value;                                                                                  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var v_mid: int;                                                                                    
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Value.x[x];                                                                                
 Value.x[x] := v;                                                                                   
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Value.x[x] := tmpV;                                                                                
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Value.x.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Segment, w0: Segment, x: Value, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Value.x;                                                                                  
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Value.x(t: Tid,x: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Value.x.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: int, w: Segment, w0: Segment, x: Value, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Value._state[x], t);                                                         
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Value.x;                                                                                  
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var x_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var x_post: Value;                                                                                 
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var v_post: int;                                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Value.x(t: Tid,x: Value,v: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[x] := v;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Segment.segments.Value.x(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: int, w0: int, x: Segment, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Value._state[y], u);                                                         
 modifies Segment.segments;                                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Segment.segments.Value.x(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: int, w0: int, x: Segment, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Value._state[y], u);                                                         
 modifies Segment.segments;                                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Segment.segments.Value.x(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: int, w0: int, x: Segment, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Value._state[y], u);                                                         
 modifies Segment.segments;                                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Segment.segments.Value.x(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: int, w0: int, x: Segment, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Value._state[y], u);                                                         
 modifies Segment.segments;                                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[y] := w;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Segment.segments.Value.x(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: int, w0: int, x: Segment, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Value._state[y], u);                                                         
 modifies Segment.segments;                                                                         
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Segment.segments.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Segment, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Segment.segments;                                                                         
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Segment.segments.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Segment, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Segment.segments;                                                                         
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Segment.segments.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Segment, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Segment.segments;                                                                         
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Segment.segments.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Segment, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Segment.segments;                                                                         
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[y] := w;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Segment.segments.Segment.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: Segment, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Segment.segments;                                                                         
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var x_pre: Segment;                                                                                
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Segment.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Value, w0: Value, x: Segment, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Segment.segments;                                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var x_pre: Segment;                                                                                
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Segment.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Value, w0: Value, x: Segment, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Segment.segments;                                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var x_pre: Segment;                                                                                
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var v_mid: Array.Segment.SegmentArray;                                                             
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Segment.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Value, w0: Value, x: Segment, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Segment.segments;                                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var x_pre: Segment;                                                                                
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var v_mid: Array.Segment.SegmentArray;                                                             
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Segment.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Value, w0: Value, x: Segment, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Segment.segments;                                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var x_pre: Segment;                                                                                
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Segment.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Value, w0: Value, x: Segment, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Segment.segments;                                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var x_pre: Segment;                                                                                
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Segment.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Segment, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Segment.segments;                                                                         
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var x_pre: Segment;                                                                                
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Segment.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Segment, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Segment.segments;                                                                         
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var x_pre: Segment;                                                                                
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Segment.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Segment, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Segment.segments;                                                                         
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var x_pre: Segment;                                                                                
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var v_mid: Array.Segment.SegmentArray;                                                             
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Segment.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Segment, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Segment.segments;                                                                         
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var x_pre: Segment;                                                                                
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Segment.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: Segment, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Segment.segments;                                                                         
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var x_pre: Segment;                                                                                
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Segment.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Segment, w0: Segment, x: Segment, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Segment.segments;                                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Segment.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Segment, w0: Segment, x: Segment, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Segment.segments;                                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Segment.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Segment, w0: Segment, x: Segment, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Segment.segments;                                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Segment.SegmentArray;                                                             
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var x_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var v_mid: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Segment.segments[x];                                                                       
 Segment.segments[x] := v;                                                                          
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Segment.segments[x] := tmpV;                                                                       
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Segment.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Segment, w0: Segment, x: Segment, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Segment.segments;                                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Segment.segments(t: Tid,x: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Segment.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.Segment.SegmentArray, w: Segment, w0: Segment, x: Segment, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Segment._state[x], t);                                                       
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Segment.segments;                                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var x_pre: Segment;                                                                                
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var v_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var v_post: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Segment;                                                                               
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Segment.segments(t: Tid,x: Segment,v: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[x] := v;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Segment.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Value, w: int, w0: int, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Segment.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Value, w: int, w0: int, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Segment.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Value, w: int, w0: int, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Segment.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Value, w: int, w0: int, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[y] := w;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Segment.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Value, w: int, w0: int, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Segment.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Value, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Segment.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Value, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Segment.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Value, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Segment.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Value, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[y] := w;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Segment.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Value, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Segment.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, w0: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Segment.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, w0: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Segment.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, w0: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Segment.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, w0: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Segment.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Value, w0: Value, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Segment.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Value, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Segment.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Value, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Segment.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Value, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Segment.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Value, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Segment.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Value, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var x_pre: Array.Segment.SegmentArray;                                                             
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Segment.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Segment, w0: Segment, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Segment.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Segment, w0: Segment, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Segment.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Segment, w0: Segment, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Value;                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var x_owner_mid: Segment;                                                                          
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var x_mid: Array.Segment.SegmentArray;                                                             
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Value;                                                                                  
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Segment.SegmentArray._elems[x][i];                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Segment.SegmentArray._elems[x][i] := tmpV;                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Segment.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Segment, w0: Segment, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Segment.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Value, w: Segment, w0: Segment, x_owner: Segment, x: Array.Segment.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Segment.SegmentArray._state[x], t);                                    
 requires Array.Segment.SegmentArray._this[x] == x_owner;                                           
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.Segment.SegmentArray._elems;                                                        
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_pre: Array.Segment.SegmentArray;                                                             
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var v_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var x_owner_pre: Segment;                                                                          
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_post: Array.Segment.SegmentArray;                                                            
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Value;                                                                                 
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var x_owner_post: Segment;                                                                         
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Segment.SegmentArray(t: Tid,x_owner: Segment,x: Array.Segment.SegmentArray,i: int,v: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[x][i] := v;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.ConcurrentHashMap.segments.Value.x(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: int, w0: int, x: ConcurrentHashMap, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Value._state[y], u);                                                         
 modifies ConcurrentHashMap.segments;                                                               
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.ConcurrentHashMap.segments.Value.x(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: int, w0: int, x: ConcurrentHashMap, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Value._state[y], u);                                                         
 modifies ConcurrentHashMap.segments;                                                               
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.ConcurrentHashMap.segments.Value.x(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: int, w0: int, x: ConcurrentHashMap, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Value._state[y], u);                                                         
 modifies ConcurrentHashMap.segments;                                                               
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.ConcurrentHashMap.segments.Value.x(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: int, w0: int, x: ConcurrentHashMap, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Value._state[y], u);                                                         
 modifies ConcurrentHashMap.segments;                                                               
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[y] := w;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.ConcurrentHashMap.segments.Value.x(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: int, w0: int, x: ConcurrentHashMap, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Value._state[y], u);                                                         
 modifies ConcurrentHashMap.segments;                                                               
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.ConcurrentHashMap.segments.Segment.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: ConcurrentHashMap, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Segment._state[y], u);                                                       
 modifies ConcurrentHashMap.segments;                                                               
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.ConcurrentHashMap.segments.Segment.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: ConcurrentHashMap, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Segment._state[y], u);                                                       
 modifies ConcurrentHashMap.segments;                                                               
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.ConcurrentHashMap.segments.Segment.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: ConcurrentHashMap, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Segment._state[y], u);                                                       
 modifies ConcurrentHashMap.segments;                                                               
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.ConcurrentHashMap.segments.Segment.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: ConcurrentHashMap, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Segment._state[y], u);                                                       
 modifies ConcurrentHashMap.segments;                                                               
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[y] := w;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.ConcurrentHashMap.segments.Segment.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x: ConcurrentHashMap, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Segment._state[y], u);                                                       
 modifies ConcurrentHashMap.segments;                                                               
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.ConcurrentHashMap.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Value, w0: Value, x: ConcurrentHashMap, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.ConcurrentHashMap.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Value, w0: Value, x: ConcurrentHashMap, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.ConcurrentHashMap.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Value, w0: Value, x: ConcurrentHashMap, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.ConcurrentHashMap.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Value, w0: Value, x: ConcurrentHashMap, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.ConcurrentHashMap.segments.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Value, w0: Value, x: ConcurrentHashMap, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.ConcurrentHashMap.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.ConcurrentHashMap.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.ConcurrentHashMap.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.ConcurrentHashMap.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.ConcurrentHashMap.segments.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x: ConcurrentHashMap, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies ConcurrentHashMap.segments;                                                               
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.ConcurrentHashMap.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Segment, w0: Segment, x: ConcurrentHashMap, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.ConcurrentHashMap.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Segment, w0: Segment, x: ConcurrentHashMap, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.ConcurrentHashMap.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Segment, w0: Segment, x: ConcurrentHashMap, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.ConcurrentHashMap.SegmentArray;                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: ConcurrentHashMap;                                                                      
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var $recorded.state_mid: int;                                                                      
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var v_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := ConcurrentHashMap.segments[x];                                                             
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 ConcurrentHashMap.segments[x] := tmpV;                                                             
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.ConcurrentHashMap.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Segment, w0: Segment, x: ConcurrentHashMap, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.ConcurrentHashMap.segments.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Array.ConcurrentHashMap.SegmentArray, w: Segment, w0: Segment, x: ConcurrentHashMap, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(ConcurrentHashMap._state[x], t);                                             
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies ConcurrentHashMap.segments;                                                               
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var x_pre: ConcurrentHashMap;                                                                      
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var x_post: ConcurrentHashMap;                                                                     
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var v_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.ConcurrentHashMap.segments(t: Tid,x: ConcurrentHashMap,v: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[x] := v;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.ConcurrentHashMap.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Segment, w: int, w0: int, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.ConcurrentHashMap.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Segment, w: int, w0: int, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.ConcurrentHashMap.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Segment, w: int, w0: int, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var w_mid: int;                                                                                    
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var y_mid: Value;                                                                                  
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Value.x[y] := w;                                                                                   
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.ConcurrentHashMap.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Segment, w: int, w0: int, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Value.x(u: Tid,y: Value,w: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Value.x[y] := w;                                                                                   
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.ConcurrentHashMap.SegmentArray._elems.Value.x(t: Tid, u: Tid, v: Segment, w: int, w0: int, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Value)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Value._state[y], u);                                                         
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Value.x;                                                                                  
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var y_pre: Value;                                                                                  
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w0_post: int;                                                                                  
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var y_post: Value;                                                                                 
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var w_post: int;                                                                                   
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Value.x(u: Tid,y: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.ConcurrentHashMap.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Segment, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.ConcurrentHashMap.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Segment, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.ConcurrentHashMap.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Segment, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Array.Segment.SegmentArray;                                                             
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var y_mid: Segment;                                                                                
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Array.Segment.SegmentArray;                                                            
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Segment.segments[y] := w;                                                                          
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.ConcurrentHashMap.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Segment, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Segment.segments(u: Tid,y: Segment,w: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Segment.segments[y] := w;                                                                          
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.ConcurrentHashMap.SegmentArray._elems.Segment.segments(t: Tid, u: Tid, v: Segment, w: Array.Segment.SegmentArray, w0: Array.Segment.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: Segment)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Segment._state[y], u);                                                       
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Segment.segments;                                                                         
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Segment.SegmentArray;                                                            
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.Segment.SegmentArray;                                                             
 var i_pre: int;                                                                                    
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var y_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var w0_post: Array.Segment.SegmentArray;                                                           
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var y_post: Segment;                                                                               
 var w_post: Array.Segment.SegmentArray;                                                            
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Segment.segments(u: Tid,y: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.ConcurrentHashMap.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Value, w0: Value, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.ConcurrentHashMap.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Value, w0: Value, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.ConcurrentHashMap.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Value, w0: Value, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var y_owner_mid: Segment;                                                                          
 var w_mid: Value;                                                                                  
 var Segment._lock_mid: [Segment]Tid;                                                               
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.Segment.SegmentArray;                                                             
 var w0_mid: Value;                                                                                 
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.ConcurrentHashMap.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Value, w0: Value, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,w: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Segment.SegmentArray._elems[y][j] := w;                                                      
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.ConcurrentHashMap.SegmentArray._elems.Array.Segment.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Value, w0: Value, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: Segment, y: Array.Segment.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.Segment.SegmentArray._state[y], u);                                    
 requires Array.Segment.SegmentArray._this[y] == y_owner;                                           
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.Segment.SegmentArray._elems;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var y_pre: Array.Segment.SegmentArray;                                                             
 var Main._lock_pre: [Main]Tid;                                                                     
 var y_owner_pre: Segment;                                                                          
 var i_pre: int;                                                                                    
 var w0_pre: Value;                                                                                 
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var w_pre: Value;                                                                                  
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var w0_post: Value;                                                                                
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var y_post: Array.Segment.SegmentArray;                                                            
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var y_owner_post: Segment;                                                                         
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var w_post: Value;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Segment.SegmentArray(u: Tid,y_owner: Segment,y: Array.Segment.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.ConcurrentHashMap.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Segment, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.ConcurrentHashMap.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Segment, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.ConcurrentHashMap.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Segment, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var x_owner_pre: ConcurrentHashMap;                                                                
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w0_mid: Array.ConcurrentHashMap.SegmentArray;                                                  
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var y_mid: ConcurrentHashMap;                                                                      
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var w_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 ConcurrentHashMap.segments[y] := w;                                                                
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.ConcurrentHashMap.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Segment, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var x_owner_pre: ConcurrentHashMap;                                                                
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,w: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 ConcurrentHashMap.segments[y] := w;                                                                
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.ConcurrentHashMap.SegmentArray._elems.ConcurrentHashMap.segments(t: Tid, u: Tid, v: Segment, w: Array.ConcurrentHashMap.SegmentArray, w0: Array.ConcurrentHashMap.SegmentArray, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y: ConcurrentHashMap)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(ConcurrentHashMap._state[y], u);                                             
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies ConcurrentHashMap.segments;                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var x_owner_pre: ConcurrentHashMap;                                                                
 var w0_pre: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var w_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var i_pre: int;                                                                                    
 var y_pre: ConcurrentHashMap;                                                                      
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var Value.x_pre: [Value]int;                                                                       
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Array.ConcurrentHashMap.SegmentArray;                                                 
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var w_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var y_post: ConcurrentHashMap;                                                                     
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.ConcurrentHashMap.segments(u: Tid,y: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.ConcurrentHashMap.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, w0: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.ConcurrentHashMap.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, w0: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
                                                                                                    
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.ConcurrentHashMap.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, w0: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Segment;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var x_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.ConcurrentHashMap.SegmentArray._state_mid: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_mid: Tid;                                                                                    
 var v_mid: Segment;                                                                                
 var Value.x_mid: [Value]int;                                                                       
 var Segment._lock_mid: [Segment]Tid;                                                               
 var w_mid: Segment;                                                                                
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var x_owner_mid: ConcurrentHashMap;                                                                
 var Array.Segment.SegmentArray._state_mid: [Array.Segment.SegmentArray]State;                      
 var Main._state_mid: [Main]State;                                                                  
 var HashEntry._state_mid: [HashEntry]State;                                                        
 var ConcurrentHashMap.segments_mid: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.Segment.SegmentArray._length_mid: [Array.Segment.SegmentArray]int;                       
 var ConcurrentHashMap._lock_mid: [ConcurrentHashMap]Tid;                                           
 var Key._lock_mid: [Key]Tid;                                                                       
 var Key._state_mid: [Key]State;                                                                    
 var w0_mid: Segment;                                                                               
 var Array.Segment.SegmentArray._elems_mid: [Array.Segment.SegmentArray]([int]Value);               
 var HashEntry._lock_mid: [HashEntry]Tid;                                                           
 var Value._lock_mid: [Value]Tid;                                                                   
 var Array.ConcurrentHashMap.SegmentArray._elems_mid: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Value._state_mid: [Value]State;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_mid: [Array.ConcurrentHashMap.SegmentArray]int;   
 var Segment.segments_mid: [Segment]Array.Segment.SegmentArray;                                     
 var j_mid: int;                                                                                    
 var y_mid: Array.ConcurrentHashMap.SegmentArray;                                                   
 var ConcurrentHashMap._state_mid: [ConcurrentHashMap]State;                                        
 var Segment._state_mid: [Segment]State;                                                            
 var $pc_mid: Phase;                                                                                
 var y_owner_mid: ConcurrentHashMap;                                                                
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.ConcurrentHashMap.SegmentArray._elems[x][i];                                         
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_mid == Key._state && Key._lock_mid == Key._lock && Value._state_mid == Value._state && Value.x_mid == Value.x && Value._lock_mid == Value._lock && HashEntry._state_mid == HashEntry._state && HashEntry._lock_mid == HashEntry._lock && Segment._state_mid == Segment._state && Segment.segments_mid == Segment.segments && Segment._lock_mid == Segment._lock && Array.Segment.SegmentArray._state_mid == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_mid == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_mid == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_mid == ConcurrentHashMap._state && ConcurrentHashMap.segments_mid == ConcurrentHashMap.segments && ConcurrentHashMap._lock_mid == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_mid == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_mid == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_mid == Array.ConcurrentHashMap.SegmentArray._length && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := tmpV;                                         
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 _writeByTPost := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.ConcurrentHashMap.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, w0: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,w: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[y][j] := w;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.ConcurrentHashMap.SegmentArray._elems.Array.ConcurrentHashMap.SegmentArray._elems(t: Tid, u: Tid, v: Segment, w: Segment, w0: Segment, x_owner: ConcurrentHashMap, x: Array.ConcurrentHashMap.SegmentArray, i: int, y_owner: ConcurrentHashMap, y: Array.ConcurrentHashMap.SegmentArray, j: int)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[x], t);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[x] == x_owner;                                 
 requires isAccessible(Array.ConcurrentHashMap.SegmentArray._state[y], u);                          
 requires Array.ConcurrentHashMap.SegmentArray._this[y] == y_owner;                                 
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
 modifies Array.ConcurrentHashMap.SegmentArray._elems;                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var x_owner_pre: ConcurrentHashMap;                                                                
 var v_pre: Segment;                                                                                
 var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                           
 var HashEntry._lock_pre: [HashEntry]Tid;                                                           
 var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                        
 var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                     
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Value._lock_pre: [Value]Tid;                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var i_pre: int;                                                                                    
 var y_pre: Array.ConcurrentHashMap.SegmentArray;                                                   
 var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                      
 var w_pre: Segment;                                                                                
 var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Segment._state_pre: [Segment]State;                                                            
 var Main._state_pre: [Main]State;                                                                  
 var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                       
 var $pc_pre: Phase;                                                                                
 var Key._lock_pre: [Key]Tid;                                                                       
 var HashEntry._state_pre: [HashEntry]State;                                                        
 var Value._state_pre: [Value]State;                                                                
 var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
 var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;  
 var t_pre: Tid;                                                                                    
 var Key._state_pre: [Key]State;                                                                    
 var Segment._lock_pre: [Segment]Tid;                                                               
 var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);               
 var w0_pre: Segment;                                                                               
 var Value.x_pre: [Value]int;                                                                       
 var y_owner_pre: ConcurrentHashMap;                                                                
 var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;   
                                                                                                    
 var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                          
 var Segment._state_post: [Segment]State;                                                           
 var x_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var y_post: Array.ConcurrentHashMap.SegmentArray;                                                  
 var $recorded.state_post: int;                                                                     
 var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                      
 var HashEntry._state_post: [HashEntry]State;                                                       
 var w_post: Segment;                                                                               
 var Key._lock_post: [Key]Tid;                                                                      
 var Value._lock_post: [Value]Tid;                                                                  
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Value.x_post: [Value]int;                                                                      
 var x_owner_post: ConcurrentHashMap;                                                               
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var j_post: int;                                                                                   
 var y_owner_post: ConcurrentHashMap;                                                               
 var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                    
 var v_post: Segment;                                                                               
 var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State; 
 var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);              
 var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                     
 var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                       
 var Segment._lock_post: [Segment]Tid;                                                              
 var Value._state_post: [Value]State;                                                               
 var w0_post: Segment;                                                                              
 var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
 var Main._lock_post: [Main]Tid;                                                                    
 var HashEntry._lock_post: [HashEntry]Tid;                                                          
 var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
 var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;  
 var Key._state_post: [Key]State;                                                                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.ConcurrentHashMap.SegmentArray(t: Tid,x_owner: ConcurrentHashMap,x: Array.ConcurrentHashMap.SegmentArray,i: int,v: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.ConcurrentHashMap.SegmentArray._elems[x][i] := v;                                            
 assume Key._state_post == Key._state && Key._lock_post == Key._lock && Value._state_post == Value._state && Value.x_post == Value.x && Value._lock_post == Value._lock && HashEntry._state_post == HashEntry._state && HashEntry._lock_post == HashEntry._lock && Segment._state_post == Segment._state && Segment.segments_post == Segment.segments && Segment._lock_post == Segment._lock && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_post == ConcurrentHashMap._state && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,y_owner: ConcurrentHashMap,y: Array.ConcurrentHashMap.SegmentArray,j: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
modifies Key._state;                                                                                
modifies Key._lock;                                                                                 
modifies Value._state;                                                                              
modifies Value.x;                                                                                   
modifies Value._lock;                                                                               
modifies HashEntry._state;                                                                          
modifies HashEntry._lock;                                                                           
modifies Segment._state;                                                                            
modifies Segment.segments;                                                                          
modifies Segment._lock;                                                                             
modifies Array.Segment.SegmentArray._state;                                                         
modifies Array.Segment.SegmentArray._elems;                                                         
modifies ConcurrentHashMap._state;                                                                  
modifies ConcurrentHashMap.segments;                                                                
modifies ConcurrentHashMap._lock;                                                                   
modifies Array.ConcurrentHashMap.SegmentArray._state;                                               
modifies Array.ConcurrentHashMap.SegmentArray._elems;                                               
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
ensures StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
ensures Y(tid , old(Key._state), old(Key._lock), old(Value._state), old(Value.x), old(Value._lock), old(HashEntry._state), old(HashEntry._lock), old(Segment._state), old(Segment.segments), old(Segment._lock), old(Array.Segment.SegmentArray._state), old(Array.Segment.SegmentArray._elems), old(Array.Segment.SegmentArray._length), old(ConcurrentHashMap._state), old(ConcurrentHashMap.segments), old(ConcurrentHashMap._lock), old(Array.ConcurrentHashMap.SegmentArray._state), old(Array.ConcurrentHashMap.SegmentArray._elems), old(Array.ConcurrentHashMap.SegmentArray._length), old(Main._state), old(Main._lock) , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
ensures  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Key._lock:                                                                                       
                                                                                                    
function {:inline} Y_Key._lock(tid : Tid, this: Key, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Key._state[this], tid) && leq(m#moverPath(ReadEval.Key._lock(tid: Tid,this: Key,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Key._lock[this] == newValue))
 &&(((Key._lock[this]==tid)==(newValue==tid)))                                                      
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Key._lock(tid : Tid, this: Key, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Key._lock.Subsumes.W(tid : Tid, u : Tid, this: Key, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var this_yield: Key;                                                                                
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Key._state[this], tid);                                                        
 assume isAccessible(Key._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Key._lock(u: Tid,this: Key,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Key._lock(tid: Tid,this: Key,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Key._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Key._lock.Reflexive(tid : Tid, this: Key , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var this_yield: Key;                                                                                
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Key._state[this], tid);                                                        
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Key._lock(tid, this, Key._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Key._lock.Transitive(tid : Tid, this: Key, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var this_pre: Key;                                                                                  
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: Key;                                                                                 
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Key._state[this], tid);                                                        
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Key._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Key._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Value.x:                                                                                         
                                                                                                    
function {:inline} Y_Value.x(tid : Tid, this: Value, newValue: int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Value._state[this], tid) && leq(m#moverPath(ReadEval.Value.x(tid: Tid,this: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Value.x[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Value.x(tid : Tid, this: Value, newValue: int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Value.x.Subsumes.W(tid : Tid, u : Tid, this: Value, newValue: int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Value;                                                                              
var Value._lock_yield: [Value]Tid;                                                                  
var newValue_yield: int;                                                                            
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
 assume isAccessible(Value._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Value.x(u: Tid,this: Value,newValue: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
                                                                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Value.x(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Value.x.Reflexive(tid : Tid, this: Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Value;                                                                              
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Value.x(tid, this, Value.x[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Value.x.Transitive(tid : Tid, this: Value, newValue : int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (6.11): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (6.11): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (6.11): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var this_pre: Value;                                                                                
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var newValue_pre: int;                                                                              
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var newValue_post: int;                                                                             
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: Value;                                                                               
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Value.x(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Value.x(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Value._lock:                                                                                     
                                                                                                    
function {:inline} Y_Value._lock(tid : Tid, this: Value, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Value._state[this], tid) && leq(m#moverPath(ReadEval.Value._lock(tid: Tid,this: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Value._lock[this] == newValue))
 &&(((Value._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Value._lock(tid : Tid, this: Value, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Value._lock.Subsumes.W(tid : Tid, u : Tid, this: Value, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Value;                                                                              
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
 assume isAccessible(Value._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Value._lock(u: Tid,this: Value,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Value._lock(tid: Tid,this: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Value._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Value._lock.Reflexive(tid : Tid, this: Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Value;                                                                              
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Value._lock(tid, this, Value._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Value._lock.Transitive(tid : Tid, this: Value, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (5.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (5.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (5.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var this_pre: Value;                                                                                
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: Value;                                                                               
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Value._state[this], tid);                                                      
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Value._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Value._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// HashEntry._lock:                                                                                 
                                                                                                    
function {:inline} Y_HashEntry._lock(tid : Tid, this: HashEntry, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(HashEntry._state[this], tid) && leq(m#moverPath(ReadEval.HashEntry._lock(tid: Tid,this: HashEntry,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (HashEntry._lock[this] == newValue))
 &&(((HashEntry._lock[this]==tid)==(newValue==tid)))                                                
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_HashEntry._lock(tid : Tid, this: HashEntry, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_HashEntry._lock.Subsumes.W(tid : Tid, u : Tid, this: HashEntry, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var this_yield: HashEntry;                                                                          
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(HashEntry._state[this], tid);                                                  
 assume isAccessible(HashEntry._state[this], u);                                                    
 assume !isError(m#moverPath(WriteEval.HashEntry._lock(u: Tid,this: HashEntry,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.HashEntry._lock(tid: Tid,this: HashEntry,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_HashEntry._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_HashEntry._lock.Reflexive(tid : Tid, this: HashEntry , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var this_yield: HashEntry;                                                                          
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(HashEntry._state[this], tid);                                                  
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_HashEntry._lock(tid, this, HashEntry._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_HashEntry._lock.Transitive(tid : Tid, this: HashEntry, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (22.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (22.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (22.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var this_pre: HashEntry;                                                                            
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var this_post: HashEntry;                                                                           
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(HashEntry._state[this], tid);                                                  
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_HashEntry._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_HashEntry._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Segment.segments:                                                                                
                                                                                                    
function {:inline} Y_Segment.segments(tid : Tid, this: Segment, newValue: Array.Segment.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Segment._state[this], tid) && leq(m#moverPath(ReadEval.Segment.segments(tid: Tid,this: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Segment.segments[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Segment.segments(tid : Tid, this: Segment, newValue: Array.Segment.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Segment.segments.Subsumes.W(tid : Tid, u : Tid, this: Segment, newValue: Array.Segment.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
var newValue_yield: Array.Segment.SegmentArray;                                                     
                                                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
 assume isAccessible(Segment._state[this], u);                                                      
 assume !isError(m#moverPath(WriteEval.Segment.segments(u: Tid,this: Segment,newValue: Array.Segment.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
                                                                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Segment.segments(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Segment.segments.Reflexive(tid : Tid, this: Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Segment.segments(tid, this, Segment.segments[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Segment.segments.Transitive(tid : Tid, this: Segment, newValue : Array.Segment.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (28.36): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (28.36): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (28.36): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var newValue_pre: Array.Segment.SegmentArray;                                                       
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var this_pre: Segment;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var this_post: Segment;                                                                             
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Array.Segment.SegmentArray;                                                      
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Segment.segments(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Segment.segments(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Segment._lock:                                                                                   
                                                                                                    
function {:inline} Y_Segment._lock(tid : Tid, this: Segment, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Segment._state[this], tid) && leq(m#moverPath(ReadEval.Segment._lock(tid: Tid,this: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Segment._lock[this] == newValue))
 &&(((Segment._lock[this]==tid)==(newValue==tid)))                                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Segment._lock(tid : Tid, this: Segment, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Segment._lock.Subsumes.W(tid : Tid, u : Tid, this: Segment, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
 assume isAccessible(Segment._state[this], u);                                                      
 assume !isError(m#moverPath(WriteEval.Segment._lock(u: Tid,this: Segment,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Segment._lock(tid: Tid,this: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Segment._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Segment._lock.Reflexive(tid : Tid, this: Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Segment._lock(tid, this, Segment._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Segment._lock.Transitive(tid : Tid, this: Segment, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (25.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var this_pre: Segment;                                                                              
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var this_post: Segment;                                                                             
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Segment._state[this], tid);                                                    
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Segment._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Segment._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Array.Segment.SegmentArray:                                                                      
                                                                                                    
function {:inline} Y_Array.Segment.SegmentArray(tid : Tid, athis: Array.Segment.SegmentArray, index: int, newValue: Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
(var this := Array.Segment.SegmentArray._this[athis];                                               
 ((isAccessible(Array.Segment.SegmentArray._state[athis], tid) && leq(m#moverPath(ReadEval.Array.Segment.SegmentArray(tid: Tid,Array.Segment.SegmentArray._this[athis]: Segment,athis: Array.Segment.SegmentArray,index: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Array.Segment.SegmentArray._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Array.Segment.SegmentArray(tid : Tid, athis: Array.Segment.SegmentArray, index: int, newValue: Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
(var this := Array.Segment.SegmentArray._this[athis];                                               
true                                                                                                
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.Segment.SegmentArray.Subsumes.W(tid : Tid, u : Tid, this: Segment, athis: Array.Segment.SegmentArray, index: int, newValue: Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.Segment.SegmentArray._this[athis];                                          
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var athis_yield: Array.Segment.SegmentArray;                                                        
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var index_yield: int;                                                                               
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Array.Segment.SegmentArray._state[athis], u);                                  
 assume !isError(m#moverPath(WriteEval.Array.Segment.SegmentArray(u: Tid,Array.Segment.SegmentArray._this[athis]: Segment,athis: Array.Segment.SegmentArray,index: int,newValue: Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
                                                                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Segment.SegmentArray(tid, athis, index, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Array.Segment.SegmentArray.Reflexive(tid : Tid, this: Segment, athis: Array.Segment.SegmentArray, index: int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires this == Array.Segment.SegmentArray._this[athis];                                          
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var athis_yield: Array.Segment.SegmentArray;                                                        
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var index_yield: int;                                                                               
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var this_yield: Segment;                                                                            
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Array.Segment.SegmentArray._state[athis], tid);                                
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Segment.SegmentArray(tid, athis, index, Array.Segment.SegmentArray._elems[athis][index] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Array.Segment.SegmentArray.Transitive(tid : Tid, this: Segment, athis: Array.Segment.SegmentArray, index: int, newValue : Value , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (26.32): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (26.32): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (26.32): Object invariant may not hold.
                                                                                                    
 requires this == Array.Segment.SegmentArray._this[athis];                                          
 requires ValidTid(tid);                                                                            
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var athis_pre: Array.Segment.SegmentArray;                                                          
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var index_pre: int;                                                                                 
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var this_pre: Segment;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var this_post: Segment;                                                                             
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var index_post: int;                                                                                
var Main._lock_post: [Main]Tid;                                                                     
var athis_post: Array.Segment.SegmentArray;                                                         
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.Segment.SegmentArray._state[athis], tid);                                
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Array.Segment.SegmentArray(tid, athis, index, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assert Y_Array.Segment.SegmentArray(tid, athis, index, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// ConcurrentHashMap.segments:                                                                      
                                                                                                    
function {:inline} Y_ConcurrentHashMap.segments(tid : Tid, this: ConcurrentHashMap, newValue: Array.ConcurrentHashMap.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(ConcurrentHashMap._state[this], tid) && leq(m#moverPath(ReadEval.ConcurrentHashMap.segments(tid: Tid,this: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (ConcurrentHashMap.segments[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_ConcurrentHashMap.segments(tid : Tid, this: ConcurrentHashMap, newValue: Array.ConcurrentHashMap.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap.segments.Subsumes.W(tid : Tid, u : Tid, this: ConcurrentHashMap, newValue: Array.ConcurrentHashMap.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var newValue_yield: Array.ConcurrentHashMap.SegmentArray;                                           
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
 assume isAccessible(ConcurrentHashMap._state[this], u);                                            
 assume !isError(m#moverPath(WriteEval.ConcurrentHashMap.segments(u: Tid,this: ConcurrentHashMap,newValue: Array.ConcurrentHashMap.SegmentArray,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
                                                                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_ConcurrentHashMap.segments(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap.segments.Reflexive(tid : Tid, this: ConcurrentHashMap , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_ConcurrentHashMap.segments(tid, this, ConcurrentHashMap.segments[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap.segments.Transitive(tid : Tid, this: ConcurrentHashMap, newValue : Array.ConcurrentHashMap.SegmentArray , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (52.36): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (52.36): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (52.36): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var this_pre: ConcurrentHashMap;                                                                    
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var newValue_pre: Array.ConcurrentHashMap.SegmentArray;                                             
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var this_post: ConcurrentHashMap;                                                                   
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var newValue_post: Array.ConcurrentHashMap.SegmentArray;                                            
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_ConcurrentHashMap.segments(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_ConcurrentHashMap.segments(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// ConcurrentHashMap._lock:                                                                         
                                                                                                    
function {:inline} Y_ConcurrentHashMap._lock(tid : Tid, this: ConcurrentHashMap, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(ConcurrentHashMap._state[this], tid) && leq(m#moverPath(ReadEval.ConcurrentHashMap._lock(tid: Tid,this: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (ConcurrentHashMap._lock[this] == newValue))
 &&(((ConcurrentHashMap._lock[this]==tid)==(newValue==tid)))                                        
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_ConcurrentHashMap._lock(tid : Tid, this: ConcurrentHashMap, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap._lock.Subsumes.W(tid : Tid, u : Tid, this: ConcurrentHashMap, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
 assume isAccessible(ConcurrentHashMap._state[this], u);                                            
 assume !isError(m#moverPath(WriteEval.ConcurrentHashMap._lock(u: Tid,this: ConcurrentHashMap,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.ConcurrentHashMap._lock(tid: Tid,this: ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_ConcurrentHashMap._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap._lock.Reflexive(tid : Tid, this: ConcurrentHashMap , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_ConcurrentHashMap._lock(tid, this, ConcurrentHashMap._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_ConcurrentHashMap._lock.Transitive(tid : Tid, this: ConcurrentHashMap, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (48.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (48.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (48.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var this_pre: ConcurrentHashMap;                                                                    
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var this_post: ConcurrentHashMap;                                                                   
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(ConcurrentHashMap._state[this], tid);                                          
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_ConcurrentHashMap._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_ConcurrentHashMap._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Array.ConcurrentHashMap.SegmentArray:                                                            
                                                                                                    
function {:inline} Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, athis: Array.ConcurrentHashMap.SegmentArray, index: int, newValue: Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
(var this := Array.ConcurrentHashMap.SegmentArray._this[athis];                                     
 ((isAccessible(Array.ConcurrentHashMap.SegmentArray._state[athis], tid) && leq(m#moverPath(ReadEval.Array.ConcurrentHashMap.SegmentArray(tid: Tid,Array.ConcurrentHashMap.SegmentArray._this[athis]: ConcurrentHashMap,athis: Array.ConcurrentHashMap.SegmentArray,index: int,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Array.ConcurrentHashMap.SegmentArray._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, athis: Array.ConcurrentHashMap.SegmentArray, index: int, newValue: Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
(var this := Array.ConcurrentHashMap.SegmentArray._this[athis];                                     
true                                                                                                
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.ConcurrentHashMap.SegmentArray.Subsumes.W(tid : Tid, u : Tid, this: ConcurrentHashMap, athis: Array.ConcurrentHashMap.SegmentArray, index: int, newValue: Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.ConcurrentHashMap.SegmentArray._this[athis];                                
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var index_yield: int;                                                                               
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var athis_yield: Array.ConcurrentHashMap.SegmentArray;                                              
                                                                                                    
 assume isAccessible(Array.ConcurrentHashMap.SegmentArray._state[athis], u);                        
 assume !isError(m#moverPath(WriteEval.Array.ConcurrentHashMap.SegmentArray(u: Tid,Array.ConcurrentHashMap.SegmentArray._this[athis]: ConcurrentHashMap,athis: Array.ConcurrentHashMap.SegmentArray,index: int,newValue: Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
                                                                                                    
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.ConcurrentHashMap.SegmentArray(tid, athis, index, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Array.ConcurrentHashMap.SegmentArray.Reflexive(tid : Tid, this: ConcurrentHashMap, athis: Array.ConcurrentHashMap.SegmentArray, index: int , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires this == Array.ConcurrentHashMap.SegmentArray._this[athis];                                
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: ConcurrentHashMap;                                                                  
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var index_yield: int;                                                                               
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var athis_yield: Array.ConcurrentHashMap.SegmentArray;                                              
                                                                                                    
 assume isAccessible(Array.ConcurrentHashMap.SegmentArray._state[athis], tid);                      
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.ConcurrentHashMap.SegmentArray(tid, athis, index, Array.ConcurrentHashMap.SegmentArray._elems[athis][index] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Array.ConcurrentHashMap.SegmentArray.Transitive(tid : Tid, this: ConcurrentHashMap, athis: Array.ConcurrentHashMap.SegmentArray, index: int, newValue : Segment , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (50.34): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (50.34): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (50.34): Object invariant may not hold.
                                                                                                    
 requires this == Array.ConcurrentHashMap.SegmentArray._this[athis];                                
 requires ValidTid(tid);                                                                            
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var athis_pre: Array.ConcurrentHashMap.SegmentArray;                                                
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var this_pre: ConcurrentHashMap;                                                                    
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var Main._lock_pre: [Main]Tid;                                                                      
var index_pre: int;                                                                                 
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var this_post: ConcurrentHashMap;                                                                   
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var athis_post: Array.ConcurrentHashMap.SegmentArray;                                               
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var index_post: int;                                                                                
var Main._lock_post: [Main]Tid;                                                                     
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.ConcurrentHashMap.SegmentArray._state[athis], tid);                      
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Array.ConcurrentHashMap.SegmentArray(tid, athis, index, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assert Y_Array.ConcurrentHashMap.SegmentArray(tid, athis, index, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
// Main._lock:                                                                                      
                                                                                                    
function {:inline} Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Main._state[this], tid) && leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _R)) ==> (Main._lock[this] == newValue))
 &&(((Main._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Subsumes.W(tid : Tid, u : Tid, this: Main, newValue: Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var newValue_yield: Tid;                                                                            
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var u_yield: Tid;                                                                                   
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume isAccessible(Main._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Main._lock(u: Tid,this: Main,newValue: Tid,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock)), _N);
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Reflexive(tid : Tid, this: Main , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Array.Segment.SegmentArray._length_yield: [Array.Segment.SegmentArray]int;                      
var Value._state_yield: [Value]State;                                                               
var Key._state_yield: [Key]State;                                                                   
var tid_yield: Tid;                                                                                 
var Main._lock_yield: [Main]Tid;                                                                    
var Segment._state_yield: [Segment]State;                                                           
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var Value._lock_yield: [Value]Tid;                                                                  
var Segment.segments_yield: [Segment]Array.Segment.SegmentArray;                                    
var Array.ConcurrentHashMap.SegmentArray._elems_yield: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var ConcurrentHashMap.segments_yield: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;      
var Value.x_yield: [Value]int;                                                                      
var ConcurrentHashMap._state_yield: [ConcurrentHashMap]State;                                       
var Array.ConcurrentHashMap.SegmentArray._length_yield: [Array.ConcurrentHashMap.SegmentArray]int;  
var HashEntry._state_yield: [HashEntry]State;                                                       
var Segment._lock_yield: [Segment]Tid;                                                              
var ConcurrentHashMap._lock_yield: [ConcurrentHashMap]Tid;                                          
var HashEntry._lock_yield: [HashEntry]Tid;                                                          
var Array.Segment.SegmentArray._state_yield: [Array.Segment.SegmentArray]State;                     
var Array.Segment.SegmentArray._elems_yield: [Array.Segment.SegmentArray]([int]Value);              
var Key._lock_yield: [Key]Tid;                                                                      
var Array.ConcurrentHashMap.SegmentArray._state_yield: [Array.ConcurrentHashMap.SegmentArray]State; 
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
assume Key._state_yield == Key._state && Key._lock_yield == Key._lock && Value._state_yield == Value._state && Value.x_yield == Value.x && Value._lock_yield == Value._lock && HashEntry._state_yield == HashEntry._state && HashEntry._lock_yield == HashEntry._lock && Segment._state_yield == Segment._state && Segment.segments_yield == Segment.segments && Segment._lock_yield == Segment._lock && Array.Segment.SegmentArray._state_yield == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_yield == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_yield == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_yield == ConcurrentHashMap._state && ConcurrentHashMap.segments_yield == ConcurrentHashMap.segments && ConcurrentHashMap._lock_yield == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_yield == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_yield == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_yield == Array.ConcurrentHashMap.SegmentArray._length && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, Main._lock[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Transitive(tid : Tid, this: Main, newValue : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
 requires StateInvariant(Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Value ::  { Value._state[_this] } isAccessible(Value._state[_this], tid) && true ==> Invariant.Value.2243228(tid: Tid,_this : Value,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (72.1): Object invariant may not hold.
requires  (forall _this : Segment ::  { Segment._state[_this] } isAccessible(Segment._state[_this], tid) && true ==> Invariant.Segment.2243551(tid: Tid,_this : Segment,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (72.1): Object invariant may not hold.
requires  (forall _this : ConcurrentHashMap ::  { ConcurrentHashMap._state[_this] } isAccessible(ConcurrentHashMap._state[_this], tid) && true ==> Invariant.ConcurrentHashMap.2243791(tid: Tid,_this : ConcurrentHashMap,Key._state,Key._lock,Value._state,Value.x,Value._lock,HashEntry._state,HashEntry._lock,Segment._state,Segment.segments,Segment._lock,Array.Segment.SegmentArray._state,Array.Segment.SegmentArray._elems,Array.Segment.SegmentArray._length,ConcurrentHashMap._state,ConcurrentHashMap.segments,ConcurrentHashMap._lock,Array.ConcurrentHashMap.SegmentArray._state,Array.ConcurrentHashMap.SegmentArray._elems,Array.ConcurrentHashMap.SegmentArray._length,Main._state,Main._lock));       // (72.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var ConcurrentHashMap._lock_pre: [ConcurrentHashMap]Tid;                                            
var HashEntry._lock_pre: [HashEntry]Tid;                                                            
var ConcurrentHashMap._state_pre: [ConcurrentHashMap]State;                                         
var Segment.segments_pre: [Segment]Array.Segment.SegmentArray;                                      
var $recorded.state_pre: int;                                                                       
var Value._lock_pre: [Value]Tid;                                                                    
var this_pre: Main;                                                                                 
var Main._lock_pre: [Main]Tid;                                                                      
var Array.Segment.SegmentArray._state_pre: [Array.Segment.SegmentArray]State;                       
var tid_pre: Tid;                                                                                   
var Array.ConcurrentHashMap.SegmentArray._elems_pre: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Segment._state_pre: [Segment]State;                                                             
var Main._state_pre: [Main]State;                                                                   
var Array.Segment.SegmentArray._length_pre: [Array.Segment.SegmentArray]int;                        
var $pc_pre: Phase;                                                                                 
var Key._lock_pre: [Key]Tid;                                                                        
var HashEntry._state_pre: [HashEntry]State;                                                         
var Value._state_pre: [Value]State;                                                                 
var ConcurrentHashMap.segments_pre: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;        
var Array.ConcurrentHashMap.SegmentArray._state_pre: [Array.ConcurrentHashMap.SegmentArray]State;   
var newValue_pre: Tid;                                                                              
var Key._state_pre: [Key]State;                                                                     
var Segment._lock_pre: [Segment]Tid;                                                                
var Array.Segment.SegmentArray._elems_pre: [Array.Segment.SegmentArray]([int]Value);                
var Value.x_pre: [Value]int;                                                                        
var Array.ConcurrentHashMap.SegmentArray._length_pre: [Array.ConcurrentHashMap.SegmentArray]int;    
                                                                                                    
var ConcurrentHashMap._lock_post: [ConcurrentHashMap]Tid;                                           
var Segment._state_post: [Segment]State;                                                            
var this_post: Main;                                                                                
var $recorded.state_post: int;                                                                      
var Array.Segment.SegmentArray._length_post: [Array.Segment.SegmentArray]int;                       
var HashEntry._state_post: [HashEntry]State;                                                        
var Key._lock_post: [Key]Tid;                                                                       
var Value._lock_post: [Value]Tid;                                                                   
var Value.x_post: [Value]int;                                                                       
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var Segment.segments_post: [Segment]Array.Segment.SegmentArray;                                     
var tid_post: Tid;                                                                                  
var Array.ConcurrentHashMap.SegmentArray._state_post: [Array.ConcurrentHashMap.SegmentArray]State;  
var Array.Segment.SegmentArray._elems_post: [Array.Segment.SegmentArray]([int]Value);               
var Array.Segment.SegmentArray._state_post: [Array.Segment.SegmentArray]State;                      
var ConcurrentHashMap._state_post: [ConcurrentHashMap]State;                                        
var Segment._lock_post: [Segment]Tid;                                                               
var Value._state_post: [Value]State;                                                                
var Array.ConcurrentHashMap.SegmentArray._elems_post: [Array.ConcurrentHashMap.SegmentArray]([int]Segment);
var Main._lock_post: [Main]Tid;                                                                     
var newValue_post: Tid;                                                                             
var HashEntry._lock_post: [HashEntry]Tid;                                                           
var ConcurrentHashMap.segments_post: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray;       
var Array.ConcurrentHashMap.SegmentArray._length_post: [Array.ConcurrentHashMap.SegmentArray]int;   
var Key._state_post: [Key]State;                                                                    
                                                                                                    
assume Key._state_pre == Key._state && Key._lock_pre == Key._lock && Value._state_pre == Value._state && Value.x_pre == Value.x && Value._lock_pre == Value._lock && HashEntry._state_pre == HashEntry._state && HashEntry._lock_pre == HashEntry._lock && Segment._state_pre == Segment._state && Segment.segments_pre == Segment.segments && Segment._lock_pre == Segment._lock && Array.Segment.SegmentArray._state_pre == Array.Segment.SegmentArray._state && Array.Segment.SegmentArray._elems_pre == Array.Segment.SegmentArray._elems && Array.Segment.SegmentArray._length_pre == Array.Segment.SegmentArray._length && ConcurrentHashMap._state_pre == ConcurrentHashMap._state && ConcurrentHashMap.segments_pre == ConcurrentHashMap.segments && ConcurrentHashMap._lock_pre == ConcurrentHashMap._lock && Array.ConcurrentHashMap.SegmentArray._state_pre == Array.ConcurrentHashMap.SegmentArray._state && Array.ConcurrentHashMap.SegmentArray._elems_pre == Array.ConcurrentHashMap.SegmentArray._elems && Array.ConcurrentHashMap.SegmentArray._length_pre == Array.ConcurrentHashMap.SegmentArray._length && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume Y(tid , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
 assume Y_Main._lock(tid, this, newValue , Key._state_p, Key._lock_p, Value._state_p, Value.x_p, Value._lock_p, HashEntry._state_p, HashEntry._lock_p, Segment._state_p, Segment.segments_p, Segment._lock_p, Array.Segment.SegmentArray._state_p, Array.Segment.SegmentArray._elems_p, Array.Segment.SegmentArray._length_p, ConcurrentHashMap._state_p, ConcurrentHashMap.segments_p, ConcurrentHashMap._lock_p, Array.ConcurrentHashMap.SegmentArray._state_p, Array.ConcurrentHashMap.SegmentArray._elems_p, Array.ConcurrentHashMap.SegmentArray._length_p, Main._state_p, Main._lock_p);
assume Key._state_post == Key._state_p && Key._lock_post == Key._lock_p && Value._state_post == Value._state_p && Value.x_post == Value.x_p && Value._lock_post == Value._lock_p && HashEntry._state_post == HashEntry._state_p && HashEntry._lock_post == HashEntry._lock_p && Segment._state_post == Segment._state_p && Segment.segments_post == Segment.segments_p && Segment._lock_post == Segment._lock_p && Array.Segment.SegmentArray._state_post == Array.Segment.SegmentArray._state_p && Array.Segment.SegmentArray._elems_post == Array.Segment.SegmentArray._elems_p && Array.Segment.SegmentArray._length_post == Array.Segment.SegmentArray._length_p && ConcurrentHashMap._state_post == ConcurrentHashMap._state_p && ConcurrentHashMap.segments_post == ConcurrentHashMap.segments_p && ConcurrentHashMap._lock_post == ConcurrentHashMap._lock_p && Array.ConcurrentHashMap.SegmentArray._state_post == Array.ConcurrentHashMap.SegmentArray._state_p && Array.ConcurrentHashMap.SegmentArray._elems_post == Array.ConcurrentHashMap.SegmentArray._elems_p && Array.ConcurrentHashMap.SegmentArray._length_post == Array.ConcurrentHashMap.SegmentArray._length_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Main._lock(tid, this, newValue , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Key._state: [Key]State, Key._lock: [Key]Tid, Value._state: [Value]State, Value.x: [Value]int, Value._lock: [Value]Tid, HashEntry._state: [HashEntry]State, HashEntry._lock: [HashEntry]Tid, Segment._state: [Segment]State, Segment.segments: [Segment]Array.Segment.SegmentArray, Segment._lock: [Segment]Tid, Array.Segment.SegmentArray._state: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state: [ConcurrentHashMap]State, ConcurrentHashMap.segments: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length: [Array.ConcurrentHashMap.SegmentArray]int, Main._state: [Main]State, Main._lock: [Main]Tid , Key._state_p: [Key]State, Key._lock_p: [Key]Tid, Value._state_p: [Value]State, Value.x_p: [Value]int, Value._lock_p: [Value]Tid, HashEntry._state_p: [HashEntry]State, HashEntry._lock_p: [HashEntry]Tid, Segment._state_p: [Segment]State, Segment.segments_p: [Segment]Array.Segment.SegmentArray, Segment._lock_p: [Segment]Tid, Array.Segment.SegmentArray._state_p: [Array.Segment.SegmentArray]State, Array.Segment.SegmentArray._elems_p: [Array.Segment.SegmentArray]([int]Value), Array.Segment.SegmentArray._length_p: [Array.Segment.SegmentArray]int, ConcurrentHashMap._state_p: [ConcurrentHashMap]State, ConcurrentHashMap.segments_p: [ConcurrentHashMap]Array.ConcurrentHashMap.SegmentArray, ConcurrentHashMap._lock_p: [ConcurrentHashMap]Tid, Array.ConcurrentHashMap.SegmentArray._state_p: [Array.ConcurrentHashMap.SegmentArray]State, Array.ConcurrentHashMap.SegmentArray._elems_p: [Array.ConcurrentHashMap.SegmentArray]([int]Segment), Array.ConcurrentHashMap.SegmentArray._length_p: [Array.ConcurrentHashMap.SegmentArray]int, Main._state_p: [Main]State, Main._lock_p: [Main]Tid): bool
{                                                                                                   
 (forall this: Key :: Y_Key._lock(tid : Tid, this, Key._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: Value :: Y_Value.x(tid : Tid, this, Value.x_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: Value :: Y_Value._lock(tid : Tid, this, Value._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: HashEntry :: Y_HashEntry._lock(tid : Tid, this, HashEntry._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: Segment :: Y_Segment.segments(tid : Tid, this, Segment.segments_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: Segment :: Y_Segment._lock(tid : Tid, this, Segment._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: ConcurrentHashMap :: Y_ConcurrentHashMap.segments(tid : Tid, this, ConcurrentHashMap.segments_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: ConcurrentHashMap :: Y_ConcurrentHashMap._lock(tid : Tid, this, ConcurrentHashMap._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall this: Main :: Y_Main._lock(tid : Tid, this, Main._lock_p[this] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall athis: Array.Segment.SegmentArray, index: int :: Y_Array.Segment.SegmentArray(tid : Tid, athis, index, Array.Segment.SegmentArray._elems_p[athis][index] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall athis: Array.ConcurrentHashMap.SegmentArray, index: int :: Y_Array.ConcurrentHashMap.SegmentArray(tid : Tid, athis, index, Array.ConcurrentHashMap.SegmentArray._elems_p[athis][index] , Key._state, Key._lock, Value._state, Value.x, Value._lock, HashEntry._state, HashEntry._lock, Segment._state, Segment.segments, Segment._lock, Array.Segment.SegmentArray._state, Array.Segment.SegmentArray._elems, Array.Segment.SegmentArray._length, ConcurrentHashMap._state, ConcurrentHashMap.segments, ConcurrentHashMap._lock, Array.ConcurrentHashMap.SegmentArray._state, Array.ConcurrentHashMap.SegmentArray._elems, Array.ConcurrentHashMap.SegmentArray._length, Main._state, Main._lock))
 && (forall _i : Key :: isShared(Key._state[_i]) ==> isShared(Key._state_p[_i]))                    
 && (forall _i : Key :: isLocal(Key._state[_i], tid) <==> isLocal(Key._state_p[_i], tid))           
 && (forall _i : Value :: isShared(Value._state[_i]) ==> isShared(Value._state_p[_i]))              
 && (forall _i : Value :: isLocal(Value._state[_i], tid) <==> isLocal(Value._state_p[_i], tid))     
 && (forall _i : HashEntry :: isShared(HashEntry._state[_i]) ==> isShared(HashEntry._state_p[_i]))  
 && (forall _i : HashEntry :: isLocal(HashEntry._state[_i], tid) <==> isLocal(HashEntry._state_p[_i], tid))
 && (forall _i : Segment :: isShared(Segment._state[_i]) ==> isShared(Segment._state_p[_i]))        
 && (forall _i : Segment :: isLocal(Segment._state[_i], tid) <==> isLocal(Segment._state_p[_i], tid))
 && (forall _i : ConcurrentHashMap :: isShared(ConcurrentHashMap._state[_i]) ==> isShared(ConcurrentHashMap._state_p[_i]))
 && (forall _i : ConcurrentHashMap :: isLocal(ConcurrentHashMap._state[_i], tid) <==> isLocal(ConcurrentHashMap._state_p[_i], tid))
 && (forall _i : Main :: isShared(Main._state[_i]) ==> isShared(Main._state_p[_i]))                 
 && (forall _i : Main :: isLocal(Main._state[_i], tid) <==> isLocal(Main._state_p[_i], tid))        
 && (forall _i : Array.Segment.SegmentArray :: isShared(Array.Segment.SegmentArray._state[_i]) ==> isShared(Array.Segment.SegmentArray._state_p[_i]))
 && (forall _i : Array.Segment.SegmentArray :: Array.Segment.SegmentArray._length[_i] == Array.Segment.SegmentArray._length_p[_i])
 && (forall _i : Array.Segment.SegmentArray :: isLocal(Array.Segment.SegmentArray._state[_i], tid) <==> isLocal(Array.Segment.SegmentArray._state_p[_i], tid))
 && (forall _i : Array.ConcurrentHashMap.SegmentArray :: isShared(Array.ConcurrentHashMap.SegmentArray._state[_i]) ==> isShared(Array.ConcurrentHashMap.SegmentArray._state_p[_i]))
 && (forall _i : Array.ConcurrentHashMap.SegmentArray :: Array.ConcurrentHashMap.SegmentArray._length[_i] == Array.ConcurrentHashMap.SegmentArray._length_p[_i])
 && (forall _i : Array.ConcurrentHashMap.SegmentArray :: isLocal(Array.ConcurrentHashMap.SegmentArray._state[_i], tid) <==> isLocal(Array.ConcurrentHashMap.SegmentArray._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1721.1-2662.2: (Method:73.5)
// 1744.1-1744.24: (73.5): Bad tid
// 1745.1-1745.38: (73.5): this is not global
// 1748.1-1748.629: (73.5): Object invariant may not hold.
// 1749.1-1749.639: (73.5): Object invariant may not hold.
// 1750.1-1750.689: (73.5): Object invariant may not hold.
// 1753.1-1753.628: (73.5): Object invariant may not hold.
// 1754.1-1754.638: (73.5): Object invariant may not hold.
// 1755.1-1755.688: (73.5): Object invariant may not hold.
// 2255.2-2257.2: (class anchor.sink.VarDeclStmt:74.9)
// 2258.2-2265.49: (class anchor.sink.Alloc:74.9)
// 2268.2-2270.2: (class anchor.sink.VarDeclStmt:75.9)
// 2271.2-2274.16: (class anchor.sink.Assign:75.9)
// 2275.2-2277.2: (class anchor.sink.VarDeclStmt:57.9)
// 2278.2-2286.120: (class anchor.sink.AAlloc:57.9)
// 2287.2-2289.2: (class anchor.sink.VarDeclStmt:58.14)
// 2290.2-2293.13: (class anchor.sink.Assign:58.22)
// 2296.2-2300.76: (class anchor.sink.While:58.27)
// 2302.1-2302.27: (73.5): Bad tid
// 2303.1-2303.41: (73.5): this is not global
// 2306.1-2306.632: (58.27): Object invariant may not hold.
// 2307.1-2307.642: (58.27): Object invariant may not hold.
// 2308.1-2308.698: (58.27): Object invariant may not hold.
// 2308.698-2309.246: (58.27): invariant forall int k$196 ::0 <= k$196 && k$196 < i$196 ==> segments$196[k$196] != Segment.null && isShared(segments$196[k$196]) may not hold
// 2309.246-2310.85: (58.27): invariant isLocal(segments$196, tid) may not hold
// 2311.1-2311.709: (58.27): Loop does not preserve yields_as annotation for field x
// 2312.1-2312.729: (58.27): Loop does not preserve yields_as annotation for field segments
// 2313.1-2313.808: (58.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2314.1-2314.759: (58.27): Loop does not preserve yields_as annotation for field segments
// 2315.1-2315.838: (58.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2316.1-2316.33: (58.27): Phase must be invariant at loop head
// 2317.1-2317.30: (58.27): Potentially infinite loop cannot be in post-commit phase.
// 2319.3-2321.3: (class anchor.sink.VarDeclStmt:62.13)
// 2322.3-2329.46: (class anchor.sink.Alloc:62.13)
// 2332.3-2334.3: (class anchor.sink.VarDeclStmt:63.13)
// 2335.3-2338.23: (class anchor.sink.Assign:63.13)
// 2339.3-2341.3: (class anchor.sink.VarDeclStmt:33.9)
// 2342.3-2350.109: (class anchor.sink.AAlloc:33.9)
// 2351.3-2353.3: (class anchor.sink.VarDeclStmt:34.14)
// 2354.3-2357.14: (class anchor.sink.Assign:34.22)
// 2360.3-2364.21: (class anchor.sink.While:34.27)
// 2366.1-2366.28: (73.5): Bad tid
// 2367.1-2367.42: (73.5): this is not global
// 2370.1-2370.633: (34.27): Object invariant may not hold.
// 2371.1-2371.655: (34.27): Object invariant may not hold.
// 2372.1-2372.699: (34.27): Object invariant may not hold.
// 2372.699-2373.76: (34.27): invariant isLocal(segments$197, tid) may not hold
// 2373.76-2374.223: (34.27): invariant forall int k$197 ::0 <= k$197 && k$197 < i$197 ==> segments$197[k$197] != Value.null && isShared(segments$197[k$197]) may not hold
// 2375.1-2375.710: (34.27): Loop does not preserve yields_as annotation for field x
// 2376.1-2376.730: (34.27): Loop does not preserve yields_as annotation for field segments
// 2377.1-2377.809: (34.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2378.1-2378.760: (34.27): Loop does not preserve yields_as annotation for field segments
// 2379.1-2379.839: (34.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2380.1-2380.34: (34.27): Phase must be invariant at loop head
// 2381.1-2381.31: (34.27): Potentially infinite loop cannot be in post-commit phase.
// 2383.4-2385.4: (class anchor.sink.VarDeclStmt:38.13)
// 2386.4-2393.45: (class anchor.sink.Alloc:38.13)
// 2396.4-2398.4: (class anchor.sink.VarDeclStmt:39.13)
// 2399.4-2402.24: (class anchor.sink.Assign:39.13)
// 2404.4-2420.27: (class anchor.sink.Write:11.9)
// 2416.1-2416.35: (11.9): Cannot have potential null deference in left-mover part.
// 2419.1-2419.29: (11.9): Reduction failure
// 2421.4-2423.4: (class anchor.sink.VarDeclStmt:12.14)
// 2424.4-2427.15: (class anchor.sink.Assign:12.22)
// 2430.4-2434.22: (class anchor.sink.While:12.27)
// 2436.1-2436.29: (73.5): Bad tid
// 2437.1-2437.43: (73.5): this is not global
// 2440.1-2440.646: (12.27): Object invariant may not hold.
// 2441.1-2441.656: (12.27): Object invariant may not hold.
// 2442.1-2442.700: (12.27): Object invariant may not hold.
// 2442.700-2443.42: (12.27): invariant this$198.x == i$198 may not hold
// 2444.1-2444.711: (12.27): Loop does not preserve yields_as annotation for field x
// 2445.1-2445.731: (12.27): Loop does not preserve yields_as annotation for field segments
// 2446.1-2446.810: (12.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Value),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2447.1-2447.761: (12.27): Loop does not preserve yields_as annotation for field segments
// 2448.1-2448.840: (12.27): Loop does not preserve yields_as annotation for field ArrayDecl(SegmentArray,ClassType(Segment),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(VarAccess(isRead),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2449.1-2449.35: (12.27): Phase must be invariant at loop head
// 2450.1-2450.32: (12.27): Potentially infinite loop cannot be in post-commit phase.
// 2452.5-2454.5: (class anchor.sink.VarDeclStmt:15.13)
// 2455.5-2472.32: (class anchor.sink.Read:15.13)
// 2467.1-2467.36: (15.13): Cannot have potential null deference in left-mover part.
// 2471.1-2471.30: (15.13): Reduction failure
// 2473.5-2476.24: (class anchor.sink.Assign:16.19)
// 2478.5-2494.32: (class anchor.sink.Write:17.13)
// 2490.1-2490.36: (17.13): Cannot have potential null deference in left-mover part.
// 2493.1-2493.30: (17.13): Reduction failure
// 2495.5-2498.24: (class anchor.sink.Assign:12.39)
// 2501.1-2501.32: (12.27): Phase must be invariant at loop head
// 2503.4-2506.25: (class anchor.sink.Break:10.17)
// 2508.4-2539.4: (class anchor.sink.AWrite:40.13)
// 2520.1-2520.60: (40.13): Cannot have potential null deference in left-mover part.
// 2525.1-2525.23: (40.13): index < 0.
// 2530.1-2530.69: (40.13): index is >= length.
// 2534.1-2534.29: (40.13): Reduction failure
// 2540.4-2543.23: (class anchor.sink.Assign:34.39)
// 2546.1-2546.31: (34.27): Phase must be invariant at loop head
// 2549.3-2574.3: (class anchor.sink.Write:42.9)
// 2561.1-2561.36: (42.9): Cannot have potential null deference in left-mover part.
// 2564.1-2564.28: (42.9): Reduction failure
// 2568.1-2568.203: (42.9): segments$197 became shared, but some element may not be shared.
// 2571.1-2571.132: (42.9): segments$197 became shared, but Array.Segment.SegmentArray._this[segments$197].segments may not be shared.
// 2575.3-2578.24: (class anchor.sink.Break:32.17)
// 2580.3-2612.3: (class anchor.sink.AWrite:64.13)
// 2592.1-2592.69: (64.13): Cannot have potential null deference in left-mover part.
// 2597.1-2597.22: (64.13): index < 0.
// 2602.1-2602.78: (64.13): index is >= length.
// 2606.1-2606.28: (64.13): Reduction failure
// 2610.1-2610.92: (64.13): seg$196 became shared, but seg$196.segments may not be shared.
// 2613.3-2616.22: (class anchor.sink.Assign:58.52)
// 2619.1-2619.30: (58.27): Phase must be invariant at loop head
// 2622.2-2647.2: (class anchor.sink.Write:67.9)
// 2634.1-2634.45: (67.9): Cannot have potential null deference in left-mover part.
// 2637.1-2637.27: (67.9): Reduction failure
// 2641.1-2641.224: (67.9): segments$196 became shared, but some element may not be shared.
// 2644.1-2644.161: (67.9): segments$196 became shared, but Array.ConcurrentHashMap.SegmentArray._this[segments$196].segments may not be shared.
// 2648.2-2651.23: (class anchor.sink.Break:56.17)
// 2653.2-2661.9: (class anchor.sink.Return:73.23)
// 2658.1-2658.628: (73.23): Object invariant may not hold.
// 2659.1-2659.638: (73.23): Object invariant may not hold.
// 2660.1-2660.688: (73.23): Object invariant may not hold.
// 2791.1-2791.34: (6.5): Value.x failed Write-Write Right-Mover Check
// 2884.1-2884.30: (6.5): Value.x failed Write-Read Right-Mover Check
// 2981.1-2981.34: (6.5): Value.x failed Write-Write Left-Mover Check
// 3075.1-3075.30: (6.5): Value.x failed Write-Read Left-Mover Check
// 3166.1-3166.34: (6.5): Value.x failed Read-Write Right-Mover Check
// 3260.1-3260.34: (6.5): Value.x failed Read-Write Left-Mover Check
// 3353.1-3353.34: (28.5): Segment.segments failed Write-Write Right-Mover Check
// 3446.1-3446.30: (28.5): Segment.segments failed Write-Read Right-Mover Check
// 3543.1-3543.34: (28.5): Segment.segments failed Write-Write Left-Mover Check
// 3637.1-3637.30: (28.5): Segment.segments failed Write-Read Left-Mover Check
// 3728.1-3728.34: (28.5): Segment.segments failed Read-Write Right-Mover Check
// 3822.1-3822.34: (28.5): Segment.segments failed Read-Write Left-Mover Check
// 3921.1-3921.34: (26.5): Array Array.Segment.SegmentArray failed Write-Write Right-Mover Check
// 4020.1-4020.30: (26.5): Array Array.Segment.SegmentArray failed Write-Read Right-Mover Check
// 4123.1-4123.34: (26.5): Array Array.Segment.SegmentArray failed Write-Write Left-Mover Check
// 4223.1-4223.30: (26.5): Array Array.Segment.SegmentArray failed Write-Read Left-Mover Check
// 4320.1-4320.34: (26.5): Array Array.Segment.SegmentArray failed Read-Write Right-Mover Check
// 4420.1-4420.34: (26.5): Array Array.Segment.SegmentArray failed Read-Write Left-Mover Check
// 4513.1-4513.34: (52.5): ConcurrentHashMap.segments failed Write-Write Right-Mover Check
// 4606.1-4606.30: (52.5): ConcurrentHashMap.segments failed Write-Read Right-Mover Check
// 4703.1-4703.34: (52.5): ConcurrentHashMap.segments failed Write-Write Left-Mover Check
// 4797.1-4797.30: (52.5): ConcurrentHashMap.segments failed Write-Read Left-Mover Check
// 4888.1-4888.34: (52.5): ConcurrentHashMap.segments failed Read-Write Right-Mover Check
// 4982.1-4982.34: (52.5): ConcurrentHashMap.segments failed Read-Write Left-Mover Check
// 5081.1-5081.34: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Write Right-Mover Check
// 5180.1-5180.30: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Read Right-Mover Check
// 5283.1-5283.34: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Write Left-Mover Check
// 5383.1-5383.30: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Write-Read Left-Mover Check
// 5480.1-5480.34: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Read-Write Right-Mover Check
// 5580.1-5580.34: (50.5): Array Array.ConcurrentHashMap.SegmentArray failed Read-Write Left-Mover Check
// 5685.1-5685.140: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.1)
// 5686.1-5686.101: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.2)
// 5687.1-5687.158: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case A.3)
// 5834.1-5834.140: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case C)
// 5986.1-5986.144: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case D)
// 5987.1-5987.144: (6.5): Value.x is not Write-Write Stable with respect to Value.x (case R)
// 6092.1-6092.136: (6.5): Value.x is not Read-Write Stable with respect to Value.x (case F)
// 6093.1-6093.136: (6.5): Value.x is not Read-Write Stable with respect to Value.x (case H)
// 6094.1-6094.146: (6.5): Value.x is not Read-Write Stable with respect to Value.x (case I)
// 6198.1-6198.136: (6.5): Value.x is not Write-Read Stable with respect to Value.x (case J)
// 6199.1-6199.136: (6.5): Value.x is not Write-Read Stable with respect to Value.x (case K)
// 6200.1-6200.99: (6.5): Value.x is not Write-Read Stable with respect to Value.x (case L)
// 6306.1-6306.140: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.1)
// 6307.1-6307.101: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.2)
// 6308.1-6308.156: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case A.3)
// 6455.1-6455.140: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case C)
// 6607.1-6607.144: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case D)
// 6608.1-6608.144: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case R)
// 6713.1-6713.136: (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case F)
// 6714.1-6714.136: (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case H)
// 6715.1-6715.144: (6.5): Value.x is not Read-Write Stable with respect to Segment.segments (case I)
// 6819.1-6819.136: (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case J)
// 6820.1-6820.136: (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case K)
// 6821.1-6821.99: (28.5): Segment.segments is not Write-Read Stable with respect to Value.x (case L)
// 6932.1-6932.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.1)
// 6933.1-6933.101: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.2)
// 6934.1-6934.156: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case A.3)
// 7088.1-7088.140: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
// 7247.1-7247.144: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
// 7248.1-7248.144: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
// 7358.1-7358.136: (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
// 7359.1-7359.136: (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
// 7360.1-7360.144: (6.5): Value.x is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
// 7469.1-7469.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case J)
// 7470.1-7470.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case K)
// 7471.1-7471.99: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Value.x (case L)
// 7577.1-7577.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.1)
// 7578.1-7578.101: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.2)
// 7579.1-7579.156: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case A.3)
// 7726.1-7726.140: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
// 7878.1-7878.144: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
// 7879.1-7879.144: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
// 7984.1-7984.136: (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
// 7985.1-7985.136: (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
// 7986.1-7986.144: (6.5): Value.x is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
// 8090.1-8090.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case J)
// 8091.1-8091.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case K)
// 8092.1-8092.99: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Value.x (case L)
// 8203.1-8203.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.1)
// 8204.1-8204.101: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.2)
// 8205.1-8205.156: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case A.3)
// 8359.1-8359.140: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
// 8518.1-8518.144: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
// 8519.1-8519.144: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
// 8629.1-8629.136: (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
// 8630.1-8630.136: (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
// 8631.1-8631.144: (6.5): Value.x is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
// 8740.1-8740.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case J)
// 8741.1-8741.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case K)
// 8742.1-8742.99: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Value.x (case L)
// 8848.1-8848.140: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.1)
// 8849.1-8849.101: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.2)
// 8850.1-8850.156: (6.5): Value.x is not Write-Write Stable with respect to Segment.segments (case A.3)
// 8997.1-8997.140: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case C)
// 9149.1-9149.144: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case D)
// 9150.1-9150.144: (28.5): Segment.segments is not Write-Write Stable with respect to Value.x (case R)
// 9255.1-9255.136: (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case F)
// 9256.1-9256.136: (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case H)
// 9257.1-9257.144: (28.5): Segment.segments is not Read-Write Stable with respect to Value.x (case I)
// 9361.1-9361.136: (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case J)
// 9362.1-9362.136: (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case K)
// 9363.1-9363.99: (6.5): Value.x is not Write-Read Stable with respect to Segment.segments (case L)
// 9469.1-9469.140: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.1)
// 9470.1-9470.101: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.2)
// 9471.1-9471.158: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case A.3)
// 9618.1-9618.140: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case C)
// 9770.1-9770.144: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case D)
// 9771.1-9771.144: (28.5): Segment.segments is not Write-Write Stable with respect to Segment.segments (case R)
// 9876.1-9876.136: (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case F)
// 9877.1-9877.136: (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case H)
// 9878.1-9878.146: (28.5): Segment.segments is not Read-Write Stable with respect to Segment.segments (case I)
// 9982.1-9982.136: (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case J)
// 9983.1-9983.136: (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case K)
// 9984.1-9984.99: (28.5): Segment.segments is not Write-Read Stable with respect to Segment.segments (case L)
// 10095.1-10095.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.1)
// 10096.1-10096.101: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.2)
// 10097.1-10097.156: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.3)
// 10251.1-10251.140: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
// 10410.1-10410.144: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
// 10411.1-10411.144: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
// 10521.1-10521.136: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
// 10522.1-10522.136: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
// 10523.1-10523.144: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
// 10632.1-10632.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case J)
// 10633.1-10633.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case K)
// 10634.1-10634.99: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Segment.segments (case L)
// 10740.1-10740.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.1)
// 10741.1-10741.101: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.2)
// 10742.1-10742.156: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case A.3)
// 10889.1-10889.140: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
// 11041.1-11041.144: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
// 11042.1-11042.144: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
// 11147.1-11147.136: (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
// 11148.1-11148.136: (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
// 11149.1-11149.144: (28.5): Segment.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
// 11253.1-11253.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case J)
// 11254.1-11254.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case K)
// 11255.1-11255.99: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Segment.segments (case L)
// 11366.1-11366.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.1)
// 11367.1-11367.101: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.2)
// 11368.1-11368.156: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case A.3)
// 11522.1-11522.140: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
// 11681.1-11681.144: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
// 11682.1-11682.144: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
// 11792.1-11792.136: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
// 11793.1-11793.136: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
// 11794.1-11794.144: (28.5): Segment.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
// 11903.1-11903.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case J)
// 11904.1-11904.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case K)
// 11905.1-11905.99: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Segment.segments (case L)
// 12016.1-12016.140: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
// 12017.1-12017.101: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
// 12018.1-12018.156: (6.5): Value.x is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
// 12172.1-12172.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case C)
// 12331.1-12331.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case D)
// 12332.1-12332.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Value.x (case R)
// 12442.1-12442.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case F)
// 12443.1-12443.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case H)
// 12444.1-12444.144: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Value.x (case I)
// 12553.1-12553.136: (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
// 12554.1-12554.136: (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
// 12555.1-12555.99: (6.5): Value.x is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
// 12666.1-12666.140: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
// 12667.1-12667.101: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
// 12668.1-12668.156: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
// 12822.1-12822.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case C)
// 12981.1-12981.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case D)
// 12982.1-12982.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Segment.segments (case R)
// 13092.1-13092.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case F)
// 13093.1-13093.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case H)
// 13094.1-13094.144: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Segment.segments (case I)
// 13203.1-13203.136: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
// 13204.1-13204.136: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
// 13205.1-13205.99: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
// 13321.1-13321.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
// 13322.1-13322.101: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
// 13323.1-13323.156: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
// 13484.1-13484.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
// 13650.1-13650.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
// 13651.1-13651.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
// 13766.1-13766.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
// 13767.1-13767.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
// 13768.1-13768.144: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
// 13882.1-13882.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
// 13883.1-13883.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
// 13884.1-13884.99: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
// 13995.1-13995.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
// 13996.1-13996.101: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
// 13997.1-13997.156: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
// 14151.1-14151.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
// 14310.1-14310.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
// 14311.1-14311.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
// 14421.1-14421.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
// 14422.1-14422.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
// 14423.1-14423.144: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
// 14532.1-14532.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
// 14533.1-14533.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
// 14534.1-14534.99: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
// 14650.1-14650.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.1)
// 14651.1-14651.101: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.2)
// 14652.1-14652.156: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case A.3)
// 14813.1-14813.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
// 14979.1-14979.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
// 14980.1-14980.144: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
// 15095.1-15095.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
// 15096.1-15096.136: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
// 15097.1-15097.144: (26.5): Array Array.Segment.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
// 15211.1-15211.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case J)
// 15212.1-15212.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case K)
// 15213.1-15213.99: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.Segment.SegmentArray (case L)
// 15319.1-15319.140: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
// 15320.1-15320.101: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
// 15321.1-15321.156: (6.5): Value.x is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
// 15468.1-15468.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case C)
// 15620.1-15620.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case D)
// 15621.1-15621.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Value.x (case R)
// 15726.1-15726.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case F)
// 15727.1-15727.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case H)
// 15728.1-15728.144: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Value.x (case I)
// 15832.1-15832.136: (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
// 15833.1-15833.136: (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
// 15834.1-15834.99: (6.5): Value.x is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
// 15940.1-15940.140: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
// 15941.1-15941.101: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
// 15942.1-15942.156: (28.5): Segment.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
// 16089.1-16089.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case C)
// 16241.1-16241.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case D)
// 16242.1-16242.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Segment.segments (case R)
// 16347.1-16347.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case F)
// 16348.1-16348.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case H)
// 16349.1-16349.144: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Segment.segments (case I)
// 16453.1-16453.136: (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
// 16454.1-16454.136: (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
// 16455.1-16455.99: (28.5): Segment.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
// 16566.1-16566.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
// 16567.1-16567.101: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
// 16568.1-16568.156: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
// 16722.1-16722.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
// 16881.1-16881.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
// 16882.1-16882.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
// 16992.1-16992.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
// 16993.1-16993.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
// 16994.1-16994.144: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
// 17103.1-17103.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
// 17104.1-17104.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
// 17105.1-17105.99: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
// 17211.1-17211.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
// 17212.1-17212.101: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
// 17213.1-17213.158: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
// 17360.1-17360.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
// 17512.1-17512.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
// 17513.1-17513.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
// 17618.1-17618.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
// 17619.1-17619.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
// 17620.1-17620.146: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
// 17724.1-17724.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
// 17725.1-17725.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
// 17726.1-17726.99: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
// 17837.1-17837.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.1)
// 17838.1-17838.101: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.2)
// 17839.1-17839.156: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case A.3)
// 17993.1-17993.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
// 18152.1-18152.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
// 18153.1-18153.144: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
// 18263.1-18263.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
// 18264.1-18264.136: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
// 18265.1-18265.144: (52.5): ConcurrentHashMap.segments is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
// 18374.1-18374.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case J)
// 18375.1-18375.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case K)
// 18376.1-18376.99: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to ConcurrentHashMap.segments (case L)
// 18487.1-18487.140: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
// 18488.1-18488.101: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
// 18489.1-18489.156: (6.5): Value.x is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
// 18643.1-18643.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case C)
// 18802.1-18802.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case D)
// 18803.1-18803.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Value.x (case R)
// 18913.1-18913.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case F)
// 18914.1-18914.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case H)
// 18915.1-18915.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Value.x (case I)
// 19024.1-19024.136: (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
// 19025.1-19025.136: (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
// 19026.1-19026.99: (6.5): Value.x is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
// 19137.1-19137.140: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
// 19138.1-19138.101: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
// 19139.1-19139.156: (28.5): Segment.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
// 19293.1-19293.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case C)
// 19452.1-19452.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case D)
// 19453.1-19453.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Segment.segments (case R)
// 19563.1-19563.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case F)
// 19564.1-19564.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case H)
// 19565.1-19565.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Segment.segments (case I)
// 19674.1-19674.136: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
// 19675.1-19675.136: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
// 19676.1-19676.99: (28.5): Segment.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
// 19792.1-19792.140: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
// 19793.1-19793.101: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
// 19794.1-19794.156: (26.5): Array Array.Segment.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
// 19955.1-19955.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case C)
// 20121.1-20121.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case D)
// 20122.1-20122.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.Segment.SegmentArray (case R)
// 20237.1-20237.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case F)
// 20238.1-20238.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case H)
// 20239.1-20239.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.Segment.SegmentArray (case I)
// 20353.1-20353.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
// 20354.1-20354.136: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
// 20355.1-20355.99: (26.5): Array Array.Segment.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
// 20466.1-20466.140: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
// 20467.1-20467.101: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
// 20468.1-20468.156: (52.5): ConcurrentHashMap.segments is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
// 20622.1-20622.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case C)
// 20781.1-20781.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case D)
// 20782.1-20782.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to ConcurrentHashMap.segments (case R)
// 20892.1-20892.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case F)
// 20893.1-20893.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case H)
// 20894.1-20894.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to ConcurrentHashMap.segments (case I)
// 21003.1-21003.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
// 21004.1-21004.136: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
// 21005.1-21005.99: (52.5): ConcurrentHashMap.segments is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
// 21121.1-21121.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.1)
// 21122.1-21122.101: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.2)
// 21123.1-21123.156: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case A.3)
// 21284.1-21284.140: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case C)
// 21450.1-21450.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case D)
// 21451.1-21451.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case R)
// 21566.1-21566.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case F)
// 21567.1-21567.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case H)
// 21568.1-21568.144: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Read-Write Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case I)
// 21682.1-21682.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case J)
// 21683.1-21683.136: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case K)
// 21684.1-21684.99: (50.5): Array Array.ConcurrentHashMap.SegmentArray is not Write-Read Stable with respect to Array Array.ConcurrentHashMap.SegmentArray (case L)
// 21691.1-21691.629: (<undefined position>): Object invariant may not hold.
// 21692.1-21692.639: (<undefined position>): Object invariant may not hold.
// 21693.1-21693.689: (<undefined position>): Object invariant may not hold.
// 21715.1-21715.628: (<undefined position>): Object invariant may not hold.
// 21716.1-21716.638: (<undefined position>): Object invariant may not hold.
// 21717.1-21717.688: (<undefined position>): Object invariant may not hold.
// 21738.1-21775.2: (7.32): yields_as clause for Key._lock is not valid
// 21780.1-21812.2: (7.32): yields_as clause for Key._lock is not reflexive
// 21818.1-21818.629: (2.1): Object invariant may not hold.
// 21819.1-21819.639: (2.1): Object invariant may not hold.
// 21820.1-21820.689: (2.1): Object invariant may not hold.
// 21821.1-21885.2: (7.32): yields_as clause for Key._lock is not transitive
// 21904.1-21941.2: (6.5): yields_as clause for Value.x is not valid
// 21946.1-21978.2: (6.5): yields_as clause for Value.x is not reflexive
// 21984.1-21984.629: (6.11): Object invariant may not hold.
// 21985.1-21985.639: (6.11): Object invariant may not hold.
// 21986.1-21986.689: (6.11): Object invariant may not hold.
// 21987.1-22051.2: (6.5): yields_as clause for Value.x is not transitive
// 22071.1-22108.2: (7.32): yields_as clause for Value._lock is not valid
// 22113.1-22145.2: (7.32): yields_as clause for Value._lock is not reflexive
// 22151.1-22151.629: (5.1): Object invariant may not hold.
// 22152.1-22152.639: (5.1): Object invariant may not hold.
// 22153.1-22153.689: (5.1): Object invariant may not hold.
// 22154.1-22218.2: (7.32): yields_as clause for Value._lock is not transitive
// 22238.1-22275.2: (7.32): yields_as clause for HashEntry._lock is not valid
// 22280.1-22312.2: (7.32): yields_as clause for HashEntry._lock is not reflexive
// 22318.1-22318.629: (22.1): Object invariant may not hold.
// 22319.1-22319.639: (22.1): Object invariant may not hold.
// 22320.1-22320.689: (22.1): Object invariant may not hold.
// 22321.1-22385.2: (7.32): yields_as clause for HashEntry._lock is not transitive
// 22404.1-22441.2: (28.5): yields_as clause for Segment.segments is not valid
// 22446.1-22478.2: (28.5): yields_as clause for Segment.segments is not reflexive
// 22484.1-22484.629: (28.36): Object invariant may not hold.
// 22485.1-22485.639: (28.36): Object invariant may not hold.
// 22486.1-22486.689: (28.36): Object invariant may not hold.
// 22487.1-22551.2: (28.5): yields_as clause for Segment.segments is not transitive
// 22571.1-22608.2: (7.32): yields_as clause for Segment._lock is not valid
// 22613.1-22645.2: (7.32): yields_as clause for Segment._lock is not reflexive
// 22651.1-22651.629: (25.1): Object invariant may not hold.
// 22652.1-22652.639: (25.1): Object invariant may not hold.
// 22653.1-22653.689: (25.1): Object invariant may not hold.
// 22654.1-22718.2: (7.32): yields_as clause for Segment._lock is not transitive
// 22736.1-22777.2: (26.5): yields_as clause for Array.Segment.SegmentArray is not valid
// 22778.1-22816.2: (26.5): yields_as clause for Array.Segment.SegmentArray is not reflexive
// 22821.1-22821.629: (26.32): Object invariant may not hold.
// 22822.1-22822.639: (26.32): Object invariant may not hold.
// 22823.1-22823.689: (26.32): Object invariant may not hold.
// 22824.1-22892.2: (26.5): yields_as clause for Array.Segment.SegmentArray is not transitive
// 22911.1-22948.2: (52.5): yields_as clause for ConcurrentHashMap.segments is not valid
// 22953.1-22985.2: (52.5): yields_as clause for ConcurrentHashMap.segments is not reflexive
// 22991.1-22991.629: (52.36): Object invariant may not hold.
// 22992.1-22992.639: (52.36): Object invariant may not hold.
// 22993.1-22993.689: (52.36): Object invariant may not hold.
// 22994.1-23058.2: (52.5): yields_as clause for ConcurrentHashMap.segments is not transitive
// 23078.1-23115.2: (7.32): yields_as clause for ConcurrentHashMap._lock is not valid
// 23120.1-23152.2: (7.32): yields_as clause for ConcurrentHashMap._lock is not reflexive
// 23158.1-23158.629: (48.1): Object invariant may not hold.
// 23159.1-23159.639: (48.1): Object invariant may not hold.
// 23160.1-23160.689: (48.1): Object invariant may not hold.
// 23161.1-23225.2: (7.32): yields_as clause for ConcurrentHashMap._lock is not transitive
// 23243.1-23284.2: (50.5): yields_as clause for Array.ConcurrentHashMap.SegmentArray is not valid
// 23285.1-23323.2: (50.5): yields_as clause for Array.ConcurrentHashMap.SegmentArray is not reflexive
// 23328.1-23328.629: (50.34): Object invariant may not hold.
// 23329.1-23329.639: (50.34): Object invariant may not hold.
// 23330.1-23330.689: (50.34): Object invariant may not hold.
// 23331.1-23399.2: (50.5): yields_as clause for Array.ConcurrentHashMap.SegmentArray is not transitive
// 23419.1-23456.2: (7.32): yields_as clause for Main._lock is not valid
// 23461.1-23493.2: (7.32): yields_as clause for Main._lock is not reflexive
// 23499.1-23499.629: (72.1): Object invariant may not hold.
// 23500.1-23500.639: (72.1): Object invariant may not hold.
// 23501.1-23501.689: (72.1): Object invariant may not hold.
// 23502.1-23566.2: (7.32): yields_as clause for Main._lock is not transitive
